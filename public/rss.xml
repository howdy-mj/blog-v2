
  <rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:media="http://search.yahoo.com/mrss/">
    <channel>
      <title>MJ Kim</title>
      <link>https://www.howdy-mj.me</link>
      <description>안녕하세요, 기록하고 공유하기를 좋아하는 프론트엔드 개발자 김민정입니다.</description>
      <language>ko</language>
      <managingEditor>hi.minjungkim@gmail.com (MJ Kim)</managingEditor>
      <webMaster>hi.minjungkim@gmail.com (MJ Kim)</webMaster>
      <lastBuildDate>Sat, 19 Oct 2024 00:00:00 GMT</lastBuildDate>
      <atom:link href="https://www.howdy-mj.me/rss.xml" rel="self" type="application/rss+xml"/>
      
    <item>
      <guid>https://www.howdy-mj.me/ai/llm-rag-for-beginners</guid>
      <title>LLM과 RAG, 쉽게 이해하기</title>
      <link>https://www.howdy-mj.me/ai/llm-rag-for-beginners</link>
      undefined
      <pubDate>Sat, 19 Oct 2024 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>ai</category>
      <content:encoded>
ChatGPT가 등장하면서 모든 분야가 급격하게 변화하고 있다. 텍스트만 입력하면 영상을 만들어주는 Sora, 기존 노래의 목소리를 다른 인물의 목소리로 바꾸는 AI 커버, 아나운서 말투를 학습한 AI 앵커 등, 여러 분야에서 무서울 정도의 속도로 사람의 자리를 대체하려 하고 있다.

이런 시기에 과연 프론트엔드 개발자는 어떻게 해야 좋을까? 일각에서는 AI 때문에 개발자의 입지가 줄어들고 힘들어질 것이라 생각한다. 실제로 전 세계 많은 IT 기업에서 대규모의 구조조정이 일어나기도 했고, 일어나고 있다.

처음에 나 역시 '언제까지 개발할 수 있을까..'라는 망연자실한 생각이 들었다(사실 지금도 여전히 마음속에 있긴 하다). 그러나 이런 시기일수록 더욱더 이러한 도구를 잘 활용해야 하지 않을까? 라는 생각이 들었고, 곧 'AI랑 친해지기'라는 목표를 세웠다.



해당 글은 관련 개념을 깊게 파고들기보다, (내가 이해할 수 있도록) 최대한 쉽게 정리하는 것이 목표다.

## LLM(Large Language Model, 대규모 언어 모델)

LLM은 개발자라면 한 번이라도 써봤을 ChatGPT, 그리고 얼핏 이름을 들어봤을 법한 Claude, Gemini 등의 서비스가 있다.

가장 큰 특징이라면, 이들은 보통 수십억에서 수조 개의 토큰(단어, 스페이스, 특수 문자 등)을 학습한 모델이다. 여기서 학습은 컴퓨터가 사람처럼 언어를 이해하고 생성하도록 훈련하는 과정이라 볼 수 있다.

한국어를 모르는 컴퓨터에 '안녕하세요'라는 단어를 주면 이게 어떤 뜻인지 알지 못한다. 따라서 ['안', '녕', '하', '세', '요'] 이렇게 작은 단위로 나누는데 이를 토큰화(Tokenization)라고 한다. 그리고 이 토큰은 컴퓨터가 이해할 수 있는 숫자 형태로 변환된다.

그리고 수집한 다양한 데이터에서 '안녕' 다음에 '하세요'가 자주 등장한다는 사실을 배운다. 이렇게 많은 문장을 반복적으로 학습하면서, 한국어의 문법, 문장 구조, 맥락 등을 이해한다. 이처럼 학습한 내용을 바탕으로 다음 단어를 예측할 수 있게 된다. 그리고 이처럼 예측하는 방식은 `가중치(weights)`를 학습하는 과정이라고 볼 수 있다.

최초에는 모델이 가중치를 무작위로 초기화한다. 따라서 처음에는 입력한 내용을 제대로 이해하거나 예측할 수 없다. 수많은 데이터를 학습하면서 가중치를 조정하며 '안녕' 다음에는 '하세요'가 나오는 값을 찾게 된다. LLM의 핵심은 이 가중치에 있다고 보면 된다. 따라서 이 가중치는 공개하는 모델은 많지 않다.

이처럼 LLM은 방대한 양의 데이터를 학습해야 하므로 실시간 업데이트가 불가하다.


  
  https://platform.openai.com/docs/models/gpt-4o


위는 gpt-4o에 대한 설명인데, 제일 우측 'TRAINING DATA'를 보면 날짜가 쓰여 있다. 이는 이날까지 학습한 데이터를 뜻하는데, gpt-4o도 2023년 10월까지의 데이터이기 때문에 올해 업데이트된 내용은 모른다.

이미 방대한 양의 데이터를 학습했기 때문에 대부분의 질문에는 잘 대답할 것이다. 하지만 만약 특정 도메인에 대한 학습이 충분하지 않을 경우 엉뚱한 답변을 할 때가 있고, 아예 거짓된 정보(Hallucination, 환각)를 반환할 때도 있다. 이 때문에 RAG라는 개념이 등장했다.

## RAG(Retrieval-Augmented Generation, 검색 증강 생성)

RAG는 정보 검색(Retrieval)과 언어 생성(Generation)을 결합한 방식으로, 사용자가 질문하면 모델이 먼저 외부 데이터베이스에서 문서를 검색한 후, 검색한 정보를 바탕으로 응답을 생성한다. 즉, RAG는 기존에 갖고 있는 데이터와 외부에서 검색한 정보를 통합하여 답변을 생성한다. 덕분에 모델이 최신 정보에 대한 답변을 줄 수도 있고, 할루시네이션도 줄어들었다.



그렇다면 RAG에서 말하는 외부 데이터는 무엇일까?

만약 회사에서 LLM을 도입한다고 가정해 보자. 대부분의 회사가 정보 유출 때문에 공개된 LLM보다는, 내부에 직접 LLM을 구축하여 회사 내부 데이터(ex. 사내 규율, 조직도, 프로젝트 정책 등)을 학습시킬 것이다. 그리고 이 데이터는 Wiki, Notion 혹은 Word, PDF 등 여러 가지 형태의 데이터가 있을 텐데, 바로 이 데이터를 외부 데이터(DB화된 데이터)라 한다.

하지만 LLM이 바로 Wiki나 Notion을 검색할 수는 없다. 이 데이터들을 LLM이 검색하기 쉽도록 DB화해야 하는데, 이때 효율적인 정보 검색을 위해 보통 벡터 데이터베이스(Vector Database)를 구축한다.

벡터 데이터베이스는 일종의 '디지털 책장'처럼 생각할 수 있다. 각 책(데이터)을 벡터로 변환하고, 이 벡터들은 비슷한 주제의 책들이 같은 선반에 배치되듯 유사한 의미의 데이터들이 가까이 위치하게 된다. 이런 구조 덕분에 찾고자 하는 데이터와 유사한 주제의 데이터를 빠르게 찾아낼 수 있게 된다.

사내에 있는 데이터를 벡터(임베딩)로 변환한다. 벡터는 텍스트의 의미를 숫자 배열로 표현한 것으로, 의미적으로 유사한 데이터는 벡터 공간에서 가깝게 위치하게 된다. '프로젝트 A의 2023 매출 보고서'와 '프로젝트 B의 2023 매출 보고서'는 벡터 공간에서 가까운 위치에 있다. 그리고 이런 벡터 표현을 저장한 DB를 구축한다. 이 DB는 벡터 간의 유사도를 빠르게 계산하고, 가장 관련성 높은 데이터를 검색할 수 있도록 설계되어 있다. 이를 통해 전체 텍스트를 매번 읽고 분석하는 대신, 유사도 검색을 통해 필요한 데이터만 효율적으로 찾아낼 수 있다.

사용자가 질문하면 그 질문 역시 벡터로 변환된다. 그리고 이렇게 변환된 질문 벡터를 벡터 DB에서 유사한 벡터를 검색하는 데 사용된다. 그리고 벡터 DB에서 유사도가 가장 높은 벡터(데이터)를 빠르게 찾아낸다. 주로 가장 관련성 높은 상위 몇 개의 문서로 제한하기 때문에 전체 데이터를 검색하지 않는다. 이렇게 검색된 상위 문서들은 RAG의 '검색 결과'로 사용된다. 그 이후, 언어 모델은 검색된 정보를 기반으로 질문에 대한 응답을 생성한다.



우리가 사용해 볼 수 있는 RAG를 적용한 서비스에는 [Microsoft Bing Chat](https://www.bing.com/chat), [Perplexity AI](https://www.perplexity.ai/)(실시간으로 외부 정보와 문서를 검색해 답변 생성), [Humata AI](https://www.humata.ai/)(논문, 기술 문서 등 문서 내 정보를 검색하여 요약 및 해석) 등이 있다.

하지만 RAG도 한계는 존재한다. 만약 실시간으로 업데이트가 필요할 경우 매번 임베딩 및 벡터 DB를 구축해야 하므로 RAG를 사용하기에는 적합하지 않다. 따라서 RAG는 상대적으로 업데이트가 자주 안 일어나는 정적인 문서들에 대해서만 가능하다.

## 그 외...

텍스트로만 대화할 수 있었던 ChatGPT에 어느 순간 이미지도 업로드 가능하게 되었다. 이와 같이 두 개 이상의 데이터 유형을 동시에 처리할 수 있는 것을 멀티 모달 AI(Multi Modal AI)라 부른다. 최근에 주목된 멀티 모달 AI로는 문서를 기반으로 두 명이 팟캐스트 형식으로 대화하는 음성을 만들어주는 [NotebookLM](https://notebooklm.google/)이 있다.



그리고 최근에 AI Agent라는 단어가 보이고 있는데, 이는 AI가 목표를 달성하기 위해 자율적으로 학습하고 의사 결정을 해서 행동한다. 하지만 AI가 모든 것을 다 해주는 것은 아니고, 사람이 컴퓨터로 할 수 있는 업무를 GPT가 할 수 있다.

가장 먼저 떠올릴 수 있는 건 영화 Her에서 나오는 가상 비서인 것 같다. 머지않은 미래에 Siri나 빅스비에 '여름휴가 계획 세워줘'라고 말하면 유저의 여행 패턴을 기반으로 가장 적합한 계획을 짜오고 결제까지 완료해 주지 않을까 한다. (만약 이런 날이 온다면 검색 플랫폼을 포함해서 지금 우리가 너무 당연하게 사용하고 있는 다른 서비스들도 없어지지 않을까?)

지금 가장 유명한 AI Agent 프레임워크로는 [LangChain](https://python.langchain.com/v0.2/docs/introduction/), [LangGraph](https://www.langchain.com/langgraph), [CrewAI](https://www.crewai.com/), [Microsoft AutoGen](https://microsoft.github.io/autogen/)이 있다.

## 마치며

프론트엔드 기술이 격변하는 시기에 관련 기술들의 업데이트를 좇아가고 이해하는데 벅차다는 생각이 들었다. 조금 익숙해질 찰나에 새로운 기술이 나오고, 이를 학습하고 다시 반복되었다. 그런데 그때보다 현재의 LLM 쪽이 더 변화무쌍한 것 같다. 또한 이들이 얼마나 발전해서 나왔느냐에 따라 과장되게는 스타트업의 BM을 쉽게 따라 할 수 있게 해주는 것 같다.

실제로 몇 년은 더 거릴 줄 알았던 기술이 최근에 [Aria와 같은 오픈 소스로 공개](https://brunch.co.kr/@namojo/33) 되었다. 동영상의 편집점을 찾고 요약하는 것은 꽤 까다로운 기술 중 하나라고 생각했는데, 오픈소스로 풀리다니 놀랍기도 하면서 무섭기도 하고 한 편으로는 다음에는 어떤 대단한 모델이 나올지 기대도 된다.
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/css/styled-components-to-stylex</guid>
      <title>Styled Components를 StyleX로 바꿔보기</title>
      <link>https://www.howdy-mj.me/css/styled-components-to-stylex</link>
      <description>Next.js에서 styled-components를 StyleX로 변경하면서 느낀점</description>
      <pubDate>Sat, 30 Mar 2024 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>css</category><category>css-in-js</category>
      <content:encoded>
예전부터 사이드 프로젝트를 할 때 주로 Next.js + Typescript + styled-components 조합으로 만들다보니, 해당 조합이 자연스럽게 나의 보일러플레이트가 되었다. 그런데 최근 React 서버 컴포넌트가 나오면서 스타일링 라이브러리를 바꿔야 하는 고민이 들기 시작했다.

styled-components는 클라이언트 런타임에서 동작하기 때문에, 서버 컴포넌트에서 사용을 못한다. Next.js 14로 올라오면서 [서버 컴포넌트를 default로 사용](https://nextjs.org/docs/app/building-your-application/rendering/server-components#using-server-components-in-nextjs) 중인데, 클라이언트 로직이 아무것도 없음에도 단지 styled-components 때문에 `use client`를 입력하고 있을 때 약간(이 아니고 많은) 아쉬움이 들었다.

이에 이전에 시도했다가 나랑 잘 맞지 않던 tailwind를 다시 시도해볼까 하다가, 새로운 라이브러리를 사용해보자 싶어서 비슷한 컨셉의 unocss 사용해봤다. 그러나 여전히 나에게는 맞지 않았다.

그러다 최근 사내 FE 그룹 발표에서 한 분이 StyleX를 발표 했었는데, 제로 런타임이라는걸 보고 갑자기 써보고 싶다는 생각이 들었다. 사실 v1.0 이 되지 않은 라이브러리는 사용을 잘 안하는 편인데, 메타가 만들기도 했고 리액트 서버 컴포넌트가 나왔으니 계속 개발을 해줄 것이라는 믿음이 갖고 한 번 과감히 (물론 혼자하는 사이드 프로젝트에서) 사용해보기로 했다.

## StyleX로 변경하면서 느낀 점들

> 해당 글에서는 StyleX의 소개나 특징을 나열하기보다는, Next.js에서 styled-components를 StyleX로 마이그레이션하면서 느낀 점들을 위주로 작성했다.

styled-components만 오랫동안 쓰다 넘어가는 입장에서 '이게 안돼?' 혹은 '이걸 이렇게 해야돼?' 싶은 것들이 좀 있었다.

아직 실제 사용해본 후기가 많지 않다보니 삽질을 좀 많이 했다(공식문서를 꼼꼼히 읽어봤으면 덜 했을 것 같다..). 혹은 해당 글의 해결책보다 더 쉬운 방법이 있을 수 있는데, 못 찾은 걸 수도 있다.



변경하면서 느낀 점들을 크게 몇 가지 섹션으로 나눠봤다.

## 1. swc 대신 babel을 사용하여 생기는 아쉬움

Next.js가 12으로 올라오면서 기본 컴파일러를 swc로 바꿨는데, StyleX를 사용하기 위해서는 babel를 써야했다. 이로 인해 초기 설정에 생각보다 해줘야 하는게 조금 있다.

### .babelrc.js 생성 및 next.config.js 수정

[공식문서](https://stylexjs.com/docs/learn/installation/#production)에도 예시가 나와 있으며, 내가 작성한 코드는 아래와 같다.

```sh
pnpm install --save-dev @stylexjs/nextjs-plugin
```

```js:.babelrc.js
const path = require('path');
module.exports = {
  presets: ['next/babel'],
  plugins: [
    [
      '@stylexjs/babel-plugin',
      {
        dev: process.env.NODE_ENV === 'development',
        runtimeInjection: false,
        genConditionalClasses: true,
        treeshakeCompensation: true,
        aliases: {
          '@/*': [path.join(__dirname, '*')],
        },
        unstable_moduleResolution: {
          type: 'commonJS',
          rootDir: __dirname,
        },
      },
    ],
  ],
};
```

```js:next.config.js
const path = require('path');
const stylexPlugin = require('@stylexjs/nextjs-plugin');

/** @type {import('next').NextConfig} */
const nextConfig = {
};

module.exports = stylexPlugin({
  aliases: {
    '@/*': [path.join(__dirname, '*')],
  },
  rootDir: __dirname,
})(nextConfig);
```

### 런타임에 스타일 주입 설정

여태 주로 사용했던 스타일 라이브러리로는 전부 HMR를 지원해서 신경 쓸 필요가 없었다. 그러나 StyleX는 컴파일 단계에서 스타일이 처리되기 때문에, 수정 후에 다시 페이지를 빌드해야 한다.

다행히 `@stylexjs/babel-plugin`에 `runtimeInjection` 설정이 있었다. 이는 런타임에 스타일 주입 여부를 설정하는 것으로, 개발 환경에서만 사용을 권장하고 있다.

```js:.babelrc.js {12}
const path = require('path');

const IS_DEV = process.env.NODE_ENV === 'development';

module.exports = {
  presets: ['next/babel'],
  plugins: [
    [
      '@stylexjs/babel-plugin',
      {
        dev: IS_DEV,
        runtimeInjection: IS_DEV,
        // ... 생략
      },
    ],
  ],
};
```

근데 가끔 텍스트 색상 같이 정말 단순한 수정 작업에 컴파일이 오래 걸리거나(3초), 컴파일이 끝났음에도 스타일이 변경되지 않은 적이 있었다. 아직 원인은 찾지 못했다.

만약 로컬에서 컴파일러를 아예 사용하고 싶지 않은 경우, [@stylexjs/dev-runtime](https://stylexjs.com/docs/learn/installation/#local-development-only) 라이브러리도 지원해주기 때문에 참고해서 적용하면 될 것 같다.

### server action, next/font 사용 불가

사이드 프로젝트에서는 최대한 공식문서에서 업데이트된 최신 기능을 모두 사용해보려 노력하는 편이다.

이번에 사용해보고 싶었던 기능 중 하나는 Next.js의 Server Actions인데 올라온 [이슈](https://github.com/facebook/stylex/issues/309)를 보면 안타깝게도 아직 babel 환경에서 지원하지 않는다. 그리고 next/font 역시 swc만 지원하기 때문에 [사용이 불가](https://github.com/facebook/stylex/issues/190)하다. (아직 사용해보지 않은 기능들도 많은데, 발견하게 되면 추후에 업데이트 하겠다)

다행히 StyleX 측에서 Vercel과 얘기중이라고 하니 조만간 해결될 수 있지 않을까 한다.

## 2. 초기 세팅

### reset 및 global css 작성

기존 styled-components를 사용할 때는, styled-reset 라이브러리를 사용하거나 `reset.ts`에 필요한 내용들만 생성한 후, `createGlobalStyle`에서 최상단에 작성한 후 커스텀 스타일로 오버라이딩하는 방식으로 사용했다.

```ts
// styles/reset.ts
export const reset = css``;

// styles/global.ts
export const GlobalStyle = createGlobalStyle`
  ${reset};

  // 커스텀 css
`;

// apps/layout.tsx
export default function RootLayout({
  children,
}: Readonly) {
  return (
    
      
        
          
          {children}
        
      
    
  );
}
```

그런데 StyleX 공식문서에 전역으로 스타일 설정하는 내용을 찾을 수 없었다. 아니나 다를까 공식문서에서 [Avoid global configuration](https://stylexjs.com/docs/learn/thinking-in-stylex/#avoid-global-configuration) 섹션을 찾을 수 있었다. 전역 설정을 지양하는 대신, 어느 프로젝트에서든 일관된 스타일로 동작하는 것을 지향하고 있다.

프로젝트 최초에 styled-components에서 전역 스타일로 설정하고, 나중에 작성한 코드를 봤을 때 전역에 설정해둔 스타일을 까먹고 엄한 곳만 삽질했던 기억이 있어서 공감이 갔다. 그리고 사실 styled-component에서 전역 스타일 설정하고, SSR에서 [클라이언트에 스타일 주입](https://nextjs.org/docs/app/building-your-application/styling/css-in-js#styled-components) 등 일련의 작업보다는 StyleX가 보다 더 직관적이고 간단한 것 같다.

어떻게 수정하는게 좋을지 조금 고민하다가 아래 방법으로 변경했다.

```css:src/apps/global.css
@layer reset, custom;

@layer custom {
  /* 커스텀 css */
}

@layer reset {
  /* reset css */
}
```

```tsx:src/apps/layout.tsx
import './global.css';

export default function RootLayout({
  children,
}: Readonly) {
  return (
    
      {children}
    
  );
}
```

### StyleX용 eslint 설치

StyleX의 컴파일러가 스타일 검증까지 해주지 않기 때문에, 유효하지 않은 스타일을 넣을 수 있다. 따라서 별도의 ESLint 설정이 필요하다.

```sh
npm install --save-dev @stylexjs/eslint-plugin
```

```json:.eslintrc.json
{
  "extends": "next/core-web-vitals",
  "plugins": ["@stylexjs"],
  "rules": {
    "@stylexjs/valid-styles": "error"
  }
}
```



이 외로, VSCode를 사용중이라면 [StyleX Intellisense](https://marketplace.visualstudio.com/items?itemName=yash-singh.stylex) 익스텐션이 있다. 하지만 공식 문서에서도 experimental 익스텐션이라 할 정도로 아직 지원하는 기능이 많진 않다.

## 3. styled-components와 대비되는 점

변경을 진행했던 코드 일부를 가져왔다.

간단하게 메인 페이지에 LayoutWithGnb 컴포넌트를 이용해 Gnb와 컨텐츠를 렌더링해주고 있다. LayoutWithGnb 컴포넌트 내부에는 TopNavigationBar, BottomNavigationBar가 있다. (해당 글에서 필요없는 코드는 임의로 줄이거나 삭제했다)

화면은 아래와 같다.


  
  메인 화면


```tsx:src/components/LayoutWithGnb.tsx
'use client';

import styled from 'styled-components';
import TopNavigationBar from './TopNavigationBar';
import BottomNavigationBar from './BottomNavigationBar';
import { PropsWithChildren } from 'react';

const Container = styled.div``;

const ContentWrapper = styled.div`
  ${(p) =>
    p.$isScrollable &&
    css`
      position: relative;
      overflow: scroll;
    `};
`;

const LayoutWithGnb = ({
  showTop = true,
  title,
  showBottom = true,
  isScrollable = true,
  children,
}: PropsWithChildren) => {
  return (
    
      {showTop && }
      {children}
      {showBottom && }
    
  );
};

export default LayoutWithGnb;
```

```tsx:src/components/TopNavigationBar.tsx
'use client';

import { useParams, useRouter } from 'next/navigation';
import styled, { css } from 'styled-components';
import { IoIosArrowBack, IoIosSettings } from 'react-icons/io';
import { MAX_WIDTH } from '@/styles/globalStyle';

export const TOP_NAVIGATION_BAR_HEIGHT = '5rem';

const Container = styled.div`
  height: ${TOP_NAVIGATION_BAR_HEIGHT};
  width: 100%;
  max-width: ${MAX_WIDTH};
  box-shadow: rgba(17, 17, 26, 0.1) 0 0 5px 0;
  background-color: ${(p) => p.theme.colors.white};
  z-index: 1;
`;

const Wrapper = styled.div`
  display: flex;
  align-items: center;
  height: 100%;
`;

const CurrentTitle = styled.h2`
  margin-left: 1rem;
  font-weight: bold;
`;

const BackButtonWrapper = styled.div`
  display: flex;
  margin-left: 1rem;
`;

const iconCss = css`
  font-size: 2.2rem;
  cursor: pointer;
`;

const ArrowBackIcon = styled(IoIosArrowBack)`
  ${iconCss};
`;

const BackButtonSection = () => {
  const router = useRouter();
  if (isVisibleBackButton(params)) {
    return (
       {
          router.back();
        }}
      >
        
      
    );
  }

  return ;
};

type TopNavigationBarProps = {
  title?: string;
};

const TopNavigationBar = ({ title }: TopNavigationBarProps) => {
  return (
    
      
        
        {title ?? '페이지명'}
      
    
  );
};

export default TopNavigationBar;
```

```tsx:src/components/BottomNavigationBar.tsx
'use client';

import { usePathname, useRouter } from 'next/navigation';
import styled from 'styled-components';
import { ROUTES } from '@/constants/routes';
import { MAX_WIDTH } from '@/styles/globalStyle';
import { IoMdHome, IoIosStar, IoMdSettings } from 'react-icons/io';

export const BOTTOM_NAVIGATION_BAR_HEIGHT = '6rem';

const Container = styled.nav`
  position: fixed;
  bottom: 0;
  width: 100%;
  height: ${BOTTOM_NAVIGATION_BAR_HEIGHT};
  max-width: ${MAX_WIDTH};
  box-shadow: rgba(17, 17, 26, 0.1) 0 0 5px 0;
  background-color: ${(p) => p.theme.colors.white};
`;

const NavWrapper = styled.ul`
  display: flex;
  align-items: center;
  height: 100%;

  & > * {
    width: 50%;

    &:not(:last-child) {
      content: '';
      border-right: 1px solid ${(p) => p.theme.colors.grey100};
    }
  }
`;

const TabWrapper = styled.li`
  & > * {
    display: flex;
    justify-content: center;
    margin: 0 auto;
    color: ${(p) => (p.$isActive ? 'green' : '')};
  }

  .icon {
    font-size: 2.5rem;
  }
`;

const TabText = styled.span`
  font-size: 1.2rem;
`;

const BottomNavigationBar = () => {
  const router = useRouter();
  const pathname = usePathname();
  return (
    
      
        {navList.map((item) => (
           {
              router.push(item.path);
            }}
            $isActive={pathname === item.path}
          >
            {item.icon}
            {item.text}
          
        ))}
      
    
  );
};

export default BottomNavigationBar;
```

### 공통으로 사용되는 스타일을 다른 요소에 적용하는 법

나는 보통 styled-components에서 공통된 스타일이 있을 때 변수로 선언한 후에, 해당 스타일을 필요로 하는 곳의 최상단에 이걸 넣어주어 사용했다.

```tsx:src/components/TopNavigationBar.tsx
import { IoIosArrowBack, IoIosSettings } from 'react-icons/io';

// 여러 개의 아이콘이 존재할 수 있으니 iconCss로 공통 css를 생성하고 적용
const iconCss = css`
  font-size: 2.2rem;
  cursor: pointer;
`;

const ArrowBackIcon = styled(IoIosArrowBack)`
  ${iconCss};
`;

const BackButtonSection = () => {
  return ;
};
```

그래서 처음에 StyleX에서도 이와 비슷한 방식으로 접근했다.

```tsx:src/components/TopNavigationBar.tsx {10}
const iconStyle = stylex.create({
  base: {
    fontSize: '2.2rem',
    cursor: 'pointer',
  },
});

const backButtonStyle = stylex.create({
  backIcon: {
    ...iconStyle.base, // 에러
  },
});

const BackButtonSection = () => {
  return (
    
  );
};
```

그런데 이렇게 하니 A style value can only contain an array, string or number. 에러가 떴다.

위의 `iconStyle.base`만 보면 value가 모두 string이라 에러가 안나야 할 것 같아서, 이를 콘솔로 찍어봤다.


  
  iconStyle.base 로그


그랬더니 `$$css: true`라는 값이 들어가 있는 걸 확인할 수 있었다. 아마 컴파일 단계에서 표시를 위해 추가한 것으로 추측되어 이를 찾아보니, `styleXCreateSet` 함수에서 찾을 수 있었다.

```js:stylex/packages/shared/src/stylex-create.js {20}
// https://github.com/facebook/stylex/blob/main/packages/shared/src/stylex-create.js#L76

// 이는 stylex.create에 전달된 스타일 객체를 변환하며, 스타일 값들을 클래스명으로 교체한다.
//
// 또한, 그 과정에서 모든 주입된 스타일들을 수집한다.
// 그런 다음 변환된 스타일 객체와 주입된 스타일들의 객체로 구성된 튜플을 반환한다.
//
// 이 함수는 기본적인 검증을 수행하고, 각 네임스페이스를 변환하기 위해 styleXCreateNamespace를 사용한다.
//
// 반환하기 전에, 중복되는 스타일이 주입되지 않도록 합니다.
export default function styleXCreateSet(
  namespaces: { +[string]: RawStyles },
  options?: StyleXOptions = defaultOptions,
): [{ [string]: FlatCompiledStyles }, { [string]: InjectableStyle }] {
  const resolvedNamespaces: { [string]: FlatCompiledStyles } = {};
  const injectedStyles: { [string]: InjectableStyle } = {};

  for (const namespaceName of Object.keys(namespaces)) {
    // ...
    resolvedNamespaces[namespaceName] = { ...namespaceObj, $$css: true };
  }

  return [resolvedNamespaces, injectedStyles];
}
```

따라서 하나의 요소에 다른 여러 스타일을 적용하기 위해서라면, 공식문서에서 명시하고 있는 [Merging Style](https://stylexjs.com/docs/learn/styling-ui/using-styles/#merging-styles)처럼 여러 style을 주입해줘야 한다.

```tsx:src/components/TopNavigationBar.tsx
const iconStyle = stylex.create({
  base: {
    fontSize: '2.2rem',
    cursor: 'pointer',
  },
});

const backButtonStyle = stylex.create({
  backIcon: {},
});

const BackButtonSection = () => {
  return (
    
  );
};
```

보통 스타일 코드를 상단이나 하단에 몰아두고, 컴포넌트 내부에서는 신경 안쓰이게 하는 편인데, 위처럼 하게 될 경우 `iconStyle`을 어디에서 사용 중인지 확인하기 위해 컴포넌트 내부를 봐야하기 때문에 약간의 피로도가 있지 않을까 생각이 든다.

### 기존 컴포넌트의 스타일 오버라이딩

styled-components에서는 기존 컴포넌트의 스타일에서 특정 스타일만 수정하고 싶을 때, 이미 존재하는 [className 속성을 활용](https://styled-components.com/docs/advanced#existing-css)하면 바로 오버라이딩할 수 있다.

하지만 StyleX는 이 방식처럼 부모 컴포넌트에서 `stylex.props(새로운 스타일)`로 할 경우, '늘 마지막 스타일이 적용된다(the last style applied always wins)'는 원칙에 의거하여 오버라이딩이 아니라 덮어 씌워진다.

```tsx
import Button from '@/components/Button';

// 1. styled-compoents
// 기존 Button 컴포넌트에 선언한 스타일에 아래 스타일이 오버라이딩 된다.
const StyledButton = styled(Button)`
  height: 5rem;
  width: 5rem;
  border-radius: 50%;
`;

// 2. StyleX
// 기존 Button 컴포넌트의 스타일은 무시되며 style.button 스타일만 적용된다.

  {/* 생략 */}
;
```

따라서 StyleX에서 스타일 오버라이딩을 원할 때에는, style 자체를 넘겨줘야 한다.

```tsx {8,19}
// 부모 컴포넌트

  {/* 생략 */}
;

// 자식 컴포넌트 (Button)
type ButtonProps = {
  overrideStyle?: stylex.StyleXStyles;
};

const Button = ({ overrideStyle, children, ...restProps }: PropsWithChildren) => {
  return (
    
      {children}
    
  );
};
```

그런데 이렇게 할 경우, 스타일 오버라이딩이 필요한 컴포넌트에서 매번 인터페이스를 뚫어줘야하기 때문에 불편한 것 같다.

물론 `PropsWithStyle` 같은 공용 인터페이스를 만든 후 사용해도 되지만, 컴포넌트 내부에서 주입받은 값을 요소에 넘겨줘야하니 한 번은 더 신경써야 한다.

### 외부에서 import 해온 변수 사용 불가

전체 애플리케이션에서 설정해둔 `MAX_WIDTH`를 가끔 컴포넌트 내부에서도 사용해야할 때가 있다.

```tsx:src/components/TopNavigationBar.tsx {2, 5, 19}
// 수정 전
import { MAX_WIDTH } from '@/styles/globalStyle';

const Container = styled.div`
  max-width: ${MAX_WIDTH};
`;

const TopNavigationBar = ({ title }: TopNavigationBarProps) => {
  return (
    
      {/* 생략 */}
    
  );
};

// 수정 후
const styles = stylex.create({
  container: {
    maxWidth: MAX_WIDTH,
  },
});

const TopNavigationBar = ({ title }: TopNavigationBarProps) => {
  return (
    
      {/* 생략 */}
    
  );
};
```

하지만 이를 StyleX에서 바로 사용하면 Only static values are allowed inside of a stylex.create() call. 에러가 뜬다.

StyleX의 [discssion](https://github.com/facebook/stylex/discussions/227)을 찾아보니, StyleX는 컴파일러이기 때문에 모든 변수가 로컬에 정의되어 있어야 하며, 예외 케이스는 오직 `*.styles.ts(x)` 파일에 [defineVars()](https://stylexjs.com/docs/learn/theming/defining-variables/)를 이용해 선언한 변수뿐이다. `defineVars()`로 선언한 변수는 컴파일 단계에서 실제로 파일의 내용을 읽어오는 것이 아니라, import할 이름과 파일 경로를 사용해 해시 알고리즘을 통해 주입할 변수명을 생성한다.

```ts:styles/theme.stylex.ts
const MAX_WIDTH = '64rem';
export const viewport = defineVars({
  maxWidth: MAX_WIDTH,
});
```

```tsx:src/components/TopNavigationBar.tsx {3}
const styles = stylex.create({
  container: {
    maxWidth: viewport.maxWidth,
  },
});

const TopNavigationBar = ({ title }: TopNavigationBarProps) => {
  return (
    
      {/* 생략 */}
    
  );
};
```

보통 해당 변수가 실제로 사용 되는 파일 내부에 선언 후 export해서 사용했는데, 오랜만에 수정이 필요할 때 어디에 있었는지 바로 기억이 나지 않아 여기저기 파일을 열어 봐야했다. 그런데 `defineVars()`를 사용하다보니 자연스레 관련 변수들을 동일한 파일에 넣으니 그 번거로움도 없어졌다.

### ThemeProvider 보다 편한 defineVars

위에서 나온 `defineVars()`로 전역에서 사용해야 하는 값을 쉽게 import 해서 사용할 수 있다.

styled-components는 루트에서 ThemeProvider와 미리 설정한 theme을 넘겨준 후, 스타일 내부에서 props로 받아 사용할 수 있다.
한 두 줄이라면 상관없지만, 한 컴포넌트 내에서 조건부로 스타일을 수정해야할 일이 많거나, 여러 props를 사용해야 한다면 좀 번거로워진다.

```tsx:src/components/TopNavigationBar.tsx {7}
// 수정 전
const Container = styled.div`
  height: ${TOP_NAVIGATION_BAR_HEIGHT};
  width: 100%;
  max-width: ${MAX_WIDTH};
  box-shadow: rgba(17, 17, 26, 0.1) 0 0 5px 0;
  background-color: ${(p) => p.theme.colors.white};
  z-index: 1;
`;

const TopNavigationBar = ({ title }: TopNavigationBarProps) => {
  return (
    
      {/* 생략 */}
    
  );
};
```

또한 타입스크립트를 사용하면 `DefaultTheme`의 [선언 병합](https://styled-components.com/docs/api#typescript)이 필요하다.

그에 반해 `defineVars()`는 변수로 선언하면 타입 추론이 매우 잘되어, 따로 타입을 신경 쓸 필요가 없다.

```ts:styles/theme.stylex.ts
export const colors = defineVars({
  white: '#ffffff',
  // ...
});
```

```tsx:src/components/TopNavigationBar.tsx {8}
// 수정 후
const styles = stylex.create({
  container: {
    height: size.topGnbHeight,
    width: '100%',
    maxWidth: viewport.maxWidth,
    boxShadow: 'rgba(17, 17, 26, 0.1) 0 0 5px 0',
    backgroundColor: colors.white,
    zIndex: 1,
  },
});

const TopNavigationBar = ({ title }: TopNavigationBarProps) => {
  return (
    
      {/* 생략 */}
    
  );
};
```

그리고 위처럼 `defineVar()`로 선언한 것을 불러오니 작성해야 할 반복 코드가 줄어들어 이전보다 깔끔해 보인다.

### 스타일을 묶을 수 있음

styled-components를 사용할 경우, 엘리먼트 단위로 만들어줘야 했기 때문에 응집도가 높은 요소들의 스타일링을 묶이게끔 표현하려면, 개행을 안하거나 주석을 달아야 했다.

```tsx
// styled-components
const Container = styled.div``;

// ...다른 스타일

const StyledModal = styled(Modal)``;
const ModalHeader = styled.h4``;

const CreateItemModal = () => {
  return (
    
      {/* 다른 엘리먼트 */}
      모달 제목}>{/* 생략 */}
    
  );
};
```

그런데 StyleX는 스타일별로 나눠서 생성할 수 있어서 더 편한 것 같다.

```tsx
// StyleX
const style = stylex.create({
  container: {},
  // ...다른 스타일
});

const modalS = stylex.create({
  base: {},
  header: {},
});

const CreateItemModal = () => {
  return (
    
      {/* 다른 엘리먼트 */}
      모달 제목}
        {...stylex.props(modalS.base)}
      >
        {/* 생략 */}
      
    
  );
};
```

### 스타일을 위한 타입 선언이 줄어든다

styled-components를 사용할 경우, 동적으로 스타일을 생성할 경우 이를 위한 타입을 선언해야 할 때도 종종 있다.

```tsx {1, 7}
type StyledButtonProps = {
  appearance: Appearance;
  height: Height;
  isFull?: boolean;
};

const StyledButton = styled.button`
  // ...
`;
```

그런데 StyleX는 계산된 값을 넘겨 받는 것이기 때문에 따로 타입 선언할 일이 없다.

```tsx
const s = stylex.create({
  base: {
    // ...
  },
});

const appearanceS = stylex.create({
  // ...
});

const Button = ({
  // ...
  ...restProps
}: PropsWithChildren) => {
  return (
    
      {children}
    
  );
};
```

### pseudo-classes(의사 클래스) 사용 방식

Common 컴포넌트를 만들 때, 특히 Button이나 Checkbox처럼 상태에 따라 스타일을 다르게 설정해야하는 컴포넌트에서 의사 클래스를 많이 사용하는 편이다.

```tsx
const StyledButton = styled.button`
  height: ${(p) => p.height}px;
  border: none;
  border-radius: 4px;
  padding: 5px 10px;

  &:hover {
    cursor: pointer;
  }

  &:disabled,
  &:focus {
    outline: none;
  }

  &:disabled {
    cursor: not-allowed;
  }

  ${(p) =>
    p.isFull &&
    css`
      width: 100%;
    `}
`;
```

그런데 StyleX에서는 pseudo 코드 작성을 지양하고 있고, 하더라도 아래처럼 그 CSS의 속성에 직관적으로 선언하는 형태를 지향한다.

```tsx
const s = stylex.create({
  base: {
    border: 'none',
    borderRadius: '0.4rem',
    padding: '0.5rem 1rem',
    cursor: {
      default: null,
      ':hover': 'pointer',
      ':disabled': 'not-allowed',
    },
    outline: {
      default: null,
      ':disabled': 'none',
      ':focus': 'none',
    },
  },
  height: (height) => ({ height }),
  isFull: {
    width: '100%',
  },
});
```

물론, 해당 속성일 때 어떤 값을 갖고 있어야 하는지 명확하게 눈에 띄어서 좋지만, 없는 경우에도 `default: null`처럼 명시적으로 작성해줘야 하기 때문에 개인의 성향에 따라 다를 것 같다.

styled-components는 개발자의 입장에서 만들어진 코드라면, StyleX는 전적으로 CSS의 입장에서 만들어진 것 같다.

### 4. 기타

### 부모 요소에서 자식 요소 스타일링이 안된다

사실 이게 좀 치명적인 단점이다.

```tsx:src/components/BottomNavigationBar.tsx
const NavWrapper = styled.ul`
  & > * {
    width: 50%;

    &:not(:last-child) {
      content: '';
      border-right: 1px solid ${(p) => p.theme.colors.grey100};
    }
  }
`;

const BottomNavigationBar = () => {
  return (
    
      {/* 생략 */}
    
  );
};
```

위 코드를 아래 처럼 수정할 경우, Invalid pseudo or at-rule. 라는 에러가 뜬다.

```tsx:src/components/BottomNavigationBar.tsx {3}
const styles = stylex.create({
  navWrapper: {
    '& > *': {
      width: '50%',
      //...
    },
  },
});

const BottomNavigationBar = () => {
  return (
    
      {/* 생략 */}
    
  );
};
```

[StyleXTypes.d.ts](https://github.com/facebook/stylex/blob/main/packages/stylex/src/StyleXTypes.d.ts#L37)에서도 해당 패턴은 존재하지 않고 공식문서에서도 최대한 [의사 요소(pseudo-elements) 사용을 지양](https://stylexjs.com/docs/learn/styling-ui/defining-styles/#pseudo-elements)하고 있다.

이는 StyleX가 [스타일 캡슐화(Encapsulation)](https://stylexjs.com/docs/learn/thinking-in-stylex/#encapsulation)를 추구하고 있기 때문이다. 해당 패턴은 강력하지만 스타일을 예측하기가 어렵고, 다른 요소에 영향을 줄 수 있다.

```
.className > *
.className ~ *
.className:hover > div:first-child
```

따라서 StyleX에서는 위와 같은 패턴을 모두 사용할 수 없다. 물론, 예측하기 어렵다는 점은 인정한다. 자식 컴포넌트가 여러 컴포넌트 하위에 있을 때, 어디에 적용한 스타일 때문에 이렇게 되었는지 코드를 타고 타고 올라간 경험이 있기 때문이다.

하지만 StyleX에 이에 대한 대안이 없다는 점은 상당히 아쉬우며, 기존 프로젝트에 이런 패턴이 많이 있다면 마이그레이션하기 쉽지 않을 것 같다. 만약 해당 패턴을 꼭 사용해야 한다면, [CSS/LESS/SASS/SCSS 등 다른 것과 같이 사용](https://github.com/facebook/stylex/issues/400#issuecomment-1917728122)하라고 말하고 있다.

그래서 할 수 없이 (눈물을 머금고) SCSS를 같이 사용했다.

```scss:src/components/BottomNavigationBar.scss
.ulWrapper {
  & > * {
    width: 50%;

    &:not(:last-child) {
      content: '';
      border-right: 1px solid #f5f5f5;
    }
  }
}
```

```tsx:src/components/BottomNavigationBar.tsx
const styles = stylex.create({
  navWrapper: {
    display: 'flex',
    alignItems: 'center',
    height: '100%',
  },
});

const BottomNavigationBar = () => {
  const router = useRouter();
  const pathname = usePathname();
  return (
    
      
        {/* 생략 */}
      
    
  );
};
```

그런데 이렇게 했더니, 여기서도 '늘 마지막 스타일이 적용된다'는 원칙 때문에, 마지막에 작성한 스타일만 적용되었다.

필요한 부분만 SCSS로 하고 싶었지만, 결국 SCSS를 사용해야 하는 곳은 SCSS만을 사용했다.

```scss:src/components/BottomNavigationBar.scss
.ulWrapper {
  display: flex;
  align-items: center;
  height: 100%;

  & > * {
    width: 50%;

    &:not(:last-child) {
      content: '';
      border-right: 1px solid #f5f5f5;
    }
  }
}
```

```tsx:src/components/BottomNavigationBar.tsx
const BottomNavigationBar = () => {
  const router = useRouter();
  const pathname = usePathname();
  return (
    
      {/* 생략 */}
    
  );
};
```

SCSS를 추가하다보니, 그럼 SCSS 내부에서 `theme.stylex.ts`에서 선언한 변수를 사용하고 싶을 때를 생각하니 아예 CSS 변수를 사용하는게 좋지 않을까란 생각도 든다. _(추후 추가)_

### 생각보다 중복 코드가 많이 나온다

```tsx:src/components/TopNavigationBar.tsx
const TopNavigationBar = ({ title }: TopNavigationBarProps) => {
  const router = useRouter();

  return (
    
      
        
        {title ?? '페이지명'}
      
    
  );
};
```

아무리 간단한 스타일이라도, 스타일이 들어간 모든 요소에 `{...stylex.props(...)}` 을 작성해줘야 한다.

만약 컴포넌트 단위가 더 크다면 꽤나 중복적이고, 코드를 읽을 때 피로도가 더 높을 것 같다.

### 브라우저에서 CSS 디버깅이 어렵다

StyleX는 스타일 정보를 컴파일 단계에서 해싱하여, 최종적으로 생성되는 클래스명에는 짧고 최소한의 정보만을 포함한다. 이는 성능 최적화, 보안 강화, 충돌 방지 등의 이점을 갖고 있지만, 브라우저에서 바로 스타일을 알아보기 어렵다.


  
  브라우저 > Elements 탭


우측의 스타일은 모두 `TopNavigationBar`의 wrapper의 내용이지만, 스타일 값 하나하나가 해싱되어 보여지기 때문에 모두 따로 노출된다.

```tsx:src/components/TopNavigationBar.tsx
const styles = stylex.create({
  // ...
  wrapper: {
    display: 'flex',
    alignItems: 'center',
    height: '100%',
  },
});

const TopNavigationBar = ({ title }: TopNavigationBarProps) => {
  return (
    
      
      {/* 생략*/}
      
    
  );
};
```

왜 이렇게 노출되는지 추후에 라이브러리를 들여다 봐야 할 것 같다.

Next.js에서는 dev 모드에서 기본적으로 Source maps을 활성화해주기 때문에, Source 탭으로 가서 실제 파일을 보는 방법도 있지만, Element 탭에서 바로 확인이 불가한 점은 좀 아쉽다. (_추후 다른 방법을 알게 되면 추가_)



## 느낀점

styled-components를 오래 사용한 프로젝트를 StyleX로 마이그레이션하려면 상당한 시간이 들 것 같다. 해당 글에서도 간단한 페이지 하나만 수정한 것에 비해 많은 불편한 점이 나왔다고 생각한다. 따라서 사이즈가 작은 프로젝트에서는 괜찮지만, 운영 중이거나 사이즈가 큰 프로젝트라면 v1.0 이후에 고려해보는 것이 좋지 않을까 생각한다.

### SWC 지원이 빨리 되었으면 좋겠다

현재 Stylex가 바벨 환경만 가능하기 때문에 제약사항이 좀 _(많이)_ 있다.

2023년 12월에 올라온 [이슈](https://github.com/facebook/stylex/issues/70)에서는 메타에서는 SWC 플러그인 관련 예정 작업이 없다며, "StyleX가 인기가 많아진다면 자연스럽게 Next.js가 이를 동작하게끔 만들것이다"라고 했다.

하지만 2024년 2월에 StyleX에 올라온 [PR](https://github.com/facebook/stylex/pull/412)을 보면, 런타임 이전에 모든 JS 파일을 StyleX 바벨 플러그인으로 변환하고 CSS 번들을 출력 후, 번들된 CSS 파일을 Next.js 같은 다른 라이브러리에 주입하는 방식을 시도 중인 것 같다. 지금도 꾸준히 계속 PR에 커밋이 올라오는 걸 보니, 조만간 지원이 될 것 같다.

### StyleX는 컴포넌트 스타일링을 위한 것이다

'이게 왜 안되지?' 싶을 때 StyleX 레포로 들어가 검색을 많이 했는데, 질문에 대한 StyleX 개발자의 답변을 보면 일관된 기조가 있다.


  "StyleX is for component styling."


그렇다. StyleX는 컴포넌트의 스타일을 위한 것이다.

StyleX의 특징이나 철학만 보더라도, Scalable(확장 가능), Predictable(예측 가능), Composable(조합 가능), 그리고 Co-location(동일 위치 배치) 등 모두 컴포넌트 단위에서 상당한 이점을 주는 설계다.

실제 구현 코드에서도 전역 설정이 없으며, 의사 클래스나 의사 요소의 사용 범위도 최소한으로 하여 컴포넌트에 미칠 수 있는 사이드 이펙트도 최소화했다.

따라서 프로젝트 전체에 바로 적용하기 보다, 모노레포의 컴포넌트 패키지부터 적용하는건 시도해볼 법 한 것 같다.

### 늘 공식문서를 보고 작업하는 것을 추천한다

아직 v1.0 전이라 그런지, 버그 수정이나 업데이트 주기가 상당히 빠르다.

해당 글은 1-2주에 걸쳐 작성했는데, 글을 작성하는 도중에도 업데이트 된 이슈나 수정된 부분이 있어서 글을 읽고 있는 시점에도 변경될 가능성이 높다. 따라서 항상 StyleX 공식 문서를 보고 프로젝트에 적용하는 것을 추천한다.


  (뭔가 글을 업로드하고 StyleX의 내용이 자주 변경 될 것 같아서... 수정이 잦을 수도 있다)




**참고**



- [StyleX](https://stylexjs.com/)


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/react/event-handling-in-react</guid>
      <title>React는 이벤트를 어떻게 처리할까?</title>
      <link>https://www.howdy-mj.me/react/event-handling-in-react</link>
      undefined
      <pubDate>Fri, 22 Dec 2023 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>react</category>
      <content:encoded>
회사에서 리액트의 js 컴포넌트를 tsx로 전환하는 과정에서 이벤트들에 대한 타입을 어떻게 선언해야 좋을지 궁금했다.

버튼에 대한 onClick 이벤트가 있다면 단순하게 `MouseEvent`로 작성했지만, 생각해보니 어떤 함수에서는 `MouseEventHandler`를 사용했다.

그러다 보니 어떤 상황에서 어떤 인터페이스를 사용하는 것이 더 적절한지 궁금해졌고, 리액트가 자체적으로 이벤트에 대한 래퍼를 갖고 있다는 사실은 알았지만, 내부에서는 어떻게 다루고 있는지도 더 궁금해졌다.



우선 가장 처음에 궁금했던 `MouseEvent`와 `MouseEventHandler`의 차이점을 알아보자.

## MouseEvent vs. MouseEventHandler

사용 방법은 아래와 같다.

```tsx
import { MouseEvent, MouseEventHandler } from 'react';

export default function App() {
  // 1. MouseEvent
  const onClick1 = (e: MouseEvent) => {
    console.log('onClick1: ', e);
  };

  // 2. MouseEventHandler
  const onClick2: MouseEventHandler = (e) => {
    console.log('onClick2: ', e);
  };

  return (
    
      case 1: MouseEvent
      
      case 2: MouseEventHandler
    
  );
}
```

`MouseEvent`는 매개변수에 대한 타입이며, `MouseEventHandler`는 해당 함수 자체에 대한 타입이다. 그리고 두 인터페이스를 보면, `MouseEventHandler`가 `MouseEvent`를 사용하는 형태인 것을 확인할 수 있다.

```ts:@types/react/index.d.ts
// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/b580df54c0819ec9df62b0835a315dd48b8594a9/types/react/index.d.ts#L1315
interface MouseEvent extends UIEvent {
  altKey: boolean;
  button: number;
  buttons: number;
  clientX: number;
  clientY: number;
  ctrlKey: boolean;
  /**
   * See [DOM Level 3 Events spec](https://www.w3.org/TR/uievents-key/#keys-modifier). for a list of valid (case-sensitive) arguments to this method.
   */
  getModifierState(key: ModifierKey): boolean;
  metaKey: boolean;
  movementX: number;
  movementY: number;
  pageX: number;
  pageY: number;
  relatedTarget: EventTarget | null;
  screenX: number;
  screenY: number;
  shiftKey: boolean;
}

type MouseEventHandler = EventHandler>;
```

그래서 두 onClick 함수의 e를 찍어보면 동일한 것도 확인 가능하다.


  
    
    onClick1의 e
  
  
    
    onClick2의 e
  


`MouseEventHandler`은 void를 반환하므로, 반환 값이 필요없는 함수일 경우 사용한다.

```ts:@types/react/index.d.ts {2}
type EventHandler> = {
  bivarianceHack(event: E): void;
}['bivarianceHack'];
```

물론 반환 값을 준다고 해도 타입 에러는 뜨지 않지만, 무시 되기 때문에 권장되지 않는다.


  
  onClick1에 return을 주었을 때



  
  onClick2에 return을 주었을 때


참고로 `MouseEvent`에서 참조하고 있는 NativeMouseEvent는 브라우저의 마우스 이벤트로 [MDN > MouseEvent](https://developer.mozilla.org/ko/docs/Web/API/MouseEvent)에 설명되어 있다.

`MouseEvent`는 `UIEvent`를 상속하고, `UIEvent`는 `Event`를 상속한다 나와 있듯이, 리액트의 타입에도 비슷한 구조로 선언되어 있다.

```ts
type NativeMouseEvent = MouseEvent;

interface UIEvent extends SyntheticEvent {
  detail: number;
  view: AbstractView;
}
```

그런데 한 가지 다른 점은, 리액트 타입에는 `UIEvent`에서 바로 `Event` 타입으로 가는 것이 아닌, `SyntheticEvent`가 중간에 있다는 점이다.

```ts
interface SyntheticEvent
  extends BaseSyntheticEvent {}

interface BaseSyntheticEvent {
  nativeEvent: E;
  currentTarget: C;
  target: T;
  bubbles: boolean;
  cancelable: boolean;
  defaultPrevented: boolean;
  eventPhase: number;
  isTrusted: boolean;
  preventDefault(): void;
  isDefaultPrevented(): boolean;
  stopPropagation(): void;
  isPropagationStopped(): boolean;
  persist(): void;
  timeStamp: number;
  type: string;
}
```

## SyntheticEvent

리액트의 SyntheticEvent는 브라우저의 네이티브 이벤트를 감싸는 리액트의 이벤트 래퍼다. 위에서 확인했던 `e`는 전부 브라우저가 아닌 리액트의 이벤트 객체다. SyntheticEvent는 기본적으로 DOM 이벤트 표준을 따르지만, 일부 브라우저마다 다르게 동작하는 기능을 일관되게 동작하게 해준다.

예를 들어, 리액트의 `onMouseLeave`는 `mouseout`라는 네이티브 이벤트를 가리킨다. 특정 기능은 퍼블릭 API에 매핑되지 않았으며, 미래에 언제든지 변경될 수 있다. 그러니 만약 기본 브라우저 이벤트가 필요하다면, `e.nativeEvent`를 참조해야 한다.

### 속성과 메서드

위 BaseSyntheticEvent 인터페이스는 기본적으로 표준 [`Event`](https://developer.mozilla.org/en-US/docs/Web/API/Event)에서 구현되었으며, [React event object](https://react.dev/reference/react-dom/components/common#react-event-object)에서 확인 가능하다.

**Event를 기반으로 구현된 속성과 메서드**

- [`bubbles`](https://developer.mozilla.org/en-US/docs/Web/API/Event/bubbles): (boolean) 이벤트가 DOM을 통해 버블링되었는지를 반환한다.
- [`cancelable`](https://developer.mozilla.org/en-US/docs/Web/API/Event/cancelable): (boolean) 이벤트를 취소할 수 있는지를 반환한다.
- [`currentTarget`](https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget): (DOM 노드) 리액트 트리에서 현재 이벤트 핸들러가 첨부된 노드를 반환한다.
- [`deafultPrevented`](https://developer.mozilla.org/en-US/docs/Web/API/Event/defaultPrevented): (boolean) `preventDefault`가 호출되었는지를 반환한다.
- [`eventPahse`](https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase): (number) 이벤트가 현재 어느 단계에 있는지 반환한다.
- [`isTrusted`](https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted): (boolean) 이벤트가 사용자에 의해 시작되었는지 반환한다.
- [`target`](https://developer.mozilla.org/en-US/docs/Web/API/Event/target): (DOM 노드) 이벤트가 발생한 노드(멀리 떨어진 자식 노드일 수 있음)를 반환한다.
- [`timeStamp`](https://developer.mozilla.org/en-US/docs/Web/API/Event/timeStamp): (number) 이벤트가 발생한 시간을 반환한다.
- [`preventDefault()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault): 브라우저의 기본 동작을 막는다.
- [`stopPropagation()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/stopPropagation): 리액트 트리에서 발생하는 이벤트 전파를 막는다.



**React만의 속성과 메서드**

- `nativeEvent`: (Event) 원래의 브라우저 이벤트 객체를 반환한다.
- `isDefaultPrevented()`: (boolean) `preventDefault`가 호출 되었는지를 반환한다.
- `persist()`: 리액트 DOM에서는 사용되지 않으며, 리액트 네이티브에서 이벤트 속성을 이벤트 이후에 읽기 위해 사용된다.
- `isPersistent()`: 리액트 DOM에서는 사용되지 않으며, 리액트 네이티브에서 `persist`가 호출되었는지를 반환한다.



**주의사항**

`currentTarget`, `eventPhase`, `target` 그리고 `type`의 값은 리액트 코드가 예상하는 값들을 반영한다. 내부적으로 리액트는 루트에 이벤트 핸들러를 부착(attach)하지만, 이는 리액트의 이벤트 객체에는 반영되지 않는다. 예를 들어, `e.currentTarget`은 기본 `e.nativeEvent.currentTarget`과는 다를 수 있다. 만약 폴리필된 이벤트인 경우, `e.type`(리액트 이벤트 타입)은 `e.nativeEvent.type`(기본 타입)과 다를 수 있다. 따라서 기본 브라우저 이벤트가 필요한 경우 반드시 `e.nativeEvent`를 참조해야 한다.

### 이벤트 위임 (Event Delegation)

자바스크립트의 [이벤트 위임](https://davidwalsh.name/event-delegate) 덕분에 여러 자식 요소에서 발생하는 동일한 유형의 이벤트를 부모 요소에서 한 번에 처리할 수 있다.

```html

  
    document.getElementById('parent-list').addEventListener('click', function (e) {
      // 만약 li 태그라면
      if (e.target && e.target.nodeName == 'LI') {
        console.log('List item ', e.target.id.replace('post-', ''), ' was clicked!');
      }
    });
  
  
    
      Item 1
      Item 2
      Item 3
    
  

```

리액트 역시 첫 출시부터 이벤트 위임을 지원했지만, 이벤트 시스템의 작동 방식은 불안정했다. 일반적으로 리액트 컴포넌트에서 이벤트 핸들러는 인라인 방식으로 사용된다.

```jsx

```

하지만 이를 DOM 노드에 직접적으로 부착하는 방식이 아니라, document 노드에 직접 이벤트를 타입별로 부착했다. 따라서 어플리케이션 내에서 이벤트가 발생한다면, 리액트는 어떤 컴포넌트를 호출할지 파악하고, 이벤트는 컴포넌트를 통해 '버블링'되어 발생한다. 만약 한 페이지에 여러 버전의 리액트가 존재한다면, 이벤트들은 모두 최상위에 등록되어 `e.stopPropagation()`이 정상적으로 동작하지 않을 수 있다.

예를 들어 아래 코드에서 내부의 InnerButton과 외부의 OuterComponent의 리액트 버전이 다를 경우를 가정해보자.

```jsx
const InnerButton = () => {
  const handleInnerClick = (e) => {
    e.stopPropagation();
    console.log('내부 버튼 클릭');
  };

  return 내부 버튼;
};

const OuterComponent = () => {
  const handleOuterClick = () => {
    console.log('외부 컴포넌트 클릭');
  };

  return (
    
      
    
  );
};
```

일반적으로 내부 버튼을 클릭하면 `e.stopPropagation()` 호출로 인해 외부 컴포넌트의 이벤트(handleOuterClick)는 실행되지 않아야 하지만 실제로는 실행된다. 이는 리액트 17 이전 버전에서 발생할 수 있으며, [Atom 에디터에서 발생](https://github.com/facebook/react/pull/8117)했었다.

그래서 리액트 17 버전부터는 document 레벨이 아닌 루트 DOM 컨테이너에 이벤트 핸들러들을 부착한다.


  
  https://ko.legacy.reactjs.org/blog/2020/08/10/react-v17-rc.html


이러한 변경 덕분에, 리액트의 `e.stopPropagation()`은 일반적인 DOM에 더 가깝게 작동하여 원하는 결과(ex. 외부에 이벤트 전파 막기)를 기대할 수 있게 되었다. (단, 모든 버전이 리액트 17 이상이어야 한다)

초반에 작성한 코드에서 이벤트의 target과 이벤트가 실제로 부착된 target을 각각 찍어보면 타겟은 button이지만 부착된 노드는 root인걸 확인할 수 있다.


  
  onClick의 e.target과 e.nativeEvent.currentTarget


## 리액트에 이벤트가 부착되는 시점은?

리액트에서 이벤트 핸들러가 root에 부착되는 시점은 리액트가 렌더링되는 시점이다.

```jsx
const rootNode = document.getElementById('root');

// React 17
ReactDOM.render(, rootNode);

// React 18
const root = ReactDOM.createRoot(rootNode);
root.render();
```

리액트 18 버전을 예로, 렌더 함수(`root.render`)를 따라가보면 아래와 같은 코드로 동작하는 걸 확인할 수 있다.

```tsx:react-dom/src/client/ReactDOMRoot.js {24}
// https://github.com/facebook/react/blob/main/packages/react-dom/src/client/ReactDOMRoot.js#L162
export function createRoot(
  container: Element | Document | DocumentFragment,
  options?: CreateRootOptions,
): RootType {
  // 생략...

  const root = createContainer(
    container,
    ConcurrentRoot,
    null,
    isStrictMode,
    concurrentUpdatesByDefaultOverride,
    identifierPrefix,
    onRecoverableError,
    transitionCallbacks,
  );
  // ...

  const rootContainerElement: Document | Element | DocumentFragment =
    container.nodeType === COMMENT_NODE
      ? (container.parentNode: any)
      : container;
  listenToAllSupportedEvents(rootContainerElement);

  // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions
  return new ReactDOMRoot(root);
}
```

아래 코드는 흐름대로 읽기 위해 순서를 변경했으며, 실제 코드는 명시한 url에서 확인할 수 있다.

```js:react-dom-bindings/src/events/DOMPluginEventSystem.js
// https://github.com/facebook/react/blob/main/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js

const listeningMarker = '_reactListening' + Math.random().toString(36).slice(2);

export function listenToAllSupportedEvents(rootContainerElement: EventTarget) {
  // rootContainerElement, 즉 id가 root인 엘리먼트에 이벤트 리스너가 부착되어 있지 않은 경우 실행한다.
  if (!(rootContainerElement: any)[listeningMarker]) {
    // 내부에서 이벤트가 부착되었다는 flag를 설정하여, 이후에 다시 실행되지 않게 동작. 따라서 첫 렌더링에만 실행된다.
    rootContainerElement[listeningMarker] = true;
    // 모든 이벤트들에 대해 이벤트 리스너를 부착한다.
    allNativeEvents.forEach(domEventName => {
      if (domEventName !== 'selectionchange') {
        if (!nonDelegatedEvents.has(domEventName)) {
          listenToNativeEvent(domEventName, false, rootContainerElement);
        }
        listenToNativeEvent(domEventName, true, rootContainerElement);
      }
    });
    // ...
  }
}

// 실제 브라우저 이벤트를 연결한다
export function listenToNativeEvent(
  domEventName: DOMEventName,
  isCapturePhaseListener: boolean,
  target: EventTarget,
): void {
  // ...
  let eventSystemFlags = 0; // 기본 값이 0인 것을 주목하자
  if (isCapturePhaseListener) {
    eventSystemFlags |= IS_CAPTURE_PHASE; // 캡쳐링을 한다면 4로 할당
  }
  addTrappedEventListener(
    target,
    domEventName,
    eventSystemFlags,
    isCapturePhaseListener,
  );
}

function addTrappedEventListener(
  targetContainer: EventTarget,
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
  isCapturePhaseListener: boolean,
  isDeferredListenerForLegacyFBSupport?: boolean,
) {
  // 우선순위에 따라 이벤트 리스너를 생성한다.
   let listener = createEventListenerWrapperWithPriority(
    targetContainer,
    domEventName,
    eventSystemFlags,
  );

  // ...
  let unsubscribeListener;

  if (isCapturePhaseListener) {
    // ...
    unsubscribeListener = addEventCaptureListener(
        targetContainer,
        domEventName,
        listener,
      );
  } else {
    // ...
    unsubscribeListener = addEventBubbleListener(
        targetContainer,
        domEventName,
        listener,
      );
  }
}
```

그리하여 마침내 익숙한 addEventListener에 도달했다.

```js:react-dom-bindings/src/events/EventListner.js
// https://github.com/facebook/react/blob/main/packages/react-dom-bindings/src/events/EventListener.js
export function addEventBubbleListener(
  target: EventTarget,
  eventType: string,
  listener: Function,
): Function {
  target.addEventListener(eventType, listener, false);
  return listener;
}

export function addEventCaptureListener(
  target: EventTarget,
  eventType: string,
  listener: Function,
): Function {
  target.addEventListener(eventType, listener, true);
  return listener;
}
```

따라서 사용자에게 화면이 보여질때는 이미 이벤트 핸들러들이 다 부착된 상태이기에 클릭, 작성 등의 이벤트들이 동작한다.

## 이벤트를 실행한다면 어떤 일이 일어날까?

위 코드들로 이벤트가 root에 이벤트 리스너 함수(addEventListener)가 부착된다는 걸 보았다. 그렇다면 반대로 button을 클릭 할 때, root에 부착된 이벤트가 어떻게 실행되는 걸까?

버튼을 클릭 할 경우, 이벤트 버블링이 일어나면서 DOM 트리를 통해 상위 요소로 버블링되며 최종적으로 root 요소에 도달한다. 그리고 바인딩 된 이벤트를 찾아 실행하는데 코드로 살펴보자.

아까 위에서 우선순위로 이벤트 리스너를 바인딩하는 함수(`createEventListenerWrapperWithPriority()`)에서 리스너에 이벤트를 실행하는 dispatch 함수를 같이 바인딩 해둔다.

```js:react-dom-bindings/src/events/ReactDOMListener.js
// https://github.com/facebook/react/blob/main/packages/react-dom-bindings/src/events/ReactDOMEventListener.js#L148
export function dispatchEvent(
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
  targetContainer: EventTarget,
  nativeEvent: AnyNativeEvent,
): void {
  // ...
}
```

해당 함수에서 이벤트의 활성화 여부, 이벤트 전파 중단 여부 등을 확인하고, 이벤트를 실행할 경우 `dispatchEventForPluginEventSystem()` 함수가 호출된다.

```js:react-dom-bindings/src/events/DOMPluginEventSystem.js
// https://github.com/facebook/react/blob/main/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js#L547
export function dispatchEventForPluginEventSystem(
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
  nativeEvent: AnyNativeEvent,
  targetInst: null | Fiber,
  targetContainer: EventTarget,
): void {
  // ...
  if (targetInst !== null) {
    // rootContainer를 찾기 위해 타겟에서 계속해서 위로 올라가며 탐색한다
    let node: null | Fiber = targetInst;
    mainLoop: while (true) {
      // ...
    }
  }
  // ...
  batchedUpdates(() =>
    dispatchEventsForPlugins(
      domEventName,
      eventSystemFlags,
      nativeEvent,
      ancestorInst,
      targetContainer,
    ),
  );
}

function dispatchEventsForPlugins() {
  // ...
  extractEvents(
    dispatchQueue,
    domEventName,
    targetInst,
    nativeEvent,
    nativeEventTarget,
    eventSystemFlags,
    targetContainer,
  );
}

function extractEvents(
  dispatchQueue: DispatchQueue,
  domEventName: DOMEventName,
  targetInst: null | Fiber,
  nativeEvent: AnyNativeEvent,
  nativeEventTarget: null | EventTarget,
  eventSystemFlags: EventSystemFlags,
  targetContainer: EventTarget,
) {
  // 기본적으로 해당 플러그인으로 이벤트 수행
  SimpleEventPlugin.extractEvents(...)
  const shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
  if (shouldProcessPolyfillPlugins) {
    // 폴리필 여부를 판단한 후, 상황에 맞는 이벤트를 실행
  }
}
```

마지막에 나오는 `extractEvents()` 함수에서 일반적으로는 SimpleEventPlugin만 실행 될 것이다. 왜냐하면 `eventSystemFlags`는 상단 이벤트 리스너를 바인딩하는 곳에서 결정되는데, 리액트에서 이벤트는 기본적으로 캡처링 모드는 비활성화 되어 있으며, `eventSystemFlags`가 기본값인 0으로 설정될 것이기 때문이다.

[SimpleEventPlugin.extractEvents](https://github.com/facebook/react/blob/main/packages/react-dom-bindings/src/events/plugins/SimpleEventPlugin.js#L55)는 리액트의 이벤트와 브라우저의 네이티브 이벤트를 바인딩 시키고, 그에 대응되는 코드는 [SyntheticEvent](https://github.com/facebook/react/blob/main/packages/react-dom-bindings/src/events/SyntheticEvent.js)에서 확인할 수 있다.

### 결론

부끄럽지만 여태 리액트에 이벤트를 선언할 때 단순히 요구사항에 맞는 함수를 만들어 선언하고 각 노드에 해당 함수를 연결해주고 더 깊게 생각하지 않았었다.

이번에 리액트 소스코드를 보다보니 각 노드들에 바인딩 된 이벤트들이 root에 바인딩 되며, 실행도 root를 통해서 되고 있다는 사실을 알았다. 리액트가 단방향 바인딩을 추구하고 있다는 건 알고 있었지만, 코드로 보니 더 확 와 닿았다.

이와 별개로 이번에 이벤트 관련 코드들을 보니 생각보다 브라우저 호환성을 위한 분기 처리나 핸들링이 적다는 생각이 들었다. 크롬은 [V8](https://v8.dev/)을, 파이어폭스는 [Gecko](https://wiki.mozilla.org/Gecko:Overview) 엔진을 사용하는데 이 두 가지 모두 메인 페이지에 ECMASCript 혹은 JavaScript에 대한 내용이 있는 반면, 사파리가 사용하는 [WebKit](https://webkit.org/) 엔진의 메인 페이지에서는 해당 내용을 찾아볼 수 없다. 그래서 상대적으로 자유분방(?)한 사파리에서 유독 이벤트 관련해서 더 많은 예외 케이스가 발생하는 것 같다. 리액트도 이런 케이스를 하나하나 대응하기에 힘들기 때문에 따로 처리하지 않은게 아닌가 유추해본다.





**참고**



- [React](https://react.dev/)
- [React event object](https://react.dev/reference/react-dom/components/common#react-event-object)


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/general/http-cache</guid>
      <title>캐시(cache)</title>
      <link>https://www.howdy-mj.me/general/http-cache</link>
      <description>HTTP 캐시 훑어보기</description>
      <pubDate>Tue, 29 Nov 2022 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>web</category><category>general</category>
      <content:encoded>
## 캐시란?

캐시(Cache)는 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킨다. 캐시는 원래 데이터를 접근하는 시간이 오래 걸리거나, 값을 다시 계산하는 시간을 절약하고 싶을 때 사용한다.

특히 웹 서비스에서는 사용하는 이미지, CSS 및 자바스크립트 파일을 매번 네트워크를 통해 불러오지 않고 최초에만 다운로드하여 캐시에 저장해 두고, 그 이후 요청때 저장해 둔 파일을 사용할 때 유용하다.



캐시의 유형은 다양하지만, 궁극적인 목표는 아래와 같다. 

- 불필요한 데이터 전송을 줄여, 네트워크 요금 비용을 줄여준다. 
- 네트워크 병목을 줄여준다.
- 원 서버(origin server)에 대한 요청을 줄여주어, 더 빨리 응답할 수 있게 된다. 
- 거리로 인한 지연을 줄여준다.

## 캐시 유형

[AWS 캐싱](https://aws.amazon.com/ko/caching/) 설명에 따르면, 캐싱은 DB 캐싱, CDN, 웹 캐싱, 일반 캐시, 세션 관리 이렇게 5가지 유형으로 나뉜다.

해당 글에서는 웹 프론트 개발시에 자주 언급되는 CDN, 웹 캐싱만 간단히 알아보자. 

### CDN

CDN(Content Delivery Network)은 분산된 서버 네트워크를 사용해 유저들에게 리소스(ex. 동영상, 이미지, 폰트 등)를 제공하여 사이트 성능을 향상시킨다. 흔히 CDN이 서버에 캐싱된 컨텐츠만 다룬다고 알고 있지만, 캐싱이 되지 않은 컨텐츠들을 제공할때도 좋다. 

CDN 서버들은 기존 컨텐츠를 불러오는 서버들보다 유저와 더 가까워서 RTT(Round Trip Time: 왕복 요청 시간)가 더 짧다.


### 웹 캐싱

웹 캐싱은 HTTP 캐싱이라고도 불리며, 웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재한다면, 그 문서는 원 서버가 아니라 그 캐시로부터 제공된다. 

웹에서 사용하는 캐시는 크게 메모리(RAM)에 저장하는 메모리 캐시와 파일 형태로 디스크에 저장하는 디스크 캐시가 있다. 어떤 캐시를 사용할지는 직접 제어할 수 없으며, 브라우저가 사용 빈도나 파일 크기에 따라 알아서 처리한다. 

## Cache-Control

브라우저가 캐시를 하기 위해서는 Cache-Control이라는 헤더가 응답 헤더에 있어야 한다. 브라우저는 이 헤더를 통해 캐시를 어떻게, 얼마나 적용할지 판단한다.



대표적으로 아래 5가지 값이 조합되어 들어간다.

- `no-store`: 캐시 사용 안함
- `no-cache`: 캐시를 사용하기 전 서버에 사용 가능한지 체크하는 옵션
- `public`: 모든 환경에서 캐시 사용 가능, 브라우저 뿐만 아니라 웹 서버와 브라우저 사이의 중간 캐시 서버에서도 캐시 사용 가능
- `private`: 브라우저 환경에서만 캐시 사용, 외부 캐시 서버에서는 사용 불가
- `max-age`: 캐시의 유효 시간(초 단위)

![Cache-Control 흐름도](https://web-dev.imgix.net/image/admin/htXr84PI8YR0lhgLPiqZ.png?auto=format&w=700)

위 흐름도를 보면 조금 더 빠르게 이해할 수 있다.



### 예제

|Cache-Control 값| 설명|
|:--|:--|
|max-age=86400| 최대 1일(60초 x 60분 x 24시간) 동안 브라우저 및 중간 캐시가 캐싱 가능|
|private, max-age=600| 최대 10분(60초 x 10분) 동안 브라우저가 캐싱 가능|
|public, max-age=3153600| 1년 동안 모든 캐시 저장 가능|
|public, max-age=0| 0초 동안 캐싱 가능, 캐시가 바로 만료되므로 매번 서버에 캐시를 사용해도 되는지 요청하여, no-cache와 동일 함|
|no-store| 캐싱이 불가하며 모든 요청에서 전체를 가져와야 함|

### 적절한 캐시 값 설정하기

리소스마다 변경 빈도가 다르기 때문에 캐싱 설정도 달라야 한다.

일반적으로 HTML 파일은 항상 최신 버전의 웹 서비스를 제공해야 하기 때문에 no-cache로 설정한다. 만약 HTML이 캐싱되어 있다면, 이전 버전의 자바스크립트나 CSS를 로드하여 최신 버전의 웹 서비스를 제공하지 못한다.

반면 CSS나 자바스크립트 혹은 정적인 리소스들은 다르다. 이미 빌드된 자바스크립트나 CSS 파일은 HTML이 변경되기 전에 변경될 일이 없다. 따라서 하루, 한 달 혹은 1년 등 길게 잡아도 상관 없다.

## 실제 페이지 Cache 살펴보기

필자 블로그 글은 페이지를 로드할때 서버 사이드에서 보여줄 글을 미리 전부 불러오고 있다. 그래서 브라우저의 네트워크 탭을 보면 200이 아닌 304로 뜨지만, 캐시 정책을 따로 작성하지 않았기 때문에 `public, max-age=0`로 설정되어 있다.

![howdy-mj cache](https://user-images.githubusercontent.com/58619071/204547491-13c1463e-e187-48d0-b792-367875be5660.png)

추후 블로그 내의 캐시 정책 수정 후에 다시 올려보겠다.



이 외, 자주 들어가는 사이트를 들어가보았더니 아래와 같은 화면을 볼 수 있었다.

![linked cache](https://user-images.githubusercontent.com/58619071/204551294-0957f521-46c5-42c2-be3e-c7b136f5a99e.png)

디스크에 저장된 캐시란 것도 확인할 수 있었고, 이미지나 동영상이 많았음에도 불구하고 로드되는 속도도 매우 빨랐다.




**참조**

- [Content delivery networks (CDNs)](https://web.dev/content-delivery-networks/)
- [HTTP caching](https://developer.mozilla.org/ko/docs/Web/HTTP/Caching)
- [HTTP Cache로 불필요한 네트워크 요청 방지](https://web.dev/http-cache/)
- [Caching Tutorial](https://www.mnot.net/cache_docs/)
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/cs/bit</guid>
      <title>컴퓨터 언어의 비트(bit)</title>
      <link>https://www.howdy-mj.me/cs/bit</link>
      undefined
      <pubDate>Sun, 16 Oct 2022 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>cs</category>
      <content:encoded>
필자는 자바스크립트로 개발을 시작했다. 매니지드 언어이다 보니, 직접 메모리에 할당이나 해제를 해보지 못했다. 그래서 내가 선언한 변수가 어떤 식으로 메모리에 할당되고 사용되는지 알 수 없었다.

하지만 개발을 하다보면 종종 '메모리 누수가 될 수 있으니 주의해야 한다', '메모리 낭비가 심하다' 등의 상황을 직면할 수 있는데, 그리 와닿지 않았다.

이를 이해하기 위해 컴퓨터를 공부해보려 한다.

## 비트

컴퓨터의 언어를 '**비트(bit)**'라 칭하며, 2진법을 사용한다는 뜻의 바이너리(binary)와 숫자를 뜻하는 디지트(digit)이 합쳐진 말이다.

일반적으로 전자기기에서는 신호가 꺼졌는지(0) 켜졌는지(1)로 구별하기 때문에 두 개의 숫자를 사용하는 2진법을 기반으로 발전했다. 모스 부호 역시 점(.)과 선(-) 두 개의 기호를 여러 가지 방식으로 조합하여 다양한 정보를 표현한다.

### 비트의 연산

비트는 논리 연산(logic operation)으로 다양한 내용을 표현할 수 있다.

|     |                                                          |
| :-: | :------------------------------------------------------: |
| NOT |       거짓인 비트는 참이, 참인 비트는 거짓을 반환        |
| AND |         모든 비트가 모두 참인 경우에만 참을 반환         |
| OR  |            어느 하나라도 참인 경우, 참을 반환            |
| XOR | 배타적(exclusive) OR는 서로 다른 값인 경우에만 참을 반환 |




  
  https://instrumentationtools.com/logic-gates-and-truth-tables/


위는 진리표(truth table)이다. 0은 거짓, 1은 참을 뜻하며, 좌측에 입력(input)값을 우측이 출력(output)으로 결과 값을 보여준다.

## 진법 변환

컴퓨터의 모든 정보는 0과 1로 표현된다. 하지만 0과 1로 모두 표기하기에는 너무 길어지고 눈이 아파서 읽기 쉬게 표현하는 방법을 고안해냈다. 


### 8진 표현법

하나는 8진 표현법(octal representation)이다. 2진수 비트들은 3개씩 그룹으로 묶는 것이다. 

100이라는 2진 값을 8진 값으로 바꾸기 위해서는 (1 x $2^2$) + (0 x $2^1$) + (0 x $2^0$) = 4라는 식으로 계산한다.

### 16진 표현법

하지만 최근 컴퓨터는 8비트의 배수를 사용해 만들어지기 때문에, 8진 표현법보다는 16진 표현법(hexadecimal representation)을 많이 쓴다. 8의 배수는 4(16진수 한 자리의 비트 수)로 균일하게 나뉘지만, 3(8진수 한 자리의 비트 수)으로는 균일하게 나눠지지 않는다. 윈도우 컴퓨터를 사용 중이라면 프로그램을 다운 받을 때 32bit, 64bit 중 어떤 걸로 다운받을지 물어보는 경우를 종종 봤을 것이다.

16진수를 표현하기 위해서는 10 이상의 숫자가 필요하다. 그래서 abcedf하는 기호가 10에서 15를 표현하기로 했다. 



0부터 15까지 각각 2진수와 10진수, 16진수로 어떻게 표현되는지 알아보자.

|2진수(4bit)| 10진수| 16진수|
|:--:|:--:|:--:|
|0000|0|0|
|0001|1|1|
|0010|2|2|
|0011|3|3|
|0100|4|4|
|0101|5|5|
|0110|6|6|
|0111|7|7|
|1000|8|8|
|1001|9|9|
|1010|10|A|
|1011|11|B|
|1100|12|C|
|1101|13|D|
|1110|14|E|
|1111|15|F|


## 글자 다루기

### 아스키 코드(ASCII)

아스키(ASCII, American Standard Code for Information Interchange)는 문자를 인코딩해주는 대표적인 부호이며, 컴퓨터와 통신 장비 등 대부분의 장치가 아스키를 기반으로 만들었다. 

출력 가능한 문자들은 52개의 영문 알파벳 대소문자와, 10개의 숫자, 32개의 특수 문자 그리고 하나의 공백 문자로 이루어진다. 전체 문자표는 [ASCII](https://ko.wikipedia.org/wiki/ASCII)에서 볼 수 있다.


### ISO, 국가의 표준 그리고 유니코드

아스키 코드는 영어를 표현하는 데 필요한 모든 문자다. 컴퓨터가 전세계로 보급되면서, 그 밖의 언어를 지원해야 할 필요가 점차 늘었다. 이에 따라 국제 표준화 기구(ISO)는 ISO-646과 ISO-8859를 도입했다. 이는 아스키를 확장해 유럽 언어에 필요한 액센트 기호나 그 밖의 발음 구별 기호를 추가한 것이다. 

이 외, 아시아권 나라에서도 각자의 표준이 생기기 시작했으며, 우리나라는 1976년에 한글을 표현하는 [KSC5601](http://www.ktword.co.kr/test/view/view.php?m_temp1=1452)를 만들었다.

국가마다 다른 표준을 만들었기 때문에, 전 세계 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 유니코드(Unicode)라는 표준이 생겼다.

유니코드는 문자 코드에 따라 각기 다른 인코딩(encoding)을 사용해서 컴퓨터가 읽을 수 있도록 표현한다. 가장 대중적인 인코딩 방식은 [UTF-8](https://ko.wikipedia.org/wiki/UTF-8)이다. 


## 색상 다루기

컴퓨터 모니터는 빨간색, 녹색, 파란색을 섞어서 색을 만들어내는데, 이를 RGB 색 모델이라 한다. 그리고 다루지 않은 어떤 색상을 표현하기 위해 알파(Alpha)라는 투명도를 사용한다.  


  
  http://web.simmons.edu/~grovesd/comm244/notes/week3/css-colors


R, G, B는 각각 8비트를 사용하여, $2^8$인 256가지(0~255)의 색상을 표현한다.

웹 개발을 하는 사람이라면 CSS로 색상을 대부분 hex color로 하는 걸 알 수 있을텐데, 이는 RGB를 16진수로 표기한 값이다. 



**추가할 내용**


  - 이진법 덧셈/뺄셈




**참고**


  - 한 권으로 읽는 컴퓨터 구조와 프로그래밍, 조너선 스타인하트 (2021)
  - [Color | MDN](https://developer.mozilla.org/ko/docs/Web/CSS/color_value#rgb_%EC%83%89%EC%83%81)

</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/react/useEffect-and-useLayoutEffect</guid>
      <title>useEffect와 useLayoutEffect의 차이</title>
      <link>https://www.howdy-mj.me/react/useEffect-and-useLayoutEffect</link>
      undefined
      <pubDate>Sun, 25 Sep 2022 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>react</category>
      <content:encoded>
예전에 데이터에 따라 DOM 조작이 필요했었는데, 이때 화면의 깜빡임을 없애기 위해 useEffect 대신 useLayoutEffect를 사용했었다.

그러나 정확히 이 둘의 차이가 무엇인지 생각해보면, 대답할 수 없었다.

## useEffect

React의 render phase에 따르면, 변형(mutations), 구독(subscriptions), 타이머, 로깅 등의 사이드 이펙트들이 컴포넌트 함수 내부에 있어서는 안된다. _(추후 다른 글로 작성할 예정)_

이를 해결하기 위해 useEffect를 사용하는데, [useEffect](https://reactjs.org/docs/hooks-reference.html#useeffect)는 화면 렌더링이 완료된 후 혹은 어떤 값이 변경되었을 때 사이드 이펙트를 수행한다.

### 실행 시점

useEffect로 전달된 함수는 layout과 paint가 완료된 후에 **비동기적**으로 실행된다.

이때 만약 DOM에 영향을 주는 코드가 있을 경우, 사용자는 화면의 깜빡임과 동시에 화면 내용이 달라지는 것을 볼 수 있다. 중요한 정보일 경우, 화면이 다 렌더되기 전에 동기화해주는 것이 좋은데, 이를 위해 useLayoutEffect라는 훅이 나왔으며, 기능은 동일하되 실행 시점만 다르다.

React 18부터는 useEffect에서도 layout과 paint 전에 동기적으로 함수를 실행할 수 있는 [flushSync](https://reactjs.org/docs/react-dom.html#flushsync)라는 함수가 추가되었다. 하지만 강제로 실행하는 것이다보니, 성능상 이슈가 있을 수 있다.

## useLayoutEffect

[useLayoutEffect](https://ko.reactjs.org/docs/hooks-reference.html#uselayouteffect)는 useEffect와 동일하지만, DOM 변경 후 layout과 paint 전에 **동기적**으로 실행된다.

때문에 설령 DOM을 조작하는 코드가 존재하더라도, 사용자는 깜빡임을 보지 않는다.



정리하자면, 렌더링(render phase) -> DOM 변경 -> layout -> useLayoutEffect -> paint -> useEffect 순으로 실행된다.

### 예제

간단하게 DOM을 조작하는 코드를 만들었다.



버튼 클릭 시, 버튼의 bottom을 가져와 텍스트가 위치할 top을 계산하여 화면에 보여주는 것으로, useEffct로 하느냐 useLayoutEffect로 하느냐의 차이만 존재한다.

그런데 너무 빨라서 두 개의 차이를 잘 보지 못할 수 있는데, 클릭한 것을 0.25배속하여 만들어보았다.


  
  0.25배속이기 때문에 인내심을 요한다


사실 0.25배속으로 해도 두 개의 차이가 크게 나타나지 않는다. 찰나의 순간 깜빡임이 있느냐 없느냐의 차이다.

따라서 스크롤 위치를 찾거나 어떤 element의 스타일 요소를 변경하는 등 직접적으로 DOM을 조작하는 곳 제외하고는 useEffect를 사용하는 것을 추천한다. 공식 문서에서도 useEffect를 먼저 사용한 후에, 문제가 생긴다면 그때 useLayoutEffect를 사용하는 것을 추천하고 있다.

### 서버 렌더링에서 useLayoutEffect 사용하기

Next.js와 같은 서버 렌더링을 사용하는 경우, 자바스크립트가 모두 다운로드 될 때까지 useEffect와 useLayoutEffect 그 어느 것도 실행되지 않는다. 따라서 서버에서 렌더링되는 컴포넌트에서 useLayoutEffect를 사용하는 경우, React에서 경고를 띄운다.

```txt
Warning: useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See  for common fixes.
```

useLayoutEffect는 페인트 전에 실행되기 때문에 서버에서 렌더되는 화면과 클라이언트에서 렌더되는 화면이 다를 수 있다. 따라서 useLayoutEffect는 오직 클라이언트 사이드에서만 실행되어야 한다는 경고 메세지다.



위 에러에서 알려주는 링크를 따라가보면 [uselayouteffect-ssr.md](https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85)에 따르면, 두 가지 방법을 알려준다.

첫 번째는 useEffect 사용하는 방법이다.

```js
function MyComponent() {
  useEffect(() => {
    // ...
  });
}
```

두 번째는 해당 컴포넌트를 lazy하게 로드하는 방법이다.

```js
function Parent() {
  const [showChild, setShowChild] = useState(false);

  // 클라이언트 사이드의 hydration 이후에 보여주기
  useEffect(() => {
    setShowChild(true);
  }, []);

  if (!showChild) {
    return null;
  }

  return ;
}

function Child(props) {
  useLayoutEffect(() => {
    // ...
  });
}
```

이 외에 세 번째 방법으로는 [useIsomorphicLayoutEffect](https://usehooks-ts.com/react-hook/use-isomorphic-layout-effect) 훅을 사용할 수 있다.

```js
import { useEffect, useLayoutEffect } from 'react';

const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;

export default useIsomorphicLayoutEffect;
```

서버일 경우 useLayoutEffect를 useEffect로 변경헌다.

## 코드로 알아보기

그렇다면 코드상으로는 어떤 부분이 다를까?

```js:ReactHooks.js
export function useEffect(
  create: () => (() => void) | void,
  deps: Array | void | null
): void {
  const dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}

export function useLayoutEffect(
  create: () => (() => void) | void,
  deps: Array | void | null
): void {
  const dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
```

[useEffect](https://github.com/facebook/react/blob/cb5084d1c4dc0693e7dcd8af7e921a0aa771914b/packages/react/src/ReactHooks.js#L102)와 [useLayoutEffect](https://github.com/facebook/react/blob/cb5084d1c4dc0693e7dcd8af7e921a0aa771914b/packages/react/src/ReactHooks.js#L118)는 실행 시점만 다를 뿐 같은 로직이기 때문에 코드만 봤을 때는 차이가 없다.



다음에는 어떤 코드를 봐야할까 고민 하던 중, react-reconciler의 [Dispatcher](https://github.com/facebook/react/blob/cb5084d1c4dc0693e7dcd8af7e921a0aa771914b/packages/react-reconciler/src/ReactInternalTypes.js#L363)를 봤지만, 타입만 명시해줄 뿐 특별히 다른건 없었다.

그러다 해당 파일 상단에 HookType이 `ReactFiberHooks.old.js`로 이동했다는 주석을 보고 동일 계층의 파일들을 보니 `ReactFiberHooks.new.js`도 있어서 해당 파일을 보기로 했다.

```js:ReactFiberHooks.new.js
const HooksDispatcherOnMount: Dispatcher = {
  // ...생략
  useEffect: mountEffect,
  useLayoutEffect: mountLayoutEffect,
};

const HooksDispatcherOnUpdate: Dispatcher = {
  // ...생략
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
};

const HooksDispatcherOnRerender: Dispatcher = {
  // ...생략
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
};
```

다른 점을 찾았다.

useEffect는 mountEffect와 updateEffect를, useLayoutEffect는 mountLayoutEffect와 updateLayoutEffect를 실행한다. mount와 update 함수의 구조는 거의 비슷하여
해당 글에서는 mount만 다룬다.

```js:ReactFiberHooks.new.js {3, 11-12}
// useEffect
function mountEffect(create: () => (() => void) | void, deps: Array | void | null): void {
  return mountEffectImpl(PassiveEffect | PassiveStaticEffect, HookPassive, create, deps);
}

// useLayoutEffect
function mountLayoutEffect(
  create: () => (() => void) | void,
  deps: Array | void | null
): void {
  const fiberFlags: Flags = UpdateEffect | LayoutStaticEffect;
  return mountEffectImpl(fiberFlags, HookLayout, create, deps);
}
```

그리고 이 둘의 차이는 return하는 함수의 첫 번째(fiberFlags), 두 번째(hookFlags) 인자가 달랐다.

```js:ReactFiberHooks.new.js {5}
function mountEffectImpl(fiberFlags, hookFlags, create, deps: Array | void | null): void {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, undefined, nextDeps);
}
```

[FiberFlags](https://github.com/facebook/react/blob/cb5084d1c4dc0693e7dcd8af7e921a0aa771914b/packages/react-reconciler/src/ReactFiberFlags.js)

```js:ReactFiberFlags.js
export type Flags = number;

export const Update = /*                       */ 0b000000000000000000000100; // => UpdateEffect
export const Passive = /*                      */ 0b000000000000010000000000; // => PassiveEffect

export const LayoutStatic = /*                 */ 0b001000000000000000000000; // => LayoutStaticEffect
export const PassiveStatic = /*                */ 0b010000000000000000000000; // => PassivStaticEffect
```

[HookFlags](https://github.com/facebook/react/blob/cb5084d1c4dc0693e7dcd8af7e921a0aa771914b/packages/react-reconciler/src/ReactHookEffectTags.js)

```js:ReactHookEffectTags.js
export type HookFlags = number;

export const Layout = /*    */ 0b01000; // => HookLayout
export const Passive = /*   */ 0b10000; // => HookPassive
```

그리고 이 fiberFlags와 hookFlags는 pushEffect 함수의 첫 번째 인자인 tag로 들어가고, 해당 함수는 `componentUpdateQueue`로 업데이트 할 컴포넌트를 Flag를 통해 Queue로 관리하는 것 같다.

```js:ReactFiberHooks.new.js {10-11}
function pushEffect(tag, create, destroy, deps: Array | void | null) {
  const effect: Effect = {
    tag,
    create,
    destroy,
    deps,
    // Circular
    next: (null: any),
  };
  let componentUpdateQueue: null | FunctionComponentUpdateQueue =
    (currentlyRenderingFiber.updateQueue: any);
  if (componentUpdateQueue === null) {
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any);
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    const lastEffect = componentUpdateQueue.lastEffect;
    if (lastEffect === null) {
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      const firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }
  return effect;
}
```

그리고 초기값으로 할당된 currentlyRenderingFiber는 renderWithHooks 함수에서 현재 동작중인 훅을 기록하는 것으로 보인다.

```js:ReactFiberHooks.new.js {10}
export function renderWithHooks(
  current: Fiber | null,
  workInProgress: Fiber,
  Component: (p: Props, arg: SecondArg) => any,
  props: Props,
  secondArg: SecondArg,
  nextRenderLanes: Lanes,
): any {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber = workInProgress;
}
```

## 결론

useEffect와 useLayoutEffect가 어떻게 다르고, 어떤 코드로 이루어졌는지 알아보았다.

그런데 사실 어떤 원리로 동작하는지 정확하게 파악하려면, React의 Fiber 알고리즘과 Reconciliation까지 이해해야 정확한 글을 작성할 수 있을 것 같다. (결국 수박 겉핥기 글이 되어버렸다..)





**참고**

- [React](https://reactjs.org/)


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/mj-log/howdy-nextjs-starter</guid>
      <title>블로그 구축기</title>
      <link>https://www.howdy-mj.me/mj-log/howdy-nextjs-starter</link>
      <description>한 달 간 블로그 템플릿 만든 후기</description>
      <pubDate>Mon, 12 Sep 2022 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>mj.log</category>
      <content:encoded>
## 블로그를 만든 이유

왜인지는 모르겠지만, 어렸을 때부터 블로그를 썼었다. 그때는 즐겨하던 게임 공략을 네이버 블로그에 작성했었다. 방문자 수가 올라가던 걸 보면서 글을 더 잘 쓰고, 사람들이 찾고 싶어 하는 내용을 작성하고 싶다는 생각이 강했다.

그다음에는 개발자 이전에 취준할 때 공부한 내용을 티스토리에 정리했었고, 개발자로 전향 후에는 JBee님이 만들어주신 [gatsby-starter-bee](https://github.com/JaeYeopHan/gatsby-starter-bee)로 블로그를 만들었다.

그러다 보니 알게 모르게 '나도 언젠가는 나만의 블로그를 만들어야지'라는 목표가 생겼고, 이번에 드디어 이루었다.

### 구축 기간

사실 예전에도 블로그 만들기를 여러 번 시도했었다. 티스토리를 사용할 때는 워드프레스로 시도했으나 결국 실패했고, 작년에는 프로젝트 초기 세팅만 하다가 어떻게 만들어야 할까만 고민하다 삭제했었다.

이는 모두 내가 어떤 블로그를 원하는지에 대한 생각이 불충분했다고 판단했다. 그래서 사용했던 블로그들의 좋았던 점들이나 아쉬웠던 점들, 평소에 봤던 페이지 중에서 내가 좋아하는 포인트들을 수시로 메모했다.

그 덕분인지, 한 달가량 작업했더니 완성할 수 있었다.

그렇다고 여유롭진 않았다. 퇴근하고 작업하니 피곤한 적도 많았고, 8월은 유독 약속이 많았던 달이었다. 그리고 무엇보다 올해 런칭해야 하는 프로젝트가 생겨서, 블로그는 무조건 이번 추석에 배포해야겠다는 생각이 들어서, 어떻게 보면 반강제적으로 한 달이라는 시간이 주어졌다.

### 기술 스택 선정 이유

해당 블로그는 Next.js, styled-components, next-mdx-remote를 사용했다.

블로그 구축할 때 Jekyll나 Gatsby를 많이 사용하는 거로 알고 있다. 그러나 필자는 현업에서 대부분 React, Next.js를 사용해왔고, 이 기술들이 이제는 어느 정도 안정기(?)가 아닐까 하는 생각을 감히 했다. 그리고 아직 현업에서 Next.js로 SEO를 처음부터 끝까지 해본 적이 없어서 도전해보고 싶었다.

스타일의 경우, 개인적으로 CSS 모듈보다 CSS-in-JS를 더 선호해서 주저없이 styled-components를 사용했다. 하지만 다크모드 구축할 때의 불편함을 미리 알았더라면 CSS 모듈도 고려했을 것 같다.

`mdx` 관련 라이브러리를 고를 때 고민을 많이 했다. 결국 유명한 라이브러리를 하나하나 사용해보면서 가장 편했던 것을 골랐다. `next-mdx-remote`가 작년까지는 mdx v1만 지원했지만, 올해 2월에 v2를 지원하면서부터 딱히 불편한 점은 없었다.

## 어려웠던 점

### 디자인

가장 어려웠던 것은 바로 디자인이다.

가령 가로 폭을 어느 정도로 잡을지, 어느 테마에서든 오래 봐도 눈이 피로하지 않은 색상으로 만들고 싶었다. 기본 텍스트 색상 외에 다른 어떤 색상이 눈에 잘 보이면서도 이질감이 없을지 등등, 가장 많은 고민과 시간을 투자했다.

초반에는 색상을 여러 개 추가했다가, 거의 다 제거하고 최대한 단순화했다. 그래서 지금은 약간 밋밋한 느낌도 없잖아 있다.

특히 다크모드를 구현할 때 이에 매칭되는 색상이 어떤 걸로 정할지 고민을 엄청나게 했다. Color Contrast 사이트를 사용했지만, 이상하게 점수가 높은 색상을 적용하면 폰트 색상이 묻히거나 배경 색상이 이상해져서, 최대한 중간 타협점을 찾아서 수정했다. 물론 내 눈에만 이상했던 걸 수도 있지만.. 나중에 더 좋은 색상을 찾으면 바꿀 것 같다.

어느 정도 틀이 잡힌 후에 회사 디자이너분에게 간단한 피드백을 요청드렸고, 덕분에 훨씬 좋아진 것 같다. _(그렇지만 그때 말씀해주신 건 다 적용 못 했어요.. 나중에 천천히 할게요...ㅠㅠ)_

### md와 mdx

필자는 `md`와 `mdx`를 모두 사용할 수 있게 만들고 싶었다.

`md`는 이전 블로그를 `md`로 작성한 이유가 (가장) 컸지만, 블로그를 작성하는 대부분의 사람은 다른 곳에서 마크다운으로 작성한 문서를 그대로 복붙해서 가져오고 있는 것 같아서 유지하기로 했다.

하지만 JSX 문법으로 작성할 수 있는 `mdx`의 유혹도 상당했다. JSX 문법을 활용한다면 나중에 더 다양한 컴포넌트를 추가할 수 있기 때문에 절대 놓치고 싶지 않았다. 특히 작성한 코드 블럭을 보여주기 위해 code sandbox나 codepen에 작성한 후 그걸 iframe으로 가져 왔었는데, 너무 불편해서 어떻게든 줄이고 싶었다. 나중에는 이러한 playground 컴포넌트를 만들어서 템플릿에 내제화하고 싶다.

무튼 이 두 개의 확장자를 모두 지원하고 싶다보니 파일을 불러올때 어떤 확장자인지 판별하는 구문이나, format 해주는 곳 등 신경써야 하는 곳이 많았다. `mdx-bundler`는 이상하게 `md` 파일인지 인지하지 못해서 열지 못하는 문제가 있었다. 물론 `next-mdx-remote`도 불편하진 않지만, 다른 라이브러리들을 완벽하게 사용해보지 못해서 아쉽다.

### Code block

개발 블로그이기 때문에 code block에 신경을 많이 썼다.

처음에는 [React Syntax Highlighter](https://github.com/react-syntax-highlighter/react-syntax-highlighter)를 사용했었다.

그런데 특정 줄을 하이라이팅하는 기능과 `이렇게 작성한 코드`와 code block을 구분하는 로직을 짤 때 '이게 맞나?' 싶을 정도로 조잡해졌었는데, 설상가상 내가 원하던 기능이 없었다.

가장 큰 이유는 해당 코드 블럭의 제목을 넣어줄 수 없다는 점이다. 이전 블로그에서는 해당 코드의 파일명이나 위치를 표기해주기 위해 코드 블럭 상단에 span 태그로 작성해주었는데, 이게 생각보다 귀찮았다. 특히 코드가 많이 나오는 곳에서는 더더욱 그랬다.

````
// 예전 방식
_app.tsx

```tsx
// ... 생략
```
````

두 번째로는 코드를 복사 & 붙여넣기 하는 기능을 원했다.

\
&nbsp;

그래서 그냥 remark, rehype로 다시 구축하기로 결심했다.

remark는 markdown을 변환해주는 플러그인이고, rehype는 HTML을 변환해주는 플러그인이다. 전체 플러그인은 [remark/plugins](https://github.com/remarkjs/remark/blob/main/doc/plugins.md), [rehype/plugins](https://github.com/rehypejs/rehype/blob/main/doc/plugins.md)에서 확인할 수 있다.

\
&nbsp;

그리하여 아래처럼 원하는 모양을 만들 수 있었다.

```js:hello.js {3-5}
const name = 'MJ Kim';

const helloThere = (name) => {
  return `Howdy, ${name}`;
};

helloThere(name);
```

_그런데 제목 부분 눈에 잘 띄지 않는 것 같아 수정해야겠다..._

### 다크모드

사실 이번에 다크모드까지 작업할 생각은 없었다. 그러다 점점 내가 목표했던 배포일이 다가오자, 이왕 배포할 거 같이 하자는 욕심이 들어서 급하게 추가했다.

그런데 styled-component의 ThemeProvider로 다크모드를 판단하자니, 처음에 라이트모드였다가 다크모드로 변경되는 그 1초가 너무 보기 싫었다. 그러한 유저 경험을 주는 블로그라면 내가 생각해도 싫을 것 같았다.

이런 저런 방법을 강구하다 결국 CSS variable을 선택했다. 이럴 줄 알았다면 처음에 CSS 모듈을 생각했을 텐데.. 역시 해보지 않으면 모르는 구나를 다시 한번 깨달았다. 다행히 이때 색상을 거의 통일해놔서 변경할 부분은 많지 않았다.

그리고 다크모드 구현이 끝난 줄 알았지만, utterances(댓글 컴포넌트)의 테마가 같이 변경되지 않았다. 여기저기 레퍼런스를 찾아봤지만 원하던 결과가 나오지 않아, 결국 테마를 토글할 때 utterances의 색상을 변경하는 로직을 넣어주었다. 이 부분도 수정하고 싶다. (utterances는 Github Repo가 public이어야 사용 가능해서 당분간은 사용 안할 예정이다)

### SEO

역시 생각처럼 쉽지 않았다. 그리고 OG Tag는 배포한 후에야 여러 플랫폼에서 결과가 제대로 나오는지 확인할 수 있었기 때문에 꽤나 번거로웠다.

그리고 글의 description에 어떤 내용을 보여줄지 summary의 유무에 따른 경우의 수 등을 생각하다보니 수정해야 할 곳이 많았다. 그리고 icon이 안나왔던 문제도 있어서 여러 메타 태그들을 찾아봤었다.

| ![블로그 페이지](https://user-images.githubusercontent.com/58619071/189531156-191812d6-8491-4901-ac54-56c14481db2d.png) |
| :---------------------------------------------------------------------------------------------------------------------: |
|                                                  블로그 페이지 테스트                                                   |

| ![글 시도1](https://user-images.githubusercontent.com/58619071/189531145-4e5632bc-0452-4dc5-ab58-41ce27752354.png) |
| :----------------------------------------------------------------------------------------------------------------: |
|                                                     글 시도 1                                                      |

| ![글 시도2](https://user-images.githubusercontent.com/58619071/189531154-7e9571c8-bb14-44a1-ada4-ec6dc50246e9.png) |
| :----------------------------------------------------------------------------------------------------------------: |
|                                                     글 시도 2                                                      |

### 커스텀 컴포넌트

이것도 어찌 보면 디자인과 연결되어 있는데, 컨텐츠의 요소들의 스타일 오버라이딩을 해주고 싶은 것들을 모두 컴포넌트로 만들었다.

그중에서도 텍스트들의 행간과 크기를 정하는 것이 가장 어려웠다. 텍스트들이 가장 많은 페이지인데, 어떻게 하면 덜 답답하고 글이 잘 읽히게 스타일링 할 수 있을까.. 여전히 진행중인 고민이다.

## 예상치 못했던 문제

위의 문제들을 어느 정도 해결하고 나니 이제 배포해도 되겠다는 생각이 들었다.

그래서 이전의 글을 새로운 블로그 Repo로 옮겨왔더니, 예상하지 못한 문제가 발생했다.

### 마크다운이 다 해주는 게 아니었다

필자가 자주 사용했던 마크다운에서는 모두 HTML 태그들을 사용해서 마크다운 단에서 지원해주는 기능인 줄 알았다.

하지만 알고 보니 마크다운은 특정 형식들만 인식해서 이를 파싱해줄 뿐, 그 외의 것들은 모두 변환하는 작업이 필요했다. 역시 당연한 것은 없었다.

왜 블로그를 만들 때 Gatsby를 사용하는지도 이때 알았다. 지원해주는 플러그인이 아주 많다. 살짝 후회하긴 했다..

\
&nbsp;

아직 원하는 기능을 모두 추가하지 못했다. 하지만 올해 배포를 못 하면 또 영영 못할 것만 같은 느낌이 들어서 우선 만든 부분까지만 배포하기로 했다. 이 때문에 아직 도메인도 옮기지 못했고, 이전 글들도 옮겨오지 못했다..🥲

전반적으로 remark, rehype 부분은 조금 더 깊게 공부하고 수정해야 할 것 같다.

### 템플릿 공개 연기

원래 howdy-nextjs-starter라는 템플릿으로 오픈하려고 했었다. 무리하게 일정을 잡은 것도 템플릿 공개 때문이었다.

그런데 첫 글을 작성하고 있는 지금, 자잘한 버그들과 부족한 부분 그리고 수정이 필요한 부분들이 너무 많다. 올해는 혼자 사용해보면서 보완 및 수정하고, 올해 말이나 내년 초쯤에 public으로 돌려놓을 예정이다.

아직 버전 `0.1.0`인데 올해 말에 `1.0.0`이 되길 기대해본다.

### 그 외...

분명 로컬에서 할 때는 잘 나왔는데, 배포하고 확인해보니 이상하게 보이는 곳들이 종종 보였다.

만약 블로그를 구축하시는 분이 계신다면 중간중간 배포해서 빌드된 결과물이 로컬과 동일하게 나오는지 확인하는 걸 추천한다.

## 마무리

구축한 한 달 동안 힘들었지만, 늘 생각해오던 목표 중 하나를 이루어서 무척이나 보람찼다.

아직 많이 부족해서 템플릿으로 공개는 못 했지만, 빠른 시일 내에 공개할 수 있도록 열심히 다듬어야겠다.

_(하나 아쉬운 점이 있다면, Gatsby로 만든 블로그의 SEO가 정말 잘 되고 있어서 갈아타기 무척이나 아쉽다.)_
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/general/functional-thinking</guid>
      <title>함수형 사고하기</title>
      <link>https://www.howdy-mj.me/general/functional-thinking</link>
      undefined
      <pubDate>Fri, 19 Aug 2022 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>general</category>
      <content:encoded>
> 해당 글은 쏙쏙 들어오는 함수형 코딩 책 내용을 기반으로 작성된 내용입니다.



언젠가부터 함수형 프로그래밍 얘기가 여기 저기에서 들려왔다. 함수형 프로그래밍이라하면 대부분 부수효과가 없는 순수함수, 일급 객체, 불변성 지향 그리고 고차 함수 등의 특징을 말한다. 그러나 필자가 봤었던 대부분의 자료들은 어플리케이션 전반이 아니라 단편적인 예시만 알려주고 있어서, 실제로 이 코드가 서비스에서 어떻게 작동하는지, 얼마나 큰 장점이 있는지 알기 힘들었다.

하지만 '쏙쏙 들어오는 함수형 코딩' 책은 이커머스 어플리케이션을 배경으로 자바스크립트를 어떻게 함수형으로 작성할 수 있는지 알려줘서 좋았다. 사실 원서의 제목은 'Grokking Simplicity: Taming Complex Software with Functional Thinking'로 함수형 프로그래밍보다는 함수형 사고에 더 집중하고 있다. 한글 책 제목만 보면 함수형 프로그래밍에 대해서만 얘기하는 것 같은데 조금 아쉽긴 하다.

책은 1, 2부로 나뉘며 1부에서는 함수형 프로그래밍을 위해 코드를 분류하고, 의미있는 계층으로 코드를 구성하는 법을 알려준다. 2부는 일급 함수를 중심으로 복잡한 계산을 만드는 법, 비동기 작업으로 인해 생길 수 있는 버그를 제거하는 법 등을 알려준다.

이번 글에서는 1부 초중반부 내용인 함수형 프로그래밍을 하기 위해 어떻게 사고해야하는지를 정리하고자 한다.

## 함수형 프로그래밍 정의의 문제점

책에서는 함수형 프로그래밍을 위키피디아의 내용을 요약해서 '부수 효과가 없는 순수 함수'로 정의하고 있지만, 이는 실제 프로그래밍을 할 때 지키기 어렵다고 설명하고 있다. 왜냐하면 모든 서비스 개발에는 부수 효과가 필연적이기 때문이다.

**부수 효과**란 함수에서 리턴 값을 주는 것 외에 하는 행동을 말한다. 따라서 그 함수에서 반환하는 것 외에 발생하는 모든 행위가 부수 효과라는 뜻이다.

```js
// 합을 리턴하는 것 외에 b를 console로 찍는 행위
let b = 0
const sum = a => {
  console.log(b)
  return a + b
}

// 유저의 이름을 서버에 요청을 보내 업데이트하지만 리턴 값이 없는 onSubmit 함수
const onSubmit = () => {
  updateUserName({ name: 'howdy-mj' })
}
```

그렇다. 대부분의 서비스를 만들기 위해서는 서버에 요청을 보내는 부수 효과가 꼭 필요하다.

그렇다면 어떻게 함수형 프로그래밍을 따르며 코딩을 할 수 있을까? 부수 효과와 순수하지 않은 함수를 잘 다루어야 한다.

그러기 위해서는 코드를 분류할 줄 알아야 한다.

## 액션, 계산, 데이터

함수형 프로그래머는 직감적으로 코드를 액션, 계산 그리고 데이터 이렇게 세 분류로 나눈다.

### 액션

액션은 호출하는 시점과 횟수에 의존한다. 언제 실행되는지, 얼마나 실행되는지에 영향을 받는다. 따라서 호출할 때 조심해야 한다.

액션은 다양한 형태로 나타난다.

```js
// 함수 호출
window.alert('howdy-mj')

// 메서드 호출
console.log('howdy-mj')

// 생성자 함수
new Date() // 호출하는 시점마다 값이 다르다

// 표현식
user.nickName // user가 공유되고 변경 가능한 경우, 읽는 시점에 따라 값이 다를 수 있음
cartItem[0] // 변경 가능한 배열일 경우, 읽는 시점에 따라 값이 다를 수 있음
```

이 외에도, 앞에서 나온 유저의 정보를 업데이트하는 등의 서버 요청도 모두 액션에 포함된다.

만약 함수 안에서 액션을 호출하고 있다면, 함수 전체가 액션이 된다.

```js{5}
function figurePayout(affiliate) {
  const owed = affiliate.sales * affiliate.commission
  if (owed > 100) {
    // 100달러 이상일 경우만 송금
    sendPayout(affiliate.bank_code, owed)
  }
}

function affiliatePayout(affiliates) {
  for (let i = 0; i  {
  return a, b
}

const getStringLength = str => {
  return str.length
}
```

계산은 언제, 어디서 실행해도 반환 값이 같으며 외부에 영향을 주지 않는다. 따라서 테스트하기 쉽고, 다른 것과 조합하여 더 큰 계산(ex. 일급 계산)을 만들 수 있다. 몇 번을 불러도 안전하다.

하지만 계산과 액션은 실행하기 전에 어떤 일이 발생했는지 알 수 없다. 코드를 읽으면 알 수 있지만, 입력 값으로 실행되어야 결과를 알 수 있다.

### 데이터

데이터도 계산과 마찬가지로 호출하는 횟수가 중요하지 않다. 하지만 계산과 달리 실행할 수 없다.

```js
const numList = [1, 2, 3, 4, 5]

const name = {
  firstName: 'Kim',
  lastName: 'MJ',
}
```

액션이나 계산과는 달리 데이터는 정적이고 보이는 그대로이기 때문에 알아보기 쉽고, 비교하기도 쉽다. 그리고 데이터 자체로 의미가 있기 때문에, 여러 가지 방식으로 해석할 수 있다.

### 분류의 장점

이렇게 분류하는게 어떤 장점이 있을까?

액션은 실행 시점과 횟수에 의존하기 때문에 코드 전체에 영향을 주지 않도록 격리 시켜야 한다. 반면, 계산과 데이터는 실행 시점이나 횟수에 의존하지 않아서 프로그래머가 제어하기 쉬운 코드가 된다. 따라서 에러가 났을 때도 쉽게 찾아낼 수 있다.

그리고 이러한 분류는 불변성을 지켰을 때 더 큰 장점으로 다가온다.



## 불변성

함수형 프로그래밍 언어는 일반적으로 불변형 데이터 구조를 지원하지만, 지원하지 않는 언어도 존재한다. 자바스크립트 역시 지원하지 않아, 불변 데이터 구조를 만들기 위해서는 카피-온-라이트, 방어적 복사, 이 두 가지 원칙을 지켜야 한다.

### 동작에 대한 분류

불변 데이터를 만드는 원칙에 대해 알아보기 전에, 동작에 대한 분류를 먼저 알아보자.

동작(기능)에 대한 분류는 읽기(read) 또는 쓰기(write) 또는 둘 다 하는 것으로 분류할 수 있다.


  
    
      읽기
      쓰기
    
    
      
        
          데이터의 정보를 가져온다
          데이터를 바꾸지 않는다
        
      
      
        
          데이터를 바꾼다
        
      
    
  


#### 그렇다면 왜 함수형 프로그래밍에서 불변성을 지켜야하는 걸까?

불변 데이터 구조를 읽는 것은 액션이 아니라 계산이다. 다시 한 번 액션과 계산의 차이점을 생각해보자.

액션은 변경 가능한 데이터를 읽는 것이며, 읽는 시점에 따라 데이터가 변경될 수 있다. 쓰기 동작은 데이터를 바꾸기 때문에 데이터를 변경 가능한 구조로 만든다. 만약 쓰기 동작을 모두 제거했다면, 데이터는 생성 이후 바뀌지 않는다. 따라서 불변 데이터다.

아래 장바구니 예시를 통해 불변 데이터 구조를 만드는 방법을 알아보자.

### 카피-온-라이트(copy-on-write)

카피-온-라이트는 이름에 나타나는 그대로 이전의 값을 복사하고 새로 쓰는 것을 뜻한다. 카피-온-라이트는 1) 복사본 만들기, 2) 복사본 변경하기 그리고 3) 복사본 리턴하기 이렇게 세 단계로 되어 있다.

```js
// 카피-온-라이트를 지키지 않은 방식
const cart = []

const addCartItem = item => {
  cart.push(item)
}

// 카피-온-라이트를 지킨 방식
const cart = []

const addCartItem = (cart, item) => {
  const newCart = cart.slice() // 1. 복사본 만들기
  newCart.push(item) // 2. 복사본 바꾸기
  return newCart // 3. 복사본 리턴하기
}
```

기존 장바구니를 복사한 장바구니의 정보를 반환했다. 따라서 이는 읽기 동작이다.

이번에는 장바구니의 아이템을 제품명으로 삭제한다고 가정해보자.

```js
// 카피-온-라이트를 지키지 않은 방식
const removeCartItemByName = (cart, name) => {
  let idx = null
  for (let i = 0; i  {
  const newCart = cart.slice() // 1. 복사본 만들기
  let idx = null
  for (let i = 0; i  값을 리턴한다
console.log(a) // output: [2, 3, 4] => 값이 바뀌었다
```

이를 읽기, 쓰기 함수로 각각 분리하는 카피-온-라이트 방법을 알아보자.

```js
const getFirstElement = arr => {
  return arr[0]
}

const dropFirstElement = arr => {
  const newArr = arr.slice()
  newArr.shift()
  return newArr
}

const originArr = [1, 2, 3, 4]

const a = dropFirstElement(originArr) // output: [2, 3, 4]
const b = getFirstElement(originArr) // output: 1
```

이 외, 객체에 대한 카피-온-라이트 방식은 아래와 같다.

```js
const updateNickname = (user, newNickname) => {
  const userCopy = Object.assign({}, user)
  userCopy.nickname = newNickname
  return userCopy
}
```

일반적으로 불변 데이터 구조는 변경 가능한 데이터 구조보다 메모리를 더 많이 쓰고 느리다. 하지만 언제든 최적화가 가능하니, 불변 데이터 구조를 사용해보고 느린 부분이 있다면 그때 최적화하면 된다.

또한, 카피-온-라이트는 얕은 복사(shallow copy)이기 때문에, 배열을 복사해도 참조에 대한 복사본이기 때문에 생각보다 많이 복사하지 않는다. 얕은 복사는 중첩 데이터에서 최상위 데이터 구조만 복사하는걸 뜻하며, 중첩된 데이터 구조에서 안쪽 데이터가 같은 데이터를 참조하는 것을 구조적 공유(structural sharing)라고 한다.



### 방어적 복사(defensive-copy)

방어적 복사는 보관하려고 하는 데이터의 복사본을 만드는 것이다. 카피-온-라이트는 데이터를 바꾸기 전에 복사한다. 이는 무엇이 바뀌는지 알기 때문에 무엇을 복사해야 할지 예상할 수 있다. 하지만 외부에서 들어오는 데이터는 어떤 건지 예측할 수 없기 때문에, 내부에 있는 데이터가 바뀌는 것을 완벽히 막아주는 원칙이 필요하다. 이러한 원칙을 방어적 복사라 한다.


  
  쏙쏙 들어오는 함수형 코딩, p150


O는 복사본, C는 복사본을 말한다.

외부의 바뀔 수도 있는 신뢰할 수 없는 코드가 안전지대(불변성이 지켜지는 곳)로 들어올 경우, 들어오기 전 깊은 복사본을 만들고 변경 가능한 원본은 버린다. 신뢰할 수 있는 코드만 복사본을 쓰기 때문에 데이터는 바뀌지 않는다. 이러한 방법으로 들어오는 데이터를 보호할 수 있다.


  
  쏙쏙 들어오는 함수형 코딩, p150


반대로, 안전지대에서 나가는 데이터도 바뀌면 안된다. 안전지대 밖으로 나가는 데이터는 신뢰할 수 없는 코드가 값을 변경할 수 있어서 변경하지 못하도록 해야한다. 따라서 나가는 데이터도 깊은 복사본을 만들어 내보낸다. 이렇게 하면 나가는 데이터를 보호할 수 있다.

방어적 복사는 깊은 복사(deep copy)를 한다. 위의 그림처럼, 방어적 복사는 데이터가 안전한 코드에서 나갈 때 복사, 안전한 코드로 데이터가 들어올 때 복사해야 하는 규칙이 있다.

사실 대부분의 웹 API는 암묵적으로 방어적 복사를 한다. JSON 데이터가 API에 요청으로 들어왔을 때, 클라이언트는 데이터를 인터넷을 통해 API로 보내려고 직렬화한다. 이때 JSON 데이터는 깊은 복사본이다. 서비스가 잘동작한다면 JSON으로 응답하는데, 이 역시도 깊은 복사본이다. 서비스에 들어오고 나갈 때 데이터를 복사한 것이다.

자바스크립트의 표준 라이브러리로 깊은 복사를 만들기에는 복잡하다. 보통 Lodash의 `cloneDeep()` 메서드를 사용한다.



### 카피-온-라이트와 방어적 복사 비교


  
    
    
  
  
    
      카피-온-라이트
      방어적 복사
    
  
  
    
      통제할 수 있는 데이터를 바꿀 때 사용
      신뢰할 수 없는 코드와 데이터를 주고 받을 때 사용
    
    
      안전지대 어디서나 사용 가능 (카피-온-라이트가 불변성을 가진 안전지대를 만든다)
      안전지대의 경계에서 데이터가 오고 갈 때 사용
    
    
      얕은 복사
      깊은 복사
    
    
      
        
          바꿀 데이터의 얕은 복사 생성
          복사본 변경
          복사본 리턴
        
      
      
        
          안전지대로 들어오는 데이터의 깊은 복사 생성
          안전지대에서 나가는 데이터의 깊은 복사 생성
        
      
    
  




### 소결론

이 책을 읽기 전까지, '함수형 프로그래밍은 순수 함수로 만들어지며, 이러한 함수들을 조합해서 재사용이 쉽다' 정도로만 생각하고 있었다.

그러나 그 전에 코드를 이해하고, 바라보는 시각을 바꿔야 한다는 생각을 들게 해줬다. 사실 읽었을 때는 이해했다는 느낌이 들지만, 막상 코드로 옮겨보면 생각보다 쉽지 않다. 현재 회사에서 진행 중인 프로젝트를 함수형으로 짜고 있는데, 계층을 나누는 것 자체가 굉장히 어렵다.

함수형으로 코드를 작성하는 것에 관심이 있다면, 해당 책을 읽고 기존의 프로젝트를 리팩토링하는 방식으로 해봐도 좋을 것 같다.

본 글은 책의 단편적인 내용만을 가져왔지만, 책에는 실제 어플리케이션에서 작성될 법한 프론트 코드를 기반으로 예제를 작성했으며, 계층에 대한 그래프도 같이 있어서 이해하기 훨씬 쉽다. 꼭 한 번 읽어보는 것을 추천한다.

다음 글에서 1부의 후반부 내용인 계층형 설계에 대해 정리해보려 한다.
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/next/hydrate</guid>
      <title>Next.js의 렌더링 과정(Hydrate) 알아보기</title>
      <link>https://www.howdy-mj.me/next/hydrate</link>
      undefined
      <pubDate>Fri, 05 Aug 2022 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>next</category>
      <content:encoded>
누군가 나에게 Next.js를 쓰는 이유를 물어본다면, 가장 먼저 SSR 때문이라고 대답할 것 같다. Next.js 공식 홈페이지에서도 가장 먼저 강조하고 있는 것이 'hybrid static & server rendering'인 것처럼 말이다.

하지만 정확히 어떠한 과정을 거쳐 렌더링이 되는지 몰라서 찾아보았다.



### Next.js의 Pre-rendering

React는 CSR(Client-side Rendering)로, 처음에 브라우저가 빈 HTML을 파일을 받아 아무것도 보여주지 않다가, 사용자의 기기에서 렌더링이 진행되어 한 번에 화면을 보여준다.


  
  https://nextjs.org/learn/foundations/how-nextjs-works/rendering


반면, Next.js는 모든 페이지를 미리 렌더링(pre-render)한다. 이는 Next.js가 모든 일을 클라이언트 측에서 모든 작업을 수행하는 것이 아니라, 각 페이지의 HTML을 미리 생성하는 것이다. 생성된 HTML은 해당 페이지에 필요한 최소한의 자바스크립트 코드와 연결된다. 그 후 브라우저에 의해 페이지가 로드되면, 자바스크립트 코드가 실행되어 페이지와 유저가 상호작용할 수 있게 된다.

이러한 과정을 hydration이라 하며, 곧 관련 코드를 훑어볼 예정이다.


  
  https://nextjs.org/learn/foundations/how-nextjs-works/rendering




그리고 Next.js에서 미리 렌더링 하는 방식은 두 가지로 나뉘며, HTML이 생성되는 시점이 다르다. 하나는 빌드 타임에 HTML에 생성되어 매 요청마다 이를 재사용하게 해주는 SSG(Static-site Generation)이고, 다른 하나는 매 요청마다 HTML을 생성하는 SSR(Server-side Rendering)이다.

Next.js는 기본적으로 SSG를 이용해 정적인 페이지를 미리 생성하여 SEO에 유리하다. 따라서, 블로그, 포트폴리오, 메뉴얼 등 데이터가 바뀌지 않는 페이지는 SSG를 사용한다. 반면, 유저의 요청마다 데이터가 변경될 수 있는 맞춤 추천리스트, 장바구니 페이지 등은 SSR을 사용해야 한다.

## Next.js 렌더링 순서

> 아래 코드 모두 next.js/packages/next를 base로 잡고 경로를 작성했으며, 해당 글에서 필요한 부분만 가져왔다. 우측의 Code 링크를 통해 소스코드를 볼 수 있다.

Next.js가 먼저 Server를 거친 후에 Client가 렌더링 되는건 알겠다. 그런데 어떤 코드들을 거쳐서 실제 브라우저에서 볼 수 있는 걸까?



흐름대로 Next.js의 Server의 render.tsx부터 살펴보았다.

server/render.tsx

  (Code)


```tsx {20}
export async function renderToHTML(
  req: IncomingMessage,
  res: ServerResponse,
  pathname: string,
  query: NextParsedUrlQuery,
  renderOpts: RenderOpts
): Promise {
  // ...

  const renderDocument = async () => {
    // ...
    async function loadDocumentInitialProps(
      renderShell?: (_App: AppType, _Component: NextComponentType) => Promise
    ) {
      // ...
      const renderPage: RenderPage = (
        options: ComponentsEnhancer = {}
      ): RenderPageResult | Promise => {
        // ...
        const html = ReactDOMServer.renderToString(
          
            
              {renderPageTree(EnhancedApp, EnhancedComponent, {
                ...props,
                router,
              })}
            
          
        );
        return { html, head };
      };
    }
    // ...
    return {
      bodyResult,
      documentElement,
      head,
      headTags: [],
      styles,
    };
  };
}
```

코드의 양이 상당히 많지만, 현재 중점적으로 봐야하는 부분은 서버에서 어떻게 HTML을 렌더링하고 있는가이다. 그 결과, `renderPage`에서 HTML을 만드는 코드를 찾을 수 있었고, 이 코드는 `ReactDOMServer.renderToString()`을 이용해 ReactNode를 HTML 문자열로 만들고 있다.

### renderToString() (Code)

```js
ReactDOMServer.renderToString(element);
```

React 엘리먼트의 초기 HTML을 문자열로 반환한다.



그리고 이렇게 생성된 HTML은 htmlProps가 되어 document로 반환된다.

server/render.tsx

  (Code)


```tsx {12,21}
export async function renderToHTML(
  req: IncomingMessage,
  res: ServerResponse,
  pathname: string,
  query: NextParsedUrlQuery,
  renderOpts: RenderOpts
): Promise {
  // ...

  const documentResult = await renderDocument();

  const htmlProps: HtmlProps = {
    __NEXT_DATA__: {
      // ...
    },
  };

  const document = (
    
      
        {documentResult.documentElement(htmlProps)}
      
    
  );

  const documentHTML = ReactDOMServer.renderToStaticMarkup(document);

  // ...
  // 운영환경 여부에 따라 prefix에 속성을 다르게 하고,
  // prefix와 suffix 정보를 가진 streams를 선언한다
  // 이때 ''가 prefix에 입력된다

  if (generateStaticHTML) {
    // ...
    return new RenderResult(optimizedHtml);
  }

  return new RenderResult(
    chainStreams(streams).pipeThrough(createBufferedTransformStream(postOptimize))
  );
}
```

Next.js로 만들어진 페이지의 Network 탭에서 서버에서 반환한 HTML을 볼 수 있다.


  
  Next.js 서버에서 반환한 HTML




Next.js 서버에서 어떻게 HTML을 생성하고 정보를 입력하는지 알았으니, 이제 Client 코드를 살펴보자.

client/next.js

  (Code)


```js
initialize({})
  .then(() => hydrate())
  .catch(console.error);
```

우선 `initialize()`가 진행된 다음에 `hydrate()`를 실행하는 것을 알았다. 각각의 코드를 살펴보자.

client/index.tsx

  (Code)


```tsx {4}
export async function initialize(opts: { webpackHMR?: any } = {}): Promise {
  initialData = JSON.parse(document.getElementById('__NEXT_DATA__')!.textContent!);
  window.__NEXT_DATA__ = initialData;

  const prefix: string = initialData.assetPrefix || '';

  appElement = document.getElementById('__next');
  return { assetPrefix: prefix };
}
```

`initialize()`는 서버에서 렌더링한 HTML에서 `__NEXT_DATA__` 를 id로 갖는 엘리먼트의 컨텐츠를 브라우저의 전역객체 `window.__NEXT_DATA__`로 저장한다. 그리고 운영 환경에 따라 assetPrefix를 반환한다.

client/index.tsx

  (Code)


```tsx
export async function hydrate(opts?: { beforeRender?: () => Promise }) {
  // ...
  const renderCtx: RenderRouteInfo = {
    App: CachedApp,
    initial: true,
    Component: CachedComponent,
    props: initialData.props,
    err: initialErr,
  };

  render(renderCtx);
}
```

`hydrate()`는 실행하려는 페이지의 에러가 있는지 확인 및 validation 체크를 하고 없다면 렌더링할 때 필요한 컨텍스트(ex. 라우터, App, Component, initialProps 등)를 `render()`의 인자로 넘겨준다.

```tsx {8}
async function render(renderingProps: RenderRouteInfo): Promise {
  // ...
  await doRender(renderingProps);
}

function doRender(input: RenderRouteInfo): Promise {
  // ...
  renderReactElement(appElement!, (callback) => (
    
      {process.env.__NEXT_STRICT_MODE ? {elem} : elem}
    
  ));
}
```

`doRender()` 함수를 따라가다보면, `renderReactElement()`를 실행한다

client/index.tsx

  (Code)


```tsx {9,12}
let shouldHydrate: boolean = true; // 첫 렌더에서는 항상 true이다

function renderReactElement(domEl: HTMLElement, fn: (cb: () => void) => JSX.Element): void {
  //...
  const reactEl = fn(shouldHydrate ? markHydrateComplete : markRenderComplete);

  // ...
  if (shouldHydrate) {
    ReactDOM.hydrate(reactEl, domEl);
    shouldHydrate = false;
  } else {
    ReactDOM.render(reactEl, domEl);
  }
}
```

그리고 드디어 React에 렌더해주는 `ReactDOM.render()`과 `ReactDom.hydrate()`가 나왔다.

### render() (Code)

```js
ReactDOM.render(element, container[, callback])
```

React 엘리먼트를 DOM(container)에 렌더링하고 컴포넌트에 대한 참조를 반환한다. 만약 이미 container 내부에 렌더링 되었다면, 수정이 필요한 DOM만 업데이트한다.

React 17의 index.js

```jsx {3}
import App from './App';

ReactDOM.render(, document.getElementById('root'));
```

이해가 잘 안갈 수 있으니 코드로 알아보자. React 18에서는 createRoot가 한 번 더 감싸주어서 17 버전의 코드를 가져왔다.

여기서 container는 `index.html` 파일의 root id를 가지고 있는 엘리먼트다. React는 보여주고자 하는 컨텐츠를 HTML의 root 엘리먼트 내부로 넣어주어 페이지를 렌더링해준다. 해당 과정 덕분에 사용자가 웹 페이지에서 상품을 클릭하여 상세 페이지로 이동하는 등의 상호작용이 가능하다.

### hydrate() (Code)

```js
ReactDOM.hydrate(element, container[, callback])
```

기본적으로 `render()`와 동일하지만, ReactDOMServer로 렌더링된 HTML에 이벤트 리스너(자바스크립트 코드)를 연결해주기 위해 사용된다.

> React 18부터는 hydrate()가 아니라 hydrateRoot()를 사용하라고 되어있다. 현재 Next.js는 React 17, 18 버전 사용중이라 아직 바꾸지 않은 것 같은데, 18로 마이그레이션 모두 끝나면 바뀔 것 같다.

## Hydration

위의 과정들을 정리해보자.

Next.js는 서버에서 HTML을 문자열로 가져온 후에, 클라이언트에서 서버에서 보내준 HTML을 `hydrate()` 혹은 `render()`하여 브라우저에 렌더링된다. 이 일련의 과정을 Hydration이라 한다.


  Hydration 번역
  
    사실 아직 hydration의 마땅한 번역 값을 찾지 못했다.
    
      Hydrate는 '수화(水化) 시키다'는 뜻이며, 수화(水化)는 어떤 물질이 물과 결합하여 수화물(물을
      포함하는 화합물)이 되는 현상이다.
    
    
      서버의 데이터가 클라이언트의 DOM과 결합하는 과정을 빗대어 hydrate라는 단어로 정의된 것 같다.
    
  


React는 클라이언트 렌더링만 있어서 유저에게 보여줄 HTML, CSS 그리고 자바스크립트 모두 `render()` 함수를 이용해 생성하여, React가 어떤 DOM을 렌더하는지 알려준다.

반면, Next.js는 서버에서 보여줄 HTML 컨텐츠를 가져오기 때문에 재차 `render()` 함수로 HTML을 생성하여 DOM을 그리는 일은 비효율적이다. 따라서 `hydrate()` 함수로 서버에서 받아온 HTML에 유저가 상호작용할 수 있는 이벤트 리스너만 연결하는 것이다.

### 코드로 확인해보기

Next.js로 만든 프로젝트에서 `getServerSideProps()`를 이용해 데이터를 주입해보자.

```tsx
import React, { useState } from 'react';
import { GetServerSideProps } from 'next';
import styled from 'styled-components';

const StyledContainer = styled.div`
  border: 1px solid blue;
`;

type TempProps = {
  name: string;
};

const Temp = ({ name }: TempProps) => {
  const [color, setColor] = useState('blue');
  return (
     setColor('purple')}>
      Temp page: {name}
    
  );
};

export default Temp;

export const getServerSideProps: GetServerSideProps = async (context) => {
  return {
    props: {
      name: 'howdy-mj',
    },
  };
};
```

위의 코드를 Network 탭의 HTML을 보면 아래와 같다.


  
  서버에서 반환한 Temp 컴포넌트의 HTML Preview


```html


  
    
    
  
  
    
      
        Temp page: howdy-mj
      
    
    
    
      {
        "props": {
          "pageProps": {
            "name": "howdy-mj"
          },
          "__N_SSP": true
        },
        "page": "/temp",
        "query": {},
        "buildId": "development",
        "isFallback": false,
        "gssp": true,
        "scriptLoader": []
      }
    
  

```

서버에서 렌더링한 HTML에 `getServerSideProps()`로 불러온 데이터와 CSS도 같이 반환되는 것을 확인할 수 있다. 이 외, styled-components로 생성한 스타일과 React 내부에서 선언한 state 그리고 onClick 메서드는 `temp.js` 파일에서 확인할 수 있다.

브라우저에 렌더링된 화면은 DOM에 자바스크립트 코드를 서버에서 가져온 HTML에 연결하여 작성한 코드가 모두 정상 동작한다.

{/* ### 궁금점 */}
{/* Next.js의 package.json을 살펴보니, 스크립트 실행을 taskr 라이브러리로 실행하고 있다. */}
{/* 마지막 릴리즈가 2017년도로, 더 이상의 유지보수는 하지 않는 것으로 보이는데 계속 사용하는 이유가 뭘까?라는 궁금증에 남겨둔다. */}



**참고**



- [Next.js](https://nextjs.org/)
- [React](https://reactjs.org/)
- [SPA기반 SSR 구현하기 (feat.React) 3-SSR용 서버 구현과 Hydration]()

{/* - What is a technical definition of "hydration" within NextJS? */}


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/react/react-node-and-jsx-element</guid>
      <title>ReactNode vs. JSX.Element 그리고 ReactElement</title>
      <link>https://www.howdy-mj.me/react/react-node-and-jsx-element</link>
      undefined
      <pubDate>Sun, 24 Jul 2022 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>react</category>
      <content:encoded>
해당 글 작성한 시점의 React는 18.0, TypeScript는 2.8 버전이다.

- DefinitelyTyped/types/react/index.d.ts

## ReactNode vs. JSX.Element

ReactNode, JSX.Element 모두 외부에서 주입받을 컴포넌트의 타입을 정의할 때 가장 많이 사용한다.

### ReactNode

```ts
type ReactNode =
  | ReactElement
  | string
  | number
  | ReactFragment
  | ReactPortal
  | boolean
  | null
  | undefined

type ReactFragment = Iterable
```

ReactNode는 ReactElement를 비롯하여 대부분의 자바스크립트 데이터 타입을 아우르는 범용적인 타입이다. 따라서 어떤 props을 받을 건데, 구체적으로 어떤 타입이 올지 알 수 없거나, 어떠한 타입도 모두 받고 싶다면 ReactNode로 지정해주는 것이 좋다.

참고로 ReactText와 ReactChild는 React를 사용할 때 큰 관련이 없기 때문에 곧 deprecated 될 것이라 명시되어 있다.

Blog.tsx

```tsx
type BlogProps = {
  profile: React.ReactNode
  introduction: JSX.Element
}

const Blog = ({ profile, introduction }: BlogProps) => {
  return (
    
      {profile}
      {introduction}
    
  )
}

export default Blog
```

App.tsx

```tsx
const App = () => {
  return (
    
  )
}

export default App
```


  


`profile`에는 string을 선언할 수 있지만, `introduction`은 string이기 때문에 Element 타입에 선언할 수 없다는 에러가 뜬다.



의아했던 점은, ReactNode에는 ReactElement만 있다는 것이다. 보통 ReactElement와 JSX.Element를 많이 비교하고 있기 때문에 두 개를 같이 아우를줄 알았는데 아니었다.

공통점부터 알아보자면, 두 가지 모두 `React.createElement()`의 리턴 값이다.

## React.createElement()

```jsx
const HowdyMj = () => {
  return howdy-mj
}
```

위와 같이 JSX로 작성된 코드를 자바스크립트로 변환하면 아래와 같다.

```js
const HowdyMj = () => {
  return React.createElement('div', null, 'howdy-mj')
}
```

다른 변환 예시를 보고 싶다면 Babel compiler - online에서 직접 해볼 수 있다.

사실 이렇게만 보면 구체적으로 와닿지 않는다. 위의 컴포넌트를 console로 찍어보자.

```tsx
console.log(HowdyMj())
```


  


그렇다면 위처럼 type, key, props 등을 갖고 있는 것을 알 수 있다.

type은 해당 요소의 HTML 태그를 나타내고, props는 children이나 className, style 등의 속성을 나타낸다.

이걸 `React.createElement()`로 만든다면 아래와 같다.

```jsx
const HowdyMj = () => {
  return React.createElement('div', {
    children: 'howdy-mj',
  })
}
```

이처럼 JSX는 `React.createElement()` 보다 훨씬 간단하게 컴포넌트를 만들 수 있다. 그래서 JSX가 `React.createElement()` 함수에 대한 문법적 설탕을 제공한다고 하는 것 같다.

## ReactElement와 JSX.Element

자 이제 둘의 리턴 타입인 `React.createElement()`에 대해 어느정도 숙지했다. 그렇다면 ReactElement와 JSX.Element의 차이점은 무엇일까?

### ReactElement

ReactElement는 ReactElementType.js에서 flow로 정의되어 있어 쉽게 볼 수 있다.

```ts
export type ReactElement = {|
  $$typeof: any,
  type: any,
  key: any,
  ref: any,
  props: any,
  // ReactFiber
  _owner: any,

  // __DEV__
  _store: { validated: boolean, ... },
  _self: React$Element,
  _shadowChildren: any,
  _source: Source,
|}
```

위에서 이미 본 익숙한 형태의 타입을 볼 수 있다.

```ts
interface ReactElement =
    | string
    | JSXElementConstructor
> {
  type: T
  props: P
  key: Key | null
}

type JSXElementConstructor =
  | ((props: P) => ReactElement | null)
  | (new (props: P) => Component)

type ComponentType = ComponentClass | FunctionComponent

type Key = string | number
```

따라서 type이 받는 T 제너릭은 해당 HTML 태그의 타입을 받고, props는 그 외의 컴포넌트가 갖고 있는 속성을 받는다.

### JSX.Element

JSX.Element는 ReactElement의 타입과 props를 모두 any로 받아 확장한 인터페이스다. 따라서 더 범용적으로 사용할 수 있다.

```ts
// Global
declare global {
  namespace JSX {
    interface Element extends React.ReactElement {}
  }
}

// React Elements
declare namespace React {
  // ... 생략
}
```

또한 React 관련 타입은 모두 React의 namespace에서 선언되었는데, JSX는 global namespace로 선언되어 있다. 따라서 React 내에서 JSX를 import하지 않아도 바로 사용이 가능하다.



**참고**



- When to use JSX.Element vs ReactNode vs ReactElement?
- JSX 소개 | React
- React Element vs Component


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/design/headless-components</guid>
      <title>Headless 컴포넌트</title>
      <link>https://www.howdy-mj.me/design/headless-components</link>
      undefined
      <pubDate>Sun, 19 Jun 2022 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>design</category>
      <content:encoded>
## Headless란?

Headless를 그대로 번역하면 '머리가 없는'이라는 뜻이다.

구글에 Headless를 검색 시, 가장 많이 나오는 단어는 Headless browser로 '창이 없는' 브라우저를 뜻한다. 주로 크롤링할 때 실제로 브라우저 창을 띄우지 않고 화면을 가상으로 렌더링하여 실제 브라우저와 동일하게 동작하는 방식을 뜻한다.

그렇다면 프론트엔드에서 Headless가 어떤 의미를 뜻할까? 먼저 프론트엔드 개발을 하면서 느껴봤을 법한 일을 떠올려보자.

### UI 라이브러리의 한계

외부 UI 라이브러리를 사용할 경우, 유스케이스에 맞게 기능을 새로 추가하거나 변경하고 싶어도 그에 맞게 디자인이나 기능을 수정하기가 매우 어렵다. 더 나아가 해당 라이브러리에 심각한 버그가 있거나, 유지보수를 종료한다고 하면 언젠가는 바꿔야 한다. 그러다 결국 '그냥 컴포넌트를 만들까?'라는 생각을 문뜩 들게 한다.

그래서 나온 개념이 Headless UI Component로 기능은 있지만 스타일이 없는 컴포넌트를 의미한다.

## Component 기반 UI 라이브러리 vs Headless UI 라이브러리

물론 언제나 Headless 라이브러리가 컴포넌트 기반의 라이브러리보다 좋다는 건 아니다. 모두 장단점이 존재하며, 상황에 맞게 사용하면 된다.

### Component 기반 UI 라이브러리

Component 기반 UI 라이브러리는 기능과 스타일이 존재하는 라이브러리를 말하며, 대표적으로 Material UI, Ant Design가 있다.




  
    
    
  
  
    
      장점
      
        
          바로 사용할 수 있는 마크업과 스타일이 존재
          설정이 거의 필요 없음
        
      
    
    
      단점
      
        
          마크업을 자유롭게 할 수 없음
          스타일은 대부분 라이브러리에 있는 테마 기반으로만 변경할 수 있어 한정적임
          큰 번들 사이즈
        
      
    
  




### Headless UI 라이브러리

Headless는 기능은 있지만 스타일이 없는 라이브러리로, Headless UI, Radix UI, Reach UI 등이 있다.




  
    
    
  
  
    
      장점
      
        
          마크업과 스타일을 완벽하게 제어 가능
          모든 스타일링 패턴 지원(ex. CSS, CSS-in-JS, UI 라이브러리 등)
          작은 번들 사이즈
        
      
    
    
      단점
      
        
          추가 설정이 필요함
          마크업, 스타일 혹은 테마 모두 지원되지 않음
        
      
    
  




디자인이 그렇게 중요하지 않고, 커스텀할 곳이 많지 않다면 Component 기반 라이브러리를 사용하면 된다. 하지만 만약 반응형에 따라 디자인이 달라지고, 기능 변경이나 추가가 많이 발생한다면 Headless 라이브러리가 유지보수에 더 좋을 것 같다.

혹은 회사에 디자이너가 없거나 기한이 촉박한 프로젝트라면, 아예 특정 UI 라이브러리만을 사용해서 만드는 경우도 있다.

## Headless Component를 만드는 원칙

하지만 아직 Headless 라이브러리에는 컴포넌트의 종류가 상대적으로 적다. 그래서 바로 사용해야 하는 컴포넌트가 없다면 만들어야 한다.

사실 Headless Component를 만드는 원칙이라기 보다는, 유지보수 하기 좋은 컴포넌트를 만드는 원칙이라고 볼 수 있다.

만드려는 컴포넌트에 어떤 메서드가 있는지를 먼저 결정하기보다, 그 컴포넌트가 **무엇을 수행할 수 있는지**부터 결정해야 한다. 그리고 사용자가 사용할 수 있는 기능들과 방법을 제공해야 한다. 이후에 그 기능을 어떻게 수행할 지 구현하면 된다.

여기서 중요한 점은 기능은 어떻게 구현할지는 컴포넌트 내부에 정의하는 것으로, 외부의 다른 컴포넌트들이나 사용자가 전혀 알지 않아도 된다. 밑의 예시로 한 번 알아보자.



### Checkbox 컴포넌트를 Headless로 리팩토링하기


  


위와 같은 Checkbox 컴포넌트를 만든다면 아래와 같을 것이다.

Checkbox.tsx

```tsx
import { useState } from 'react'

const Checkbox = () => {
  const [isChecked, setIsChecked] = useState(false)
  return (
    
       setIsChecked(!isChecked)}
      />
      체크박스 만들기
    
  )
}

export default Checkbox
```

이를 다른 곳에서 바로 사용할 수 있게 하려면 어떤 내용을 체크하는 지에 대한 라벨, 체크가 되었는지의 상태 값, 체크하는 로직을 props를 받아야 한다. 수정한다면 아래와 같은 형태가 될 것이다.

Checkbox.tsx

```tsx
type CheckboxProps = {
  label: string
  isChecked: boolean
  onChange: () => void
}

const Checkbox = ({ label, isChecked, onChange }: CheckboxProps) => {
  return (
    
      
      {label}
    
  )
}

export default Checkbox
```

App.tsx

```tsx
export default function App() {
  const [isChecked, setIsChecked] = useState(false)
  return (
     setIsChecked(!isChecked)}
    />
  )
}
```

만약 Checkbox를 사용하는 모든 곳에서 디자인과 기능이 동일하다면 이대로 사용해도 문제없다.

하지만 만약 특정 페이지들에서만 색상을 다르게 한다던지, 모바일에서는 체크박스를 오른쪽으로 옮겨야 한다던지 등의 레이아웃의 변경이 필요하다면 어떻게 해야할까? 디자인이 살짝 다르다는 이유로 컴포넌트를 새로 만들거나 내부에서 분기 처리하여 수정하기 시작한다면, 유지보수가 점점 더 힘들어질 것이다.



이럴 때 Headless 컴포넌트로 만들면 좋다. 다시 한 번 Headless 컴포넌트(aka. 유지보수 하기 좋은 컴포넌트)를 만드는 원칙들을 생각해보자.

#### Checkbox 컴포넌트는 무엇을 하는 컴포넌트일까?

- 상태에 대한 라벨(설명)이 있다.
- 마우스로 체크박스나 라벨을 클릭할 수 있다.
- 체크가 안 된 상태라면 박스가 비어있고, 체크가 된 상태면 박스가 ✓ 아이콘이 생긴다.

#### 사용자가 할 수 있는 기능은 무엇일까?

- 사용자는 Checkbox 컴포넌트를 마우스로 클릭할 수 있다.



사용자는 그저 Checkbox 컴포넌트를 클릭할 뿐, 컴포넌트 내부가 어떻게 구현되어 있는지는 알 수 없고, 알 필요도 없다.



Headless 컴포넌트를 만드는 방식은 다양한데, 그 중 세 가지 방법을 소개해보려 한다.



### 1. Compound Component

Material UI, Reach UI등 많은 UI 라이브러리가 Compound 컴포넌트를 사용한다.

> Compound components is a pattern where components are used together such that they share an implicit state that lets them communicate with each other in the background.

Compound 컴포넌트란 같이 사용되는 컴포넌트들의 상태(state) 값을 공유할 수 있게 만들어주는 패턴이다. 코드로 한 번 알아보자.

CheckboxWrapper.tsx

```tsx
import * as React from 'react'

type CheckboxContextProps = {
  id: string
  isChecked: boolean
  onChange: () => void
}

type CheckboxProps = CheckboxContextProps & React.PropsWithChildren

const CheckboxContext = React.createContext({
  id: '',
  isChecked: false,
  onChange: () => {},
})

const CheckboxWrapper = ({
  id,
  isChecked,
  onChange,
  children,
}: CheckboxProps) => {
  const value = {
    id,
    isChecked,
    onChange,
  }
  return (
    
      {children}
    
  )
}

const useCheckboxContext = () => {
  const context = React.useContext(CheckboxContext)
  return context
}

const Checkbox = ({ ...props }) => {
  const { id, isChecked, onChange } = useCheckboxContext()
  return (
    
  )
}

const Label = ({ children, ...props }: React.PropsWithChildren) => {
  const { id } = useCheckboxContext()
  return (
    
      {children}
    
  )
}

CheckboxWrapper.Checkbox = Checkbox
CheckboxWrapper.Label = Label

export default CheckboxWrapper
```

App.tsx

```tsx
import CheckboxWrapper from './CheckboxWrapper'

export default function App() {
  const [isChecked, setIsChecked] = useState(false)
  return (
     setIsChecked(!isChecked)}
    >
      
      체크박스 만들기
    
  )
}
```

컴포넌트 내부에서 state를 공유하기 위해 Context API를 사용해서 처음에 작성해야 하는 코드가 꽤 많다.

하지만 컴포넌트를 사용하는 곳에서는 `` 하위에 어떤 컴포넌트가 있는지 볼 수 있고, 위치도 자유롭게 수정 가능하다.



### 2. Function as Child Component

Function as Child Component는 자식에 어떤 것이 들어올지 예상할 수 없기 때문에 `children` prop으로 받아 그대로 전달하는 것이다.

CheckboxHeadless.ts

```tsx
type CheckboxHeadlessProps = {
  isChecked: boolean
  onChange: () => void
}

const CheckboxHeadless = (props: {
  children: (args: CheckboxHeadlessProps) => JSX.Element
}) => {
  const [isChecked, setIsChecked] = useState(false)

  if (!props.children || typeof props.children !== 'function') return null

  return props.children({
    isChecked,
    onChange: () => setIsChecked(!isChecked),
  })
}

export default CheckboxHeadless
```

App.tsx

```tsx
import CheckboxHeadless from './CheckboxHeadless'

export default function App() {
  return (
    
      {({ isChecked, onChange }) => {
        return (
          
            
            체크박스
          
        )
      }}
    
  )
}
```

Compound 컴포넌트보다 작성해야 하는 코드량이 훨씬 적다. 사용하려는 state 값을 위에서 따로 선언할 필요가 없어, 다른 컴포넌트에 해당 state를 실수로 넣을 일이 적어진다. 그리고 관련된 코드가 한 곳에 모여 있어 읽기 편하다. 하지만 다른 곳에서 해당 state를 공유할 경우, `CheckboxHeadless`가 감싸야 할 코드량이 많아지는 단점이 있다.



### 3. Custom hooks

React를 사용해본 사람이라면 가장 익숙할 법한 커스텀 훅이다.

useCheckbox.ts

```ts
import { useState } from 'react'

export const useCheckbox = () => {
  const [isChecked, setIsChecked] = useState(false)

  return {
    isChecked,
    onChange: () => setIsChecked(!isChecked),
  }
}
```

App.tsx

```tsx
import { useCheckbox } from './useCheckbox'

export default function App() {
  const { isChecked, onChange } = useCheckbox()
  return (
    
      
      체크박스 만들기
    
  )
}
```

위의 두 방식보다 간단하고 직관적이다. 하지만 state 값을 사용되어야 하는 Checkbox 컴포넌트가 아니라 다른 곳에 작성할 실수가 발생할 수 있다.



달력의 외관이 다르더라도 위의 특징을 갖고 있다면 사용자는 달력이라 생각한다.

예를 들어 사용자가 '달력을 본다'라는 메세지를 Calendar에게 요청하면, Calendar는 달력을 보여주는 대신 한 해의 날짜를 다 보여줄 수도 있고, 월 단위로 나누어서 보여줄 수도 있고, 주 단위로 나누어서 보여줄 수도 있다. 이처럼 Calendar가 달력을 어떻게 보여줄지는 내부에서 결정한다.

물론 사용자가 원한다면 '달력을 본다(월 단위로)'처럼 메세지에 내용을 추가하여 요청할 수 있다. 이렇게 컴포넌트에 기능을 실행하도록 요청하는 방법이 바로 인터페이스(interface)이며, 외부에서 유일하게 컴포넌트 내부와 소통할 수 있는 수단이다.

```ts
type UnitType = 'year' | 'month' | 'week'

interface CalenderProps {
  open: (unit: UnitType) => Calendar
}
```

Calendar의 인터페이스는 위와 같을 것이며, 우리는 Calendar의 내부가 어떻게 구현되어 있는지 알 수 없으며 알 필요도 없다. Calender의 인터페이스를 보고 원하는 기능을 요청하면 된다.

그리고 공휴일이 포함된 달력을 구현해야 할 수도 있는데, 공휴일은 나라마다 다르다. 따라서 Calendar 컴포넌트에 바로 적용하기 보다는 CalendarKor 처럼 따로 생성하여 구현하는 것이 나중에 유지보수 차원에서 더 좋을 수 있다. 물론 국내 달력만 구현한다면 Calendar 컴포넌트 내부에 구현해도 무방할 것이다. -->

## 결론

Headless 컴포넌트는 스타일이 없고 로직만 존재하는 것을 뜻한다. 마크업과 스타일 수정이 자유롭기 때문에 기능 변경이 많은 곳에서 유용하다. 하지만 장단점이 명확하니 상황에 맞게 도입해야 한다.

그리고 사실 기능은 언제든 변경될 수 있다. 따라서 어느 컴포넌트든 유지보수 하기 좋은 컴포넌트를 만들어야 한다. 유지보수 하기 좋은 컴포넌트란, 변경에 쉽게 대응할 수 있는 컴포넌트다. Headless라는 개념도 변경에 쉽게 대응하기 위해 생겨난 것이라 생각한다.

변경에 쉽게 대응하기 위해서는 해당 컴포넌트가 무엇을 하는지 알아야 하며, 내부와 외부에 두어야 할 것을 완전히 분리해야 한다. 외부가 변경되었다 하더라도 내부 컴포넌트가 영향을 받아서도 안되고, 내부가 수정되었다 하더라도 외부가 변경되어서도 안된다.



**참고**



- The Sexiness of Headless UI Components
- HEADLESS USER INTERFACE COMPONENTS
- FUNCTION AS CHILD COMPONENTS
- React Hooks: Compound Components
- ⚛️ 🚀 React Component Patterns
- 객체지향의 사실과 오해, 조영호 (2015)
- TanStack Table | Introduction



The complete guide to building headless interface components in React -->

Headless UI Components: A Journey With High Order Components, Render Props, and Custom Hooks -->


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/javascript/how-to-read-ecmascript</guid>
      <title>ECMAScript 스펙 읽는법</title>
      <link>https://www.howdy-mj.me/javascript/how-to-read-ecmascript</link>
      undefined
      <pubDate>Fri, 03 Jun 2022 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>javascript</category>
      <content:encoded>
JavaScript 관련하여 궁금한 점이 있을 때 이것저것 찾다보면 그 종착지는 언제나 ECMAScript였다. 그러나 엄청난 길이의 스크롤을 보고 주눅이 들었고, 차분히 읽어보기로 마음 먹었을 때는 처음 보거나 정의를 알 수 없는 것들이 많이 있었다. 그러다 참조 링크를 계속 타고 들어가서 이해할때 쯔음, 처음에 무엇때문에 이걸 찾아봤는지 까먹는 나를 발견할 수 있었다.

'언젠간 이해가 되겠지' 하면서 ECMAScript를 계속 읽어보던 중, How to Read the ECMAScript Specification 글을 보고 '나만 어려운게 아니구나'란 안도감이 들었고, 가장 궁금했던 내용들 위주로 작성해보았다.

## ECMAScript, JavaScript의 차이

JavaScript를 공부하는데 왜 ECMAScript를 봐야할까? 이 둘의 차이는 정확히 무엇일까? 그리고 구글링하다보면 ECMA-262, TC39 등 용어 자주 같이 등장하는데 이건 또 뭘까?

### Ecma International

Ecma International은 1961년부터 현재까지 국제 정보통신기술(ICT, Information and Communications Technology)과 전자제품(CE, Consumer Electronics)의 표준 규격(standards)을 개발하고 발표하는 곳이다. 우리가 핸드폰 혹은 컴퓨터 등의 전자기기로 사용하는 대부분의 규격을 Ecma에서 관리하고 있다고 볼 수 있다.

현재 관리하고 있는 규격들은 여기에서 확인할 수 있다.

### ECMA-262, ECMAScript, TC39

그리고 Ecma International에는 수 많은 규격들이 존재하는데, 그 중 하나가 ECMA-262이며 곧 ECMAScript다.

> ECMA-262: This Standard defines the ECMAScript 2021 general-purpose programming language.

ECMAScript는 원래 스크립트 언어로 설계되었으나, 브라우저 외에서 동작할 수 있도록 실행시켜주는 Node.js가 나오면서 범용 프로그래밍 언어로 사용되고 있다.


  용어: 스크립트 언어, 범용 프로그래밍 언어
  
      스크립트 언어(scripting language): 응용 소프트웨어를 제어하는 언어로 독립적으로 사용할 수 있으며, 컴파일없이 실행가능한 언어다.
      
      - 대표적인 스크립트 언어로는 JavaScript, Python, 셸(Shell) 스크립트가 있다.
      
      *컴파일(compile)은 코드가 실행되기 전에 소스코드 전체를 컴퓨터가 바로 실행할 수 있는 기계어로 변환하는 작업을 말하며, 대표적인 언어는 C언어, Java가 있다.
      
      범용 프로그래밍 언어(general-purpose programming language): 다양한 도메인의 소프트웨어를 개발하기 위해 설계된 프로그래밍 언어
      
      - 예를 들어, HTML은 웹 페이지 작성에만 사용되기 때문에 범용 언어가 아니다.
      
  





  
  ECMA-262 Classification


ECMA-262의 분류를 보면, TC39라고 적혀있다. Technical Committees(이하 TC)는 Ecma의 기술 작업을 수행하는 조직이며, 하위에는 TG(Task Group)로 나누어 특정 영역을 관리하게 한다.

TC39는 ECMAScript의 표준화를 관리하며, 언어 문법(language syntax), 의미(semantics), 그리고 라이브러리 및 언어를 지원하는 상호 보완적인 기술이 포함되어 있다. 하위 태스크에는 ECMA-262의 ECMAScript 언어, ECMA-402의 ECMASCript 국제화 API 스펙, 보안이 있다. Ecma TC39 Github에 가보면 관련 레포들이 있는 걸 확인할 수 있다.

### ECMAScript와 JavaScript

그렇다면 ECMAScript와 JavaScript의 관계는 어떻게 되는걸까?

ECMAScript는 여러 기술을 기반으로 만들어졌는데, 가장 유명한 것이 JavaScript와 JScript이다. 각각 Netscape Navigator 2.0 브라우저와 Microsoft의 IE 3.0 브라우저에서 사용되기 위해 만들어진 언어다. 브라우저마다 사용되는 스크립트 언어가 다르다보니, 같은 웹 페이지인데 브라우저에 따라 동작하지 않는 문제가 발생했다. 이에 Netscape는 표준화를 위해 JavaScript 기술 규격을 Ecma International에 제출하였고, 이것이 곧 ECMA-262(ECMASCript)가 되었다.

사실 Netscape는 JavaScript를 규격 이름으로 제출했지만, 당시 상표권이 Sun Microsystems(현 Oracle)에 있었기 때문에 사용이 불가하여 ECMAScript로 명명되었다.

즉, ECMASCript는 스크립트 언어들이 모두 호환되도록 만들어진 표준화된 스펙이다. 따라서, ECMAScript는 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수, 표준 빌트인 객체 등 핵심 문법을 규정한다. 그리고 각 브라우저는 ECMAScript를 준수하여 자바스크립트 엔진(ex. Webkit, Gecko, Blink 등)을 구현한다.

실행 환경이 브라우저인지 Node.js인지에 따라 JavaScript에서 지원하는 API가 달라지는데, ECMAScript를 다루는 것은 같다. 브라우저에서 사용할 경우 브라우저가 지원하는 Web API를, Node.js는 Node.js 고유의 API를 지원한다.


  
  모던 자바스크립트 Deep Dive, 이웅모 (2020), p18


## ECMAScript에서 다루는 내용

JavaScript와 ECMASCript의 차이를 이해했다면, ECMAScript에서 어떤 내용을 다루는지 파악하기 쉽다.

### 다루는 내용

- 문법(syntax)
  - 원시(primitive) 값이 무엇인지
  - if문
  - for, for-in, for-of, while등의 반복문
- 의미(semantics)
  - var가 어떻게 변수명을 결정하는지
  - if문이 무엇을 평가하고 그 결과 값이 무엇인지
  - for가 어떻게 반복문을 실행하는지
- 표준 빌트인 객체
  - Object, Array, Function, Number, Math, RegExp,Proxy, Map, Promise, ArrayBuffer, TypedArray, globalThis, ...

### 다루지 않는 내용

- 브라우저와 Node.js에서만 동작하는 것
  - console, setTimeout(), setInterval(), clearTimeout(), clearInterval()
- 브라우저에서만 동작하는 것
  - window, alert(), confirm(), DOM, BOM
- Node.js에서만 동작하는 것
  - Buffer, process, global
  - module, exports, require(), \_\_dirname, \_\_filename

## if문으로 ECMASCript 스펙 살펴보기

누구나 다 알법한 The if Statement으로 ECMASCript 스펙을 살펴보자.


  
  if문 ECMAScript 스펙




당황할 수 있다.

하지만 우리는 이미 if문이 무엇이고 어떻게 동작하는지 알고 있으니, 차근차근 살펴보자.

### 문법(Syntax)

처음에는 if문의 문법에 대해 설명한다.


  




if...else 문과 if 문을 정의한 것으로 보인다. 그런데 문(Statement)과 표현식(Expression) 옆에 있는 [Yield, Await, Return]은 무엇일까?

이건 ECMAScript의 5.1.5 Grammar Notation에 정의되어 있는데, 필자도 정확하게 이해한 상태가 아니라 이런 것이겠구나 정도로만 작성해보겠다.



정의하려는 문(Statement)이 italic체로 표시되어 있으며 콜론(:) 다음에 정의된다.


  IfStatement :
  
    &nbsp; &nbsp; &nbsp; &nbsp;  if ( Expression ) Statement else Statement
  
  
    &nbsp; &nbsp; &nbsp; &nbsp;  if ( Expression ) Statement [lookahead ≠ else]
  


IfStatement 옆에 있는 [Yield, Await, Return]은 [parameters]라 하며, 해당 문이 반환할 수 있는 값으로 해석했다. _(의역이며, 밑의 예시에서 다시 살펴보자)_

parameters는 하나 혹은 그 이상이 있을 수 있고, 모든 곳에서 반드시 모든 parameter를 참조하는 것은 아니다. 그리고 `+`는 해당 값을 필수로 포함하라는 뜻이며, `?Yield`는 상위에 `_Yield`가 있는 것에서만 붙는다는 뜻이다.

`[In]`은 관계연산자(relational operator)로 두 개의 관계를 비교하는 것으로 항상 Boolean 값으로 반환된다. 이를 for...in의 in과 혼동하지 않아야 한다.

```js
// ifStatement을 해당 if문 외부의 블럭 요소(여기서는 checkIsFemale 함수)라 이해하고 작성했다.
// 하지만 틀린 내용일수 있으니 문맥 이해하는 정도로만 넘겨주었으면 좋겠다.
const checkIsFemale = (gender) => {
  if (gender === 'female') {
    return true;
  }
};
```

`checkIsFemale`은 return 값만 존재하는 문이다. 따라서 지금은

```
IfStatement_Return:
  Expression_In {       # 두 개의 관계를 비교하는 표현식
    Statement_Return    # return이 있는 문
  }
```

만약

```js
const checkIsFemale = async () => {
  const gender = await getUserGender();
  if (gender === 'female') {
    return true;
  }
};
```

였다면,

```
IfStatement_Await_Return:
  Expression_In {
    Statement_Await_Return
  }
```

이 되는 것이다.

opt이 붙어있다면, 그건 옵셔널하다는 뜻이다. -->

마지막으로 [lookahead ≠ else]는, 바로 뒤에 오는 토큰(최소 단위)가 else가 아니다. _(제대로 이해 못한 것 같아 추후 보충 필요)_



요약된 문법 내용은 A Grammar Summary에서 볼 수 있다.

### Static Semantics

정적 의미론(Static Semantics)은 코드가 실행되기 전에 해당 의미가 유의미한지 파악하며, 주로 초기 오류(Early errors)를 잡는데 사용된다. 초기 오류는 eval이 호출되어 평가되는 시점에 보고되며, 평가 코드의 평가를 중단할 수 있다. 초기 오류가 아닌 모든 오류는 런타임 오류(runtime errors)다.


  




if문에서 Early error가 나는 경우는 한 가지다.

IsLabelledFunction은 문(Statement, 이하 stmt)을 인자로 받으며 Boolean을 반환하는 추상 연산자(abstract operation)이다. IsLabelledFunction이 true를 반환하는 조건은 stmt 내부에 함수 선언문이 있는 경우다.

```js
if (true) {
  function test() {
    // TS1252: Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'.
    console.log('test');
  }
}
```

위 처럼 if문 안에 함수 선언문을 존재할 경우, IDE에서 바로 빨간 밑줄과 함께 에러 메세지를 보여준다.

### Runtime Semantics

런타임 의미론(Runtime Semantics)은 반드시 런타임에 호출되어야 하는 의미론을 명시하는 알고리즘을 말한다. 해당 부분이 주로 개발자가 사용하는 로직이며, 주로 어떻게 평가되는지 알려준다.


  


초록색으로 되어 있는 value를 클릭하면 매칭되는 단어들이 같은 색으로 칠해져 읽기 더 수월하다.


*해당 글에서 Completion Record와 UpdateEmpty()가 무엇인지 서술하지 않지만, 이해하는데 무리는 없을 것이다. 


if..else 문만 해석하자면 아래와 같다.


  exprRef를 조건문의 결과라 가정하고,
  exprValue는 exprRef의 값을 Boolean으로 반환한 값이라면,
  exprValue가 true라면,
    - a. stmtCompletion이 첫 번째 Statement를 평가한 결과값으로 한다.
  그 외라면, 
    - b. stmtCompletion이 두 번째 Statement를 평가한 결과값으로 한다.
  반환값을 결정한다. (if문에 return이 있다면 그 값을 반환하고, 아니라면 undefined를 반환한다)


## 맺음

항상 ECMAScript를 읽으면서 '이게 도대체 뭘까...'하면서 찾아보지 않고 그냥 넘기다보니 계속 모르는 상태로 있었다. 앞으로도 계속 이렇게 넘어하면 완전히 이해할 수 없다고 생각이 들어서 하나하나 뜯어보았다.

물론 지금도 완벽하게 이해하고 작성한 건 아니다. 그렇지만 이번에 습득한 내용을 토대로 하나씩 개념을 익혀가다보면, 언젠가는 ECMAScript의 규격을 이해할 수 있지 않을까란 생각이 든다.



**참고**



- Ecma International
- ECMAScript 2023 (작성일 기준 2022.5.26 버전)
- What’s the difference between JavaScript and ECMAScript?
- 모던 자바스크립트 Deep Dive, 이웅모 (2020)
- Understanding the ECMAScript spec, part 3
- How to Read the ECMAScript Specification
- What are [Yield, Await, In, Return] in EcmaScript grammar


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/general/history-of-web</guid>
      <title>웹 브라우저의 역사</title>
      <link>https://www.howdy-mj.me/general/history-of-web</link>
      undefined
      <pubDate>Fri, 27 May 2022 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>general</category>
      <content:encoded>
웹 브라우저는 오늘날 우리들이 사용하고 있는 크롬, 사파리, 파이어폭스, IE 등처럼 웹 페이지를 볼 수 있는 프로그램이다. _(해당 글에서는 웹 브라우저만 다루며, 이하 '브라우저'라 칭한다)_

지금의 웹 페이지는 상당히 많은 정보를 담고 있다. 쇼핑몰일 경우, 우리가 사고 싶은 물건을 장바구니에 담고 결제하는 등 다양한 조작이 가능하지만, 최초의 브라우저는 그저 단순히 텍스트로만 이루어진 문서를 볼 수 있는 정적인 페이지였다.

## 최초의 브라우저, WorldWideWeb

1990년, 팀 버너스리(Tim Berners-Lee)는 CERN(유럽 입자 물리 연구소)에 있었는데, 연구 자료의 관리와 공유를 쉽게 하기 위해 어디서든 자료를 열람할 수 있는 시스템을 만들었다.


  
  https://cds.cern.ch/record/2665088


위 이미지가 당시 연구소에 제출했던 제안서다.

하이퍼링크(참조)를 통해 한 문서에서 다른 문서로 접근할 수 있는 **하이퍼텍스트(Hypertext)**기반의 정보 저장 시스템이다. 그리고 어느 컴퓨터에서든 사용가능하도록 하기 위해, 브라우저가 서버에게 요청해서 문서를 받아올 수 있는 규칙인 **HTTP(Hypertext Transfer Protocol)**, 각 하이퍼링크가 가리키는 고유 주소인 **URI** 그리고 문서의 형식을 **HTML**로 정의했다.

이때 HTTP는 오로지 문서를 가져오는 용도로만 쓰였기 때문에 GET 메서드만 있었다.


  
  https://www.w3.org/People/Berners-Lee/WorldWideWeb.html


위 화면이 최초의 브라우저이자 브라우저 에디터인 WorldWideWeb이며, 이를 이용해 만든 최초의 웹사이트는 info.cern.ch이다. 훗날 W3C(World Wide Web)와의 이름 충돌을 피하기 위해 Nexus로 이름을 바꾸었다.


  용어: W3C(World Wide Web)
  
      웹 표준을 개발하고 장려하는 조직으로 1994년 팀 버너스리를 중심으로 설립되었다.
  


## Mosaic, Netscape 그리고 자바스크립트

1993년, 인터넷이 막 보급되면서 사람들이 브라우저를 조금씩 쓰기 시작했는데, 텍스트로만 페이지를 작성하다보니 어느정도 한계가 존재했다.

당시 NCSA에 다니고 있던 마크 앤드리슨(Marc Andreessen)이 최초로 텍스트와 이미지를 함께 보여주는 브라우저 **Mosaic**을 만들었다. 인터넷을 사용하는 사람이 2천만 명도 안되던 시기에, 1년 반만에 2백만 다운로드가 될 정도로 유명한 브라우저가 되었다.


  용어: NCSA(National Center for Supercomputing Applications)
  
      1986년에 설립되었으며, 슈퍼 컴퓨터망에서 이용하게 될 각종 프로그램과 통신 규약을 연구하는 국립 슈퍼 컴퓨터 응용 센터다.
  





  
  https://www.wired.com/2010/04/0422mosaic-web-browser/


1994년에 앤드리슨은 Mosaic으로 Netscape라는 회사를 설립하려 했으나, Mosaic의 저작권이 NCSA에 있었기 때문에 다시 무에서 Netscape Navigator라는 브라우저를 새로 만들었다. Mosaic보다 더 완성도 있게 출시해서 얼마 지나지 않아 브라우저 점유율의 90%를 차지하게 되었다.




  
  https://www.arnnet.com.au/slideshow/557401/pictures-visual-history-netscape-navigator/




### 자바스크립트의 탄생

브라우저를 사용하는 유저들이 많아지다보니, 브라우저 내에 쿠키나 인증 정보를 HTTP header에 담아 서버에 요청하면, 서버가 그 데이터를 이용해 가공한 화면을 보여주기 시작했다. 이렇듯 서버는 동적인 응답을 하기 시작했지만, 브라우저는 여전히 정적인 화면만을 보여주었다.

Netscape는 브라우저 역시 더 동적으로 바뀔 필요가 있음을 느꼈다. HTML은 그대로 작성하면서, 이미지나 플러그인 등을 쉽게 삽입할 수 있는 언어가 필요하다고 생각했다. 그리하여 브렌던 아이크(Brendan Eich)를 영입하게 되었고, 단 10일 만에 자바스크립트를 개발했다.

1996년도에 Netscape Navigator 2.0을 출시하면서 자바스크립트를 지원했고, 1997년에 자바스크립트의 표준화를 위해 기술 규격을 ECMA International에 제출했고, 곧 ECMA-262의 이름 아래에 ECMAScript 사양이 출범하게 되었다.


  용어: ECMA International, ECMAScript
  
      ECMA International은 정보와 통신 시스템을 위한 국제적 표준화 기구다.
      ECMAScript는 ECMA International이 ECMA-262 기술 규격에 따라 정의하고 있는 표준화된 스크립트 프로그래밍 언어를 말하며, 자바스크립트의 표준화를 위해 만들어졌다.
      스크립트 언어는 독립된 시스템에서 작동하도록 설계된 프로그래밍 언어다.
      ECMAScript 사양을 읽으면 어떻게 스크립트 언어를 만들어야 할지 알려주며, 자바스크립트 문서를 읽으면 이 스크립트 언어를 어떻게 사용해야 하는지를 알 수 있다.
  




자바스크립트의 등장으로 팝업창을 띄운다던지, 상태바에 메세지를 넣는다던지 등의 브라우저에 동적인 효과를 줄 수 있게 되었다.

## 1차 브라우저 전쟁 (IE vs. Netscape)

1995년, 마이크로소프트에서 Mosaic 코드를 기반으로 인터넷 익스플로러(IE)를 만들면서 1차 브라우저 전쟁이 시작되었다.

1996년 iframe, CSS 지원, ActiveX 컨트롤, 인라인 멀티미디어 등의 다양한 기능을 포함한 IE 3.0이 나왔으나, 브라우저 점유율을 뺏어오기가 생각보다 쉽지 않았다.


  용어: iframe, ActiveX
  
    
      iframe: 현재 문서 안에 다른 HTML 페이지를 삽입할 수 있다. 주로 지도, 동영상, 다른 페이지를 삽입할 때 사용한다.
    
    
      ActiveX: 응용 프로그램을 컴퓨터에 설치한 후 페이지에 접근하도록 만들어주는 것이다. 자바스크립트나 Adobe Flash는 브라우저 내부에서만 실행되도록 설계되었지만, ActiveX는 외부 프로그램도 설치만하면 바로 실행할수 있어 보안에 무척 취약했다.
    
  




이미 대부분의 사람들이 Netscape Navigator를 사용하고 있었고, 4.5 버전에 메일 기능을 포함하여 Netscape Communicator로 리브랜딩했기 때문이다.


  
  https://www.arnnet.com.au/slideshow/557401/pictures-visual-history-netscape-navigator/




이에 질세라 IE도 Netscape Communicator에 있는 기능들을 포함하고, favicon 아이콘, 동적으로 innerHTML 요소를 업데이트 하는 기능 등 다양한 기능을 추가한 4.0 버전 출시했다.


  
  https://www.webdesignmuseum.org/web-design-history/internet-explorer-4-0-1997




IE 4.0 출시를 축하하기 위해 IE 직원들이 Netscape 본사 앞에 IE 로고인 'e'를 갖다 두었는데, 다음날 Netscape 직원들이 그 위에 자신들의 마스코트인 용을 올려둔 여담도 있다.


  
    
    https://medium.com/@ddprrt/tales-from-the-browser-wars-mozilla-stomps-internet-explorer-799035887cb1
  

  
    
    http://home.snafu.de/tilman/mozilla/stomps.html
  


그도 그렇듯 당시만 해도 Netscape의 점유율이 72%였고, IE는 18% 밖에 되지 않았다.



하지만 전세계 90%가 윈도우을 사용하던 시기에 IE를 윈도우의 기본 브라우저로 설정하자 IE의 점유율이 점진적으로 올라갔으며, 2000년부터 80% 이상의 점유율을 가져오면서 1차 브라우저 전쟁에서 승리했다고 볼 수 있다.


  
  https://sudonull.com/post/80379-Never-give-up-how-Netscape-waged-an-unequal-battle-with-Internet-Explorer




### FireFox, Safari의 출범

Netscape는 개발을 중단하면서 이를 오픈소스로 풀었는데, 이때 비영리 재단인 Mozilla가 설립하여 이를 이어 받았다. Mozilla 개발자들은 상업적인 요구 때문에 무분별한 기능들이 브라우저에 추가되었다고 생각하여, 이를 전부 제거하고 꼭 필요한 기능을 갖춘 경량화한 브라우저 파이어폭스(Firefox)를 2002년에 출시했다.


  
  https://commons.wikimedia.org/wiki/File:Firefox_1.0.png


2003년, 스티브 잡스에 의해 사파리(Safari) 브라우저가 출시했으며, 매킨토시 운영체제에 탑재되었다. 사파리 역시 브라우저에서 꼭 필요한 기능들을 제공했고, 깔끔한 디자인을 추구했다.


  
  https://www.zdnet.com/pictures/safari-1-0/


## Ajax의 탄생

**Ajax(Asynchronous JavasScript And XML)**는 자바스크립트를 사용하여 브라우저가 서버에게 비동기적으로 데이터를 요청하고, 서버가 보내준 데이터를 받아서 웹페이지를 동적으로 업데이트하는 방식을 말한다. _(해당 글은 비동기에 대해 다루지 않는다)_


  용어: XML(eXtensible Markup Language)
  
    W3C에서 개발된 특수한 목적을 갖는 마크업 언어로, 인터넷에 연결된 시스템끼리 데이터를 쉽게 주고 받을 수 있게 한다.
    HTML은 문자의 크기나 색깔 등 데이터 표현 방식에 치중되어 문서 구조 정보 파악이 어렵다. 반면 XML은 단순히 데이터 교환을 위해 구조만을 정의하고 있다. 또한 HTML과 달리 브라우저에서만 열리는 것이 아니라, 어느 환경에서도 모두 읽을 수 있다.
  




Ajax는 브라우저에서 제공하는 Web API인 XMLHttpRequest 객체를 기반으로 동작한다.

XMLHttpRequest는 1999년 마이크로소프트에서 개발되었지만 보급이 되지 않다가, 2005년 구글이 Gmail, 구글 맵 등에 사용하면서 널리 퍼졌다. 그리고 2006년 W3C는 XMLHttpRequest 객체를 위한 첫 번째 명세를 생성했으며, 지금은 웹 표준이 되었다.

Ajax가 나오기 전에는, 어떤 몇 개의 단어가 수정되어 브라우저가 이를 서버에 요쳥하면, 서버는 다시 그 페이지 전체를 만들어 전달해주었고, 브라우저는 이를 보여주기 위해 새로고침되어 화면을 보여주었다. 그리고 브라우저는 서버에서 응답을 받을 때까지 아무것도 하지 못하고 기다려야 했다.


  
  https://web.archive.org/web/20061107032631/http://www.adaptivepath.com/publications/essays/archives/000385.php


반면, Ajax가 나오고 나서는 업데이트 할 부분의 데이터만 서버에게 요청하고 받기 때문에 불필요한 데이터 통신이 발생하지 않으며, 새로고침없이 업데이트할 수 있게 되었다.

## IE의 문제, 그리고 크롬의 승리

IE는 1차 브라우저 전쟁에서 승리하기 위해 너무나 많은 기능들이 추가했는데, 웹 표준을 지켜지지 않은 문제도 있었다. 2000년 초반에 나온 파이어폭스, 사파리 역시 이와 같은 문제를 타파하고자 만들었다.

그리고 2008년, 이 흐름을 놓치지 않고 구글에서 크롬(Chrome) 브라우저를 출시했다.

특히, 2010년 애플의 스티븐 잡스가 Thoughts on Flash에서 HTML5, CSS, JavaScript와 같은 웹 표준을 적용할 것이며, 보안, 배터리 성능, 멀티 터치가 불가능 그리고 서드파티 라이브러리를 사용할 경우 의존성이 높아져 새로운 기능 개발이 어렵다는 이유로 iOS에서 Adobe Flash를 사용하지 않을 것이라 발표하면서 더 주목받았다.



곧 본격적인 2차 브라우저 전쟁이 일어났지만, 대중들도 가벼운 브라우저를 원해서 인지, 크롬의 대대적인 업데이트 때문인지 승부는 금방 판가름 났다.

2011년도에 크롬은 9.0 버전에서 대량의 업데이트를 한 번에 풀면서 인기를 끌었다. WebGL을 정식으로 지원하여 자체 그래픽 렌더링을 지원하고, 크롬 웹스토어를 따로 만들어 유저가 원하는 부가기능을 설치할 수 있도록 하는 등, 1년만에 버전 9에서 16으로 올랐다.


  
  https://gs.statcounter.com/browser-market-share/desktop/worldwide/#monthly-200901-202204


2015년도부터 크롬이 50% 이상의 점유율을 꾸준히 유지해오고 있다.

마이크로소프트에서도 웹 표준을 지키는 레이아웃 엔진을 포함한 마이크로소프트 엣지(Microsoft Edge) 브라우저를 출시했으며, 2020년 브라우저 엔진을 크로미움 기반으로 바꾼 신 버전의 엣지가 출시되었다.

(드디어 2022년 6월 15일부터 Windows 10버전에서 IE의 서비스 지원이 종료된다!)



### 소결론

브라우저의 역사를 조사해보면서 프론트엔드 기술 발전이 왜 이렇게 빠른지 알 수 있었다. 처음에는 그저 단순한 정적 페이지를 보여주면 됐지만, 지금은 유튜브처럼 영상을 볼 수도 있고, 후원도 가능하며, 댓글도 달 수 있는 등 유저가 직접 페이지와 상호작용할 수 있어졌다. 정말 짧은 시간 내에 발전했다.

웹 페이지의 형태가 발전하면서 브라우저도 변화하는데, 브라우저마다 사용하는 엔진이 다르고, 표준을 지키지 않은 기능들 때문에 크로스 브라우징 이슈도 처리해줘야 한다. 브라우저 엔진은 주로 '렌더링 엔진' 또는 '레이아웃 엔진'이라 불리며, 웹 페이지를 읽고 사람이 이해할 수 있는 문서로 표시하는 역할을 한다. _(브라우저 엔진 관련해서 나중에 글로 작성해볼 예정이다.)_

이에 발 맞춰 jQuery, AngularJS, React 그리고 Next.js가 나온 것 같다. 물론 지금도 새로운 브라우저(ex. Brave, 네이버 웨일 등)들이 나오고는 있지만 이전만큼의 격변은 아닌 것 같다. 그렇다면 과연 프론트엔드 기술도 어느정도 안정기를 가질 수 있을까? 궁금하다.



**참고**



- Browser Wars | Wikipedia
- Tales from the Browser wars: Mozilla stomps Internet Explorer
- The History of Web Browsers
- Never give up: how Netscape waged an unequal battle with Internet Explorer
- In Pictures: A visual history of Netscape Navigator
- AJAX | Wikipedia
- XML | Wikipedia


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/html/web-accessibility-and-wcag</guid>
      <title>웹 접근성과 웹 콘텐츠 접근성 지침</title>
      <link>https://www.howdy-mj.me/html/web-accessibility-and-wcag</link>
      undefined
      <pubDate>Sat, 07 May 2022 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>html</category>
      <content:encoded>
> 웹 접근성은 매우 중요하며, 시맨틱 마크업을 준수해야 한다.

웹 개발을 했다면 많이 들어봤을 말이다.

그렇다보니 필자는 이를 단순하게 _웹 접근성 = 시맨틱 마크업_, 시맨틱 마크업은 곧 적절한 곳에 올바른 HTML 태그를 작성하는 것이라고만 인지하고 있었다.

그러나 생각했던 것과는 달리 더 상세하고 복잡한 규정이 존재했다.

## 웹 접근성(Web Accessibility)

웹은 누구나 어떤 것으로 접속해도 모두가 동일한 기능을 사용할 수 있어야 한다. 이 문장만 봤을 때는 쉽게 체감되지 않을 수 있다.

장애를 가진 사람들도 웹에 있는 기능을 다 사용할 수 있어야 한다. 시각 장애인의 경우 웹 페이지의 내용을 소리내어 읽어 주어 알려줄 수 있어야 하며, 청각 장애인의 경우 오디오로 된 내용은 텍스트로 읽을 수 있도록 만들어야 한다.

이 외, 웹 접근성이 잘 준수되어 있다면,

- 앱을 깔지 않고도 모바일 웹이 PC와 동일하게 동작하여, 모든 기능을 사용할 수 있다.
- 손가락을 다쳐 키보드 사용이 불편할 경우, 가상 키보드로 입력할 수 있다.
- 인터넷 속도가 느려서 이미지가 늦게 뜨지만 이미지에 대한 설명이 있어 어떤 내용인지 알 수 있다.

지금은 W3C(World Wide Web Consortium)에서 HTML, CSS등의 웹 표준을 개발 중이며, 산하에 WAI(Web Accessibility Initiative, 웹 접근성 이니셔티브)가 웹 접근성과 관련된 지침을 계속 개발하고 정의하고 있다.

## 웹 콘텐츠 접근성 지침

WCAG(Web Content Accessibility Guidelines, 웹 콘텐츠 접근성 지침)는 현재 2.0, 2.1, 2.2 버전이 있으며, 2.2는 2022년 9월에 마무리될 것으로 예정되어있다. 2.2 버전은 이전의 2.0, 2.1 의 내용을 모두 아우르며 변경된 점은 Change Log에서 볼 수 있다.

웹 콘텐츠 접근성 지침은 일반적으로 텍스트, 이미지, 소리와 같은 정보 그리고 구조나 표현 방법 등을 정의한 코드나 마크업을 가리킨다.

그래서 WCAG에서는 크게 네 가지 원칙으로 이를 분류했다. (아래는 2.2 기준으로 작성되었다)

### 1. Perceivable(인지성)

모든 콘텐츠(정보와 사용자 인터페이스 컴포넌트)는 사용자가 인지할 수 있도록 표시되어야 한다.


  사용자 인터페이스 컴포넌트(user interface component)는 사용자가 하나의 기능으로 인식하는 콘텐츠의 일부를 말한다.


**1.1 Text Alternatives (대체 텍스트 제공)**

텍스트가 아닌(non-text) 컨텐츠들에 대한 대체 텍스트가 제공되어야 한다. 대표적인 예로는 이미지에 대한 설명을 작성하는 것이다.

```html





```

일반적으로 가장 많이 보는 예는 CAPTCHA(캡챠)가 있다.


  
  https://www.cloudflare.com/ko-kr/learning/bots/how-captchas-work/


사람인지 봇인지 판단하기 위해 나온 테스트인데, 시각장애인이라면 소리를 들을 수 있게 음성도 같이 제공해주었다.

**1.2 Time-based Media (대체 미디어 제공)**

영상이라면 자막이나 수화 등 대체 가능한 컨텐츠가 있어야 한다.

**1.3 Adaptable (적응 가능한)**

정보나 구조를 잃지 않고 다른 방법(ex. 간단한 레이아웃)으로 표시할 수 있는 컨텐츠를 만든다.

예를 들면,

- 필수로 입력해야 하는 값에는 `*`나 텍스트를 빨간 색상으로 하여 눈에 잘 띄게 한다.
- 체크 박스 옆의 텍스트를 클릭해도 체크박스가 체크 된다.
- 여러 열로 이루어진 문서를 볼 경우, 왼쪽에서 오른쪽으로 위에서 아래로 읽는다.
- 여러 페이지의 설문지일 경우, 다음 페이지로 넘기는 버튼이 어디에 있는지 눈에 띄는 색상을 활용해 잘 찾을 수 있게 한다.
- 사용자의 정보를 기기에서 가져와 자동입력(autofill) 기능을 제공한다.
- 입력하는 내용 옆에 아이콘을 붙여 어떤 내용을 작성해야하는지 시각적으로 알려준다.



**1.4 Distinguishable (구별 가능한)**

배경과 콘텐츠를 구분하여 사용자들이 쉽게 보고 들을 수 있게 한다.

이는 텍스트 색상, 크기, 행간과 배경 색상과의 대비 명도를 통한 강조, 이해하기 쉬운 시각적 자료 그리고 링크와 input등에 마우스나 키보드를 올렸을 때 나타나는 상태 등이 있다.

텍스트와 배경색의 대비 관련해서는 Colorable에서 책정해볼 수 있다. 이 외, 웹 디자이너를 위한, 웹 스타일 가이드 지침서에 잘 정리되어 있으니 확인해보면 좋다.



### 2. Operable(운용성)

사용자 인터페이스 컴포넌트와 네비게이션이 작동되어야 한다.

**2.1 Keyboard Accessible (키보드 접근성)**

모든 기능이 키보드로 동작할 수 있어야 한다.

예를 들면, 마우스의 드래그, 드롭은 복사, 붙여넣기로 대체 가능하며, 그림을 그리는 프로그램에서 생성, 사이즈 조절, 회전 등의 기능의 단축키가 존재한다.

**2.2 Enough Time (충분한 시간)**

사용자가 충분한 시간을 갖고 읽고 사용할 수 있어야 한다.

대표적으로는 어떠한 콘텐츠에 시간 제한이 걸려있다면, 사용자가 직접 그 제한 시간을 끄거나, 조정하거나, 늘릴 수 있어야 한다.






**2.3 Seizures and Physical Reactions (발작과 신체 반응)**

발작이나 신체 반응을 일으키는 방식으로 콘텐츠를 만들면 안된다.

예를 들면 1초에 3번 이상의 플래시 효과나 밝기가 너무 낮은 콘텐츠는 포함되면 안된다.

**2.4 Navigable (이동 가능한)**

사용자들이 탐색하거나, 콘텐츠를 찾고, 어디에 있을지 결정하는 방법을 제공해야 한다. 주로 링크로 페이지를 이동하는 것을 말한다.

**2.5 Input Modalities (입력 양식)**

사용자가 키보드의 다양한 입력을 통해 기능을 보다 더 쉽게 조작할 수 있어야 한다.





### 3. Understandable(이해성)

정보와 유저 인터페이스의 조작은 반드시 이해할 수 있어야 한다.

**3.1 Readable (읽기 쉬운)**

텍스트 콘텐츠 읽기 쉬우며 이해하기 쉬워야 한다.

**3.2 Predictable (예측 가능한)**

예측 가능한 방식으로 표시하고 작동해야 한다. 예를 들어, input 창을 마우스로 클릭할 경우, 해당 input 창 테두리의 색상이 바뀌며 활성화 된 걸 표시하는 것이 있다.

**3.3 Input Assistance (입력 도움)**

사용자의 실수를 방지하고 수정할 수 있도록 도와주어야 한다. 예를 들어, 사용자가 잘못 입력한 경우, 빨간 테두리가와 함께 어떤 형식으로 작성해야 하는지 알려주어야 한다.



### 4. Robust(견고성)

콘텐츠는 보조 기술(assistive technologies)(추후 보충)을 포함한 다양한 사용자 에이전트에 의해 해석될 수 있도록 견고해야 한다.

**4.1 Compatible (호환 가능)**

보조 기술을 포함하여, 현재 및 미래 사용자 에이전트와의 호환성을 극대화해야 한다.

예를 들어, 마크업 언어를 사용해 구현된 콘텐츠에서 요소들은 완전한 시작과 끝 태그를 갖고 있으며, 요소들은 그들의 스펙에 따라 중첩될 수 있으며, 중복된 속성을 포함하지 않는다.

## 예제 및 평가

해당 글에서는 어떤 지침이 있는지 간단하게 훑어본 것이기 때문에 이해하기 어려울 수 있다.

WCAG에서 만든 빠른 참고 자료를 보면, 규칙에 해당하는 예제를 볼 수 있다. 국내는 국가표준 한국형 웹 콘텐츠 접근성 지침 2.1(KWCAG 2.1)(2015년 3월 개정)을 따르고 있으며, 각 항목마다 세부 설명도 첨부되어 있다.

사이트가 웹 접근성을 잘 지켰는지 확인해보려면, 크롬 브라우저의 Screen Reader를 통해 확인해볼 수 있다. 무료에 음성도 제공하여 간편하다.



**참고**



- 웹 접근성 소개 | W3C
- Web Content Accessibility Guidelines (WCAG) 2.2

 -->


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/javascript/type-conversions</guid>
      <title>자바스크립트의 형 변환(Type Conversions)</title>
      <link>https://www.howdy-mj.me/javascript/type-conversions</link>
      undefined
      <pubDate>Mon, 21 Mar 2022 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>javascript</category>
      <content:encoded>
개발하다 보면 string을 number로, number를 string으로 혹은 boolean으로 형 변환을 해야 할 때가 존재한다.

형 변환을 하는 방법에는 여러 개가 있는데 각각의 차이점이 무엇인지 궁금해서 찾아보았다.

아래 코드 모두 console을 생략하고, 우측의 주석이 반환된 결과 값이다.

## string으로 변환

가장 간단한 방법으로는 `+`가 있다.

```js
1 + '1' // '11'
```

하지만 `undefined`나 `null`, `NaN` 같은 값들도 그대로 문자열로 반환하여 따로 예외 처리가 필요하다.

```js
1 + '2' + undefined // '12undefined'
2 + '2' + null // '22null'
3 + '2' + NaN // '32NaN'
```

### String()

```js
String(1) // '1'
String(true) // 'true'
String(false) // 'false'
String(null) // 'null'
String(undefined) // 'undefined'
```

### Object.prototype.toString()

```js
true.toString() // 'true'
false.toString() // 'false'

const one = 1
one.toString() // '1'
```

`toString()`은 인자로 전달한 그 숫자의 진수로 변환해준다. 만약 아무것도 전달하지 않으면 기본 값으로 10진수로 변환한다.

주의할 점이 있다면, 숫자, `null`, `undefined`를 바로 호출하면 SyntaxError가 뜬다.

```js
1.toString(); // Uncaught SyntaxError: Invalid or unexpected token

null.toString() // Error: Cannot read properties of null
undefined.toString() // Error: Cannot read properties of undefined
```

반면 빈 객체, 빈 배열을 하면 예상 외의 값이 반환된다.

```txt
({}.toString()) // '[object Object]'
([]).toString() // ''
```

_추후 내용 추가_

## number로 변환

가장 간단한 방법으로는 `/`나 `*` 가 있다.

`true`는 1로, `false`와 `null` 0으로 묵시적 형 변환을 한 다음에 계산된다.

```js
// 1. '/' 사용
'6' / 2 // 3
true / 2 // 0.5
false / 2 // 0
null / 2 // 0

// 2. '*' 사용
'6' * 2 // 12
true * 2 // 2
false * 2 // 0
null * 2 // 0
```

하지만 숫자 외 문자가 포함된 문자열이나, `undefined`는 인식하지 못하고 NaN을 반환한다.

```js
'hello' / 2 // NaN
'he1' / 2 // NaN

undefined / 2 // NaN
undefined * 2 // NaN
```

단, `null`은 결과 값이 조금 다르다.

```js
2 * null // 0
null / 2 // 0

2 / null // Infinity
```

### Number()

빈 문자열, 빈 배열, `null`은 0을 반환하고, 숫자 외의 문자가 포함된 문자열, `undefined`, 빈 객체는 NaN을 반환한다.

```js
Number('123') // 123
Number('123.1') // 123.1

Number(true) // 1
Number(false) // 0

// 0 반환
Number('')
Number([])
Number(null)

// NaN 반환
Number('howdy')
Number('mj123')
Number('123kim')
Number(undefined)
Number({})
```

### parseInt()

위의 예제를 그대로 가져와서 실행해보면 아래와 같은 결과가 나온다.

```js
parseInt('123') // 123
parseInt('123.1') // 123

// NaN 반환
parseInt(true)
parseInt(false)

// NaN 반환
parseInt('')
parseInt([])
parseInt(null)

// NaN 반환
parseInt('howdy')
parseInt('h123')

parseInt('123kim') // 123
```

falsy, truthy와 상관없이 숫자가 들어간 것만 반환해주며, 정수로만 변환해준다.

그리고 앞에 띄어쓰기가 존재하는 숫자+문자 혼합일 경우, 숫자인 곳 까지만 정수로 변환한다.

```js
parseInt(' 3 ') // 3
parseInt(' 3.2 ') // 3
parseInt(' 1mj23') // 1
parseInt(' 123howdy') // 123
```

### parseFloat()

위의 예제를 그대로 가져와보자.

```js
parseFloat('123') // 123
parseFloat('123.1') // 123.1
parseFloat('314e-2') // 3.14
parseFloat('0.0314E+2') // 3.14

// NaN 반환
parseFloat(true)
parseFloat(false)

// NaN 반환
parseFloat('')
parseFloat([])
parseFloat(null)

// NaN 반환
parseFloat('howdy')
parseFloat('h123')

parseFloat('123kim') // 123

parseFloat(' 3 ') // 3
parseFloat(' 3.2 ') // 3.2
parseFloat(' 1mj23') // 1
parseFloat(' 123howdy') // 123
parseFloat(' 123.2howdy') // 123.2
```

parseInt()와 달리 항상 10진수를 사용하며 소수점 모두 숫자로 변환해준다.

단, `parseInt()`와 `parseFloat()` 모두 BigInt를 Number로 반환하여 매우 큰 수나 매우 작은 수일 경우 정확한 값을 반환하지 못한다.

```js
parseFloat(Number.MIN_SAFE_INTEGER) // -9007199254740991
parseFloat(Number.MAX_SAFE_INTEGER) // 9007199254740991

parseInt(900719925474099267n) // 900719925474099300
parseInt('900719925474099267n') // 900719925474099300

parseFloat(900719925474099267n) // 900719925474099300
parseFloat('900719925474099267n') // 900719925474099300
```

추후 BigInt 관련해서 글을 써 볼 예정이다.

## boolean으로 변환

간단한 방법으로는 변환하고 싶은 값의 앞에 `!!`를 붙여주면 된다.

```js
// true 반환
!!true
!!1
!!'howdy'
!![]
!!{}

// false 반환
!!false
!!0
!!''
!!undefined
!!null
```

빈 배열이나 빈 객체가 false를 반환한다고 생각할 수 있지만, true를 반환한다는 점을 주의해야 한다.

### Boolean()

숫자 `0`, 빈 문자열(`''`), `null`, `undefined`, `NaN`은 false를 반환하고, 이 외의 값은 모두 true를 반환한다.

```js
// true 리턴
Boolean(1)
Boolean('howdy')
Boolean(' ')
Boolean(Number.MAX_SAFE_INTEGER)

// false 리턴
Boolean(0)
Boolean('')
Boolean(null)
Boolean(undefined)
Boolean(NaN)
```



**참고**



- MDN


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/bookmark/web-xr</guid>
      <title>WebXR</title>
      <link>https://www.howdy-mj.me/bookmark/web-xr</link>
      undefined
      <pubDate>Sun, 20 Feb 2022 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>bookmark</category>
      <content:encoded>
 -->

WebXR 관련 북마크 모음

## Open source

- WebGL API
- WebXR Device API
- three.js
- Babylon.js
- A-Frame

## 관련 자료

### OpenGL / WebGL / GLSL

- Learn OpenGL
  - Coordinate Systems
- The Book of Shaders (한글 有)
- WebGL 기초
- GLSL Noise Algorithms (gist)

### Three.js

- RENDERING IMMERSIVE WEB EXPERIENCES WITH THREE.JS AND WEBXR (2019.02.19)
- Three.js와 WebXR 몰입형 웹 경험의 랜더링 (2021.10.27)

### WebXR

- WebXR Device API를 이용한 웹 AR 구현, 그 한계와 대안 - 이론 편 (2020.10.16)
- WebXR Device API를 이용한 웹 AR 구현, 그 한계와 대안 - 실전 편 (2020.11.30)
- #2 윤석찬 / Mozilla Hubs를 통한 WebXR (가상현실) 구현하기 (2020.10.14, 영상)

## Examples

- WebXR Sample Pages

 -->
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/react/memoization</guid>
      <title>React의 Memoization</title>
      <link>https://www.howdy-mj.me/react/memoization</link>
      undefined
      <pubDate>Mon, 14 Feb 2022 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>react</category>
      <content:encoded>
위키피디아에 따르면, 메모이제이션(memoization)은 컴퓨터가 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로서 동일한 계산을 하지 않도록 하여, 속도를 높이는 기술이다. 보통 애플리케이션의 최적화를 위해 사용된다.



React에서 컴포넌트가 렌더링하는 규칙에는 크게 세 가지가 존재한다.

1. state나 props가 변경되었을 때
2. `forceUpdate()`를 실행했을 때
3. 부모 컴포넌트가 렌더링 되었을 때

애플리케이션의 규모가 커지면서 리렌더가 점점 더 잦아진다면 이는 서비스 사용에 불편을 초래할 것이다. 따라서 리렌더가 일어나지 않도록 최적화해주는 것이 중요하다.

React에서 메모이제이션을 하는 대표적인 방법으로는 `useCallback`, `useMemo`, `React.memo`가 있다.



### useCallback

```js
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```

useCallback은 메모이제이션 된 콜백을 반환한다.

컴포넌트 내부에 있는 위치해있는 컴포넌트가 렌더링 될 때마다 다시 함수를 생성한다. 하지만 useCallback으로 감싸주게 되면 첫 렌더할 때에만 생성하고 그 이후에는 함수를 기억하고 있어 재생성하지 않는다.

dependency 배열에는 어떠한 값이 변경되었을 때 다시 생성해준다는 뜻으로 새로운 값으로 함수를 실행해야 한다면 반드시 그 값을 해당 의존성 배열에 넣어줘야 한다.

### useMemo

```js
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

useMemo는 메모이제이션 된 값을 반환한다.

렌더링하는 과정에서 특정 값이 바뀌었을 때만 계산을 실행하고, 원하는 값이 바뀌지 않았다면 이전에 계산한 그 값을 그대로 사용한다. useCallback과 마찬가지로 dependency 배열에 값을 넘긴다.

### React.memo

```js
// 방법 1
const Result = React.memo(() => {
  return ()
})

// 방법 2
export default React.memo(Result)
```

`React.memo`는 컴포넌트를 감싸서 사용하며, 들어온 props의 값이 바뀌었다면 해당 컴포넌트의 렌더를 발생시킨다. 따라서 props만 받는 자식 컴포넌트에서 사용하는 것을 권장한다.

Class 컴포넌트에는 `PureComponent`가 존재하며, `React.memo`와는 달리 props와 state의 얕은 비교를 하는 `shouldComponentUpdate`와 비슷하다. `PureComponent`는 하위 컴포넌트에 대한 props를 갱신하지 않기 때문에, 반드시 자식 컴포넌트들이 순수한지 확인해야 한다.

## 간단한 코드로 보는 사용 예시

1시간 안에 끝내야 할 todo 리스트를 만드는 앱이며, 코드는 아래와 같다.

App.tsx

```tsx
import { useState, useMemo } from 'react';
import Title from './components/Title';
import { getAvgPerHour } from './utils/index';

const App = () => {
  const [list, setList] = useState([]);
  const [todo, setTodo] = useState('');

  const onChange = (e: React.ChangeEvent) => {
    setTodo(e.target.value);
  };

  const onSubmit = (e: React.ChangeEvent) => {
    e.preventDefault();
    setList([...list, todo]);
    setTodo('');
  };

  const avgPerHour = getAvgPerHour(list);

  return (
    <>
      
      
        
          
        

        
          {list.map((value, index) => (
            {value}
          ))}
        
        하나당 최대 걸려야할 시간: {avgPerHour}분
      
    
  );
};

export default App;
```

components/Title.tsx

```tsx {8}
import React from 'react';

interface TitleI {
  title: String;
}

const Title = ({ title }: TitleI) => {
  console.log('Title 렌더');
  return {title};
};

export default React.memo(Title);
```

utils/index.ts

```ts {2}
export const getAvgPerHour = (totalList: string[]) => {
  console.log('getAvgPerHour 함수');
  if (totalList.length === 0) {
    return 0;
  }
  return 60 / totalList.length;
};
```


  
  만들어진 화면


가장 큰 문제점은, input에 값을 입력할 때마다, `getAvgPerHour()`와 Title 컴포넌트에서 console이 찍히다는 것이다.

input에 값을 입력할 때에는 list의 값이 변경되지 않고, Title은 변하지 않기 때문에 불필요한 렌더가 일어나고 있는 것이다.

따라서, avgPerHour는 `useMemo`로 감싸주어 이전에 기억하고 있던 값과 다르지 않다면 그 값을 재사용하는 것으로 바꾸고, Title은 props로 들어오는 값이 달라지지 않는다면 렌더를 하지 않도록 `React.memo`로 감싸주면 된다.

App.tsx

```tsx {1}
const avgPerHour = useMemo(() => getAvgPerHour(list), [list]);
```

components/Title.tsx

```tsx {6}
const Title = ({ title, obj }: TitleI) => {
  console.log('Title 렌더');
  return {title};
};

export default React.memo(Title);
```

이렇게 하면 input에 값을 입력해도 console이 찍히지 않는다.

그렇다면 `useCallback`은 언제 사용할까? 이건 함수의 재생성을 막아주는 것이기 때문에 console로는 바로 확인이 어렵다.

App.tsx

```tsx {1,3}
const onChange = useCallback((e: React.ChangeEvent) => {
  setTodo(e.target.value);
}, []);
```

`useCallback`은 컴포넌트가 리렌더 될 때 함수의 재생성을 막아주는 역할을 한다. 위와 같이 `useCallback`으로 감싸준다면 첫 렌더할 때만 생성하고, 이후에는 저장된 값을 그대로 가져와서 사용한다.



하지만 모든 곳에서 `useCallback`, `useMemo`를 사용하면 메모리 성능상 좋지 않을 수 있다. 그렇다면 이것들은 언제 적용해야 할까?

## dependency 배열의 참조 타입 처리 (참조동일성)

위에서 dependency 배열에 넘기는 값은 모두 원시 타입일 경우이다.

React는 얕은 비교를 하기 때문에 원시 타입은 판단 가능하지만, 참조 타입은 렌더가 될 때마다 참조 메모리 주소가 달라진다. 따라서 우리가 보기에는 같은 값이더라도, React는 다른 값으로 인지하여 렌더를 일으킨다.

App.tsx

```tsx {6}
const App = () => {
  const person = { name: 'kmj' };

  return (
    <>
      
    
  );
};
```

components/Title.tsx

```tsx {11}
import React, { useEffect, useRef } from 'react';

interface TitleI {
  title: String;
  person: {
    name: string;
  };
}

const Title = ({ title, person }: TitleI) => {
  console.log('Title 렌더'); // 렌더될때마다 console에 찍힘
  return (
    <>
      {title}
      작성자: {person.name}
    
  );
};

export default React.memo(Title);
```

만약 이처럼 Title 컴포넌트에 person이라는 참조 타입을 넘기게 된다면, 아무리 `React.memo`로 감싸고 있더라도 React는 다른 값으로 인식하여 계속 console이 찍히는 것을 볼 수 있다. 때문에 넘겨줄 때, `useMemo`를 통해 person의 이전 값을 기억해두면 된다.

App.tsx

```tsx {1}
const person = useMemo(() => {
  return { name: 'kmj' };
}, []);
```

이는 useMemo, useCallback, useEffect 그리고 모든 커스텀 훅에도 해동되는 내용이다.



**참고**



- [Hooks API Reference | React](https://ko.reactjs.org/docs/hooks-reference.html)
- [성능 최적화 | React](https://ko.reactjs.org/docs/optimizing-performance.html)
- [When to useMemo and useCallback | Kent C.Dodds](https://kentcdodds.com/blog/usememo-and-usecallback)


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/javascript/asynchronous-programming</guid>
      <title>자바스크립트의 비동기 프로그래밍</title>
      <link>https://www.howdy-mj.me/javascript/asynchronous-programming</link>
      undefined
      <pubDate>Mon, 31 Jan 2022 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>javascript</category>
      <content:encoded>
최근 들어 자바스크립트에서 비동기를 잘 다루는게 얼마나 중요한지 더 절실하게 느낀다. 필자가 마주한 대부분의 골치 아픈 에러는 비동기로 인한 것이며, 왜 이때 실행되는지 혹은 왜 이렇게 늦게 실행되는지 등 원인 파악이 어려워 늘 애를 먹는다.

개발 공부를 막 시작했을 무렵 Node.js란?과 자바스크립트 비동기 함수 알아보기 글을 작성했었다. 당시에 내가 이해한 만큼만 썼다보니 겉핥기 식의 글로 무척이나 부끄럽지만, 공부했던 기록이니 삭제보다는 새로 작성해보려 한다.



### 싱글스레드인 자바스크립트의 비동기가 가능한 이유

사람은 혼자서 앞과 뒤를 동시에 볼 수 없고, 공부를 하면서 잠을 자는 등의 업무를 동시에 진행할 수 없다.

자바스크립트 역시 싱글 스레드로 한 번에 하나의 코드만 실행시킬 수 있다. 따라서 애니메이션이 지속됨과 동시에 상품 상세페이지로 이동하기 위한 클릭 등의 작업이 불가하다. 하지만 이 글을 읽는 사람 모두가 알듯이, 브라우저에서 이와 같은 업무가 가능하다. 왜 그럴까?


    용어: 스레드(Thread)
    
        스레드는 어떠한 프로그램이 실행되는 작업을 말한다.
        싱글 스레드는 한 번에 하나의 작업만 수행할 수 있으며, 멀티 스레드는 한 번에 여러 개의 작업을 수행할 수 있다.
    


이는 '이벤트 루프(Event Loop)' 덕분이다.

## 이벤트 루프


  
  출처: https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5


그림에서도 알 수 있듯이 이벤트 루프는 자바스크립트가 아닌 브라우저에 내장되어 있는 기능 중 하나다. 즉, 자바스크립트는 싱글 스레드이지만 브라우저에서는 이벤트 루프 덕분에 비동기 작업을 비블로킹 방식으로 처리하고, 이를 통해 동시성을 구현하여 마치 멀티스레딩처럼 느껴지게 한다.

  
    용어: Memory Heap(메모리 힙), Call Stack(콜 스택)
    
        메모리 힙: 메모리 할당이 일어나는 곳
        콜 스택: 힙에 저장된 객체를 참조하여, 호출 된 코드(함수)의 정보를 저장하고 실행하는 곳
        더 자세한 내용은 추후 실행 컨텍스트 글에서 다뤄보겠다.
    
  

하지만 만약 콜 스택에 `while(true)`나 React `useEffect()`의 두 번째 인자를 작성하지 않아 무한 호출되는 함수가 존재한다면, 콜 스택이 감당할 수 있는 범위를 초과하면 브라우저의 동작이 멈춰버리니 주의해야 한다.

이벤트 루프는 실행 할 함수를 관리하는 역할로 콜 스택과 큐(Queue)의 함수를 계속 확인한다. 만약 콜 스택이 비어 있고 큐에 대기 중인 함수가 있다면, 순차적으로 큐에 대기중인 함수를 콜 스택으로 이동시킨다. 그리고 이렇게 반복되는 매 순회(Iteration)을 tick이라 부른다.

```js
console.log('Hi');
setTimeout(function cb1() {
  console.log('cb1');
}, 5000);
console.log('Bye');
```

위의 함수를 실행한 순서는 아래와 같다.


  
  https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5


예상한 것과 달리, 콜 스택에서 바로 큐로 넘어가는게 아니라 중간에 Web APIs를 한 번 거쳐 큐로 넘어간다. 이는 어떤 함수나 이벤트가 종료될 때까지 시간이 오래 걸릴 수 있기 때문에, 자바스크립트 엔진이 직접 처리하는 것이 아니라 브라우저에 위임한다. 위 예제에서는 `setTimeout()` 함수가 5초 뒤에 실행되기 때문에, Web APIs가 해당 연산을 마치고(5초 후) 콜 스택에서 바로 실행될 수 있는 상태가 되었을 때 큐에 등록한다.

## 큐 (Queue)

큐는 먼저 들어간 데이터가 먼저 나오는 특징(FIFO, First In First Out)을 갖고 있다.


  
  https://garychang.gitbook.io/data-structure/lecture1-stack-and-queue/lecture1.2-queue-lie



    용어: 스택(Stack)
    
      스택은 나중에 들어간 데이터가 먼저 나오는 특징(LIFO, Last In First Out)의 특징을 갖고 있다.
      
       
        https://garychang.gitbook.io/data-structure/lecture1-stack-and-queue/lecture1.1-stack-dui
      
      그래서 위에 콜 스택은 나중에 들어간 데이터가 먼저 빠지고, 큐는 우->좌로 실행된다.
    




큐는 크게 태스크 큐(Task Queue), 마이크로 태스크 큐(Micro Task Queue)로 나뉜다.




  
    태스크 큐(Task Queue): `setTimeout()`, `setInterval()`과 같은 비동기 함수의 콜백 함수 또는 DOM 이벤트(ex. 클릭) 핸들러가 대기하는 곳이다.
  
  
    마이크로 태스크 큐(Micro Task Queue): `Promise()`의 후속 처리 메서드의 콜백 함수나 `queueMicrotask()`, `MutationObserver()`가 대기하는 곳이다.
  




### 우선 순위

각 큐에 대한 실행 우선 순위는 **마이크로 태스크 큐 > 태스트 큐** 순서이다. 이벤트 루프는 해당 순서대로 대기하고 있는 함수들을 보고 있다가 차례대로 콜 스택에 가져와 실행한다.

```js
console.log('처음');

setTimeout(() => {
  console.log('setTimeout - 태스크 큐');
}, 0);

Promise.resolve()
  .then(() => {
    console.log('promise1 - 마이크로 태스크 큐');
  })
  .then(() => {
    console.log('promise2 - 마이크로 태스크 큐');
  });

console.log('마지막');
```

```txt
처음
마지막
promise1 - 마이크로 태스크 큐
promise2 - 마이크로 태스크 큐
setTimeout - 태스크 큐
```



#### 만약 긴급하게 실행해야 하는 함수가 존재한다면?

태스크 큐보다 먼저 실행해야하는 함수가 존재한다면, `queueMicrotask()`로 우선 순위를 끌어올릴 수 있다.

```js
const callback = () => console.log('일반 콜백 함수 호출');
const urgentCallback = () => console.log('---> 긴급 콜백 함수 호출');

console.log('시작');
setTimeout(callback, 0);
queueMicrotask(urgentCallback);
console.log('종료');
```

```
시작
종료
---> 긴급 콜백 함수 호출
일반 콜백 함수 호출
```





### setTimeout(setInterval)의 문제

먼저 알아야 할 점은, 대부분의 브라우저는 W3C 권장사항에 따라 디스플레이 주사율과 일치한 횟수로 콜백 함수를 호출한다. 그래서 보통 60FPS로 화면을 렌더링하고, 이는 콜백의 수가 보통 1초에 60회, 16ms(0.016초)에 하나씩 실행된다.


  
  https://namu.wiki/w/FPS



    용어: FPS(Frames Per Second), 프레임
    
      FPS는 초당 프레임을 말한다.
      동영상은 정지된 사진의 연속으로도 볼 수 있는데, 이처럼 각각의 정지된 사진을 '프레임'이라 부른다. 그리고 이러한 사진이 1초에 몇 장 보이는지를 일컬어 프레임률이라 하며 단위는 'fps' 혹은 'Hz'를 쓴다.
      일반적인 모니터가 초당 60번의 갱신 주기(Hz)를 갖고 있기 때문에 W3C에서도 60FPS를 권장한게 아닌가 생각한다.
    


`requestAnimationFrame()`이 등장하기 전에는 웹 애니메이션을 구현하기 위해 주로 `setTimeout()`이나 `setInterval()`을 사용했다. 유저가 애니메이션을 부드럽게 느끼려면, 함수 실행이 프레임마다 끊기지 않고 연이어 이루어져야 했다. 따라서 이 함수들을 중헙해서 반복적으로 사용해서 마치 연속적인 움직임을 보이게 만들었다.

그러나 `setTimeout()`과 `setInterval()` 모두 엄밀히 말해 '시간 기반'으로 작동하는 함수라기보다는, 지정된 **최소 지연 시간** 이후에 콜백 함수를 실행하는 예약 함수다. 즉, 앞의 콜백 함수가 종료된 후에 다음 실행을 대기하는 방식이다. 게다가 만약 컴퓨터 성능이 안 좋거나, 다른 무거운 작업이 있다면, 프레임(16ms) 시작 시점에 함수 실행이 늦어질 수 있다. 이렇게 되면 화면과 애니메이션 싱크가 맞지 않아 애니메이션이 끊겨 보이는 현상(ex. 위 gif의 15FPS)이 일어난다.


  
  https://web.dev/optimize-javascript-execution/


이러한 문제를 해결하기 위해 requestAnimationFrame()이 등장했다. 이는 브라우저 렌더링 주기와 동기되어 작동하는 함수이다. 콜백을 실행하는 시점에 `DOMHighResTimeStamp`를 전달받아, 실제 브라우저의 **다음 리페인트 직전**에 실행을 보장한다.

브라우저는 `requestAnimationFrame()` 콜백을 실행하기 가장 좋은 시점을 스스로 판단한다. 만약 탭이 비활성화되면 실행을 일시 중지하여 불필요한 리소스 낭비를 줄이거나, CPU, 배터리 소모를 최적화할 수 있다. 이러한 특성 덕분에 `setTimeout()`, `setInterval()` 대신 `requestAnimationFrame()` 사용이 훨씬 좋다.

## 비동기 프로그래밍(Asynchronous Programming)

비동기 처리는 현재 실행중인 것이 완료되지 않더라도 다음 코드를 실행하는 방식을 말한다.

동시에 여러 작업을 수행할 수 있다는 큰 장점이 있지만, 비동기 함수가 많을 경우 어떤 코드가 먼저 실행되는지 알 수 없고 가독성이 나쁘다는 평을 들어왔다. 이런 문제를 해결하기 위해 여러 비동기 프로그래밍 방법이 생겼고 크게 `콜백(Callback) 함수`, `Promise`, `async/await` 패턴이 존재한다.

해당 글에서는 각각의 패턴이 어떤 형태이며, 어떤 문제점이 존재하는지 등에 대해 간단히 다루고 다른 글에서 사용법에 대해 자세히 다뤄보겠다.

### 콜백(Callback) 함수

콜백은 다른 함수의 인자로 함수를 넘기는 것을 말한다. 콜백 함수로 비동기 프로그래밍을 짤 수 있지만, 모든 콜백 함수가 비동기이진 않다. 예를 들어 `map()`, `filter()`의 첫 번째 인자로 들어가는 콜백 함수는 동기식으로 호출된다.

```js {20}
// 해당 코드는 [자바스크립트 Deep Dive, 이웅모 (2020)]의 프로미스(p842)에서 가져왔습니다.

const POSTS_URL = 'https://jsonplaceholder.typicode.com/posts';

const getPosts = (url) => {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.send();

  xhr.onload = () => {
    if (xhr.status === 200) {
      console.log(JSON.parse(xhr.response));
    } else {
      console.error(`${xhr.status} ${xhr.statusText}`);
    }
  };
};

const posts = getPosts(POSTS_URL);
console.log('posts: ', posts);
```

여기서 post를 console로 찍었을 때 어떤 결과가 나올까?

`xhr.onload()`가 비동기로 동작하기 때문에 post는 undefined라는 결과를 반환한다. 이렇듯 비동기로 동작하는 함수는 외부에서 그 값을 바로 참조하지 못하여, 무조건 콜백 함수 내부에서 그 처리를 진행해야 한다.

```js
const getPosts = (url, whenSuccess, whenFail) => {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.send();

  xhr.onload = () => {
    if (xhr.status === 200) {
      whenSuccess(JSON.parse(xhr.response));
    } else {
      whenFail(xhr.status, xhr.statusText);
    }
  };
};

const handlePosts = (response) => {
  // ...
};

const errorHandling = (status, statusText) => {
  // ...
};

const posts = getPosts(POSTS_URL, handlePosts, errorHandling);
```

따라서 콜백의 후속 처리를 모두 그 콜백 함수 내에서 처리해야 하기 때문에, 위처럼 다시 콜백함수를 넘기는 수 밖에 없게 되었다.

그런데 만약 해당 콜백 함수에 또 예외 처리를 해야 하거나, 여러 에러 상황에 각기 다른 조치를 취해야 한다면 어떻게 해야할까? 끔찍하게도 이것 역시 또 다른 콜백함수로 넘겨야 한다. 그리고 이런 상황이 곧 '콜백 헬(callback hell)'이라는 단어로 불러졌다.

### Promise

Promise도 콜백 헬을 해결할 수 없었지만, 비동기 함수의 후속 처리가 콜백 함수에 비해 다루기 훨씬 쉬워졌다.

```js {19}
const getPostsWithPromise = (url) => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();

    xhr.open('GET', url);
    xhr.send();

    xhr.onload = () => {
      if (xhr.status === 200) {
        resolve(JSON.parse(xhr.response));
      } else {
        reject(xhr.status, xhr.statusText);
      }
    };
  });
};

const posts = getPostsWithPromise(POSTS_URL);
console.log('posts: ', posts); // Promise {}
```

콜백 함수와 달리 post를 console로 찍어보면 Promise {\}이란 값이 나온다. 비동기 함수가 수행되기 전이기 때문에 resolve나 reject가 아닌 pending이 반환된 것이다.

```js
posts
  .then((res) => console.log(res))
  .catch((err) => console.error(err))
  .finally(() => console.log('끝'));
```

그리고 Promise로 생성된 posts는 각각 then, catch, finally로 후속 처리가 가능하다.

fetch() 함수가 바로 Promise 기반으로 만들어진 HTTP 요청 전송 기능인 클라이언트 사이드 Web API다. 쓰임새도 Promise와 매우 유사하다.

```js
fetch(POSTS_URL)
  .then((res) => console.log(res))
  .catch((err) => console.error(err))
  .finally(() => console.log('끝'));
```

Promise는 비동기 함수 처리를 쉽게 할 수 있다는 것 외에도, 여러 비동기 처리를 병렬 처리할 때 사용하는 `Promise.all()`, 여러 비동기 처리를 다룰 때 가장 먼저 fulfilled된 처리 결과를 반환하는 `Promise.race()` 등 일반 콜백 함수로 다루는 것보다 보다 더 다양한 작업이 가능하다.

### async/await

그러나 Promise는 여전히 콜백 함수를 사용하기 때문에, 콜백 헬의 문제를 해결할 수 없었다. ES6에 제너레이터가 도입되어 비동기를 동기처럼 구현했지만, 코드가 장황해지고 가독성이 나빠졌다. 이에 뒤따라 ES8에서 보다 간단하고 가독성 좋게 비동기 처리를 동기 처리처럼 구현하는 async/await가 도입되었다.

async/await는 Promise를 기반으로 동작하며, then/catch/finally와 같은 후속 처리 메서드 없이 마치 동기 처리처럼 사용할 수 있다.

```js
const getPostWithAsync = async (url) => {
  try {
    const response = await fetch(url);
    return await response.json(); // 혹은 다른 형태로 데이터 전처리 가능
  } catch (err) {
    console.err(err);
  } finally {
    console.log('끝');
  }
};

const posts = getPostWithAsync(POSTS_URL);
console.log('posts: ', posts);

posts.then(console.log);
```

콜백 함수나 Promise는 무조건 api를 호출한 후, 또 다른 콜백 함수를 실행하여 데이터의 처리가 가능했지만, async/await는 해당 함수 내부에서 바로 동기 처리처럼 데이터를 수정할 수 있다. 또한 try/catch 문으로 에러 처리도 훨씬 수월하다. _(추후 콜백 함수나 Promise에서는 try/catch 문이 어려운지 작성해보겠다)_



_추후 추가할 내용_

- 콜백함수, Promise, async/await에서의 try/catch 문



**참고**



- 비동기 프로그래밍 | JavaScript로 만나는 세상
- How JavaScript works: an overview of the engine, the runtime, and the call stack
- How JavaScript works: Event loop and the rise of Async programming + 5 ways to better coding with async/await
- Tasks, microtasks, queues and schedules
- JavaScript의 queueMicrotask()와 함께 마이크로태스크 사용하기
- 모던 자바스크립트 Deep Dive, 이웅모 (2020)
- JavaScript Visualized: Promises & Async/Await
- window.requestAnimationFrame() | MDN
- Why is requestAnimationFrame better than setInterval or setTimeout | StackOverFlow
- 자바스크립트 실행 최적화 | Google Developers
- Timing control for script-based animations | W3C


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/javascript/debounce-and-throttle</guid>
      <title>Debounce와 Throttle</title>
      <link>https://www.howdy-mj.me/javascript/debounce-and-throttle</link>
      undefined
      <pubDate>Tue, 25 Jan 2022 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>javascript</category>
      <content:encoded>
디바운스(Debounce)와 쓰로틀(Throttle)은 예전부터 들어왔지만, 실무에서는 직접 구현하기 보다 lodash를 사용했기 때문에 정확히 어떻게 동작 되는지 몰랐다.

해당 글에서는 간단하게 `useDebounce`와 `useThrottle` hooks를 만들어서 설명해보려 한다.

## 언제 사용하는가?

debounce와 throttle 모두 특정 함수의 호출 횟수를 줄여서, 웹 성능이 저하 되는 것을 방지하기 위해 사용된다.

예를 들어, 브라우저 크기 조절이나 지도에서 마커가 이동 중에는 주소가 변경되지 않는 것, 입력 창에 어떤 제품을 입력하고 몇 초 지나서 하단에 추천 검색어가 뜨는 것, 여러 번 클릭했음에도 한 번만 실행되는 것 등, 모두 어느 정도의 텀을 두고 유저에게 보여진다. 이처럼 주로 api 호출이나 DOM 이벤트의 실행을 줄일 때 사용된다.



필자가 생각한 '간단한' 정의는 아래와 같으며, 아래 hooks 예시를 통해 자세히 알아보자.

- **debounce**: 일정 시간 이후에 함수를 호출한다.

- **throttle**: 일정 시간마다 함수를 호출한다.

_(아래 예시에서 일정 시간은 모두 1초다)_



### useDebounce



위 예시처럼, input에 입력한 text는 바로 바뀌지만, debounceText는 입력한 후에 일정 시간 이후에 바뀌는 것을 볼 수 있다.

useDebounce.ts

```ts
import { useEffect, useState } from 'react'

const useDebounce = (value: string, time: number) => {
  const [debouncedValue, setDebouncedValue] = useState(value)
  useEffect(() => {
    const timerId = setTimeout(() => {
      // 일정 시간 이후에 변경한다
      // 변경 사항이 생긴다면, 그로부터 time을 다시 센다
      return setDebouncedValue(value)
    }, time)
    // 기능 수행을 완료하면 구독을 해제한다
    return () => clearTimeout(timerId)
  }, [value, time])

  // 변경된 값을 return
  return debouncedValue
}

export default useDebounce
```

App.tsx

```ts
const debouncedText = useDebounce(text, 1000)
```

`useDebounce`는 변경된 값을 return하기 때문에 변수에 할당해서 사용할 수 있다. 여기서 주의할 점은, **text에 변경사항이 생긴다면 그로부터 일정 시간이 지나야 함수를 호출한다**는 점이다.

### useThrottle



그에 반해, throttle은 일정 시간마다 함수를 호출한다.

useThrottle.ts

```ts
import { useEffect, useState } from 'react'

const useThrottle = (callbackFunc: () => void, time: number): any => {
  const [isWaiting, setIsWaiting] = useState(false)

  useEffect(() => {
    if (!isWaiting) {
      callbackFunc()
      setIsWaiting(true) // 함수가 호출되자마자 true로 바꾸어 호출 중단

      setTimeout(() => {
        // 특정 시간 이후에 false로 바꾸어 재호출
        setIsWaiting(false)
      }, time)
    }
  }, [callbackFunc, isWaiting, time])
}

export default useThrottle
```

형태도 useEffect와 비슷하다.

App.tsx

```ts
useEffect(() => {
  const interval = setInterval(() => setCount(count => count + 1), 100)
  return () => clearInterval(interval)
}, [])

useThrottle(() => {
  setThrottledCount(throttledCount + 1)
}, 1000)
```

debounce와 달리 연속적으로 api를 호출(ex. 추천검색어, 무한스크롤)이 필요할 때 일정 시간마다 호출하여 실행한다.

`useThrottle`은 최소한의 스펙을 구현하기 위해 작성한 것으로 추후 무한스크롤 관련 글 작성할 때 더 다뤄볼 예정이다.

## 문제점

debounce와 throttle 모두 `setTimeout`이라는 Web API에 의해 실행된다. 그러나 `setTimeout`, `setInterval`은 정확한 지연시간을 보장해주지 않는다. 실제로 `useThrottle` 예제를 몇 번 새로고침하다보면 count와 throttleCount의 숫자가 불규칙하게 변하는 것을 확인할 수 있다. 때문에 정교한 작업의 개발이 필요하다면 다른 방법을 찾아봐야 한다.



**참고**



- The Difference Between Throttling and Debouncing
- Throttle 와 Debounce 개념 정리하기
- 디바운스(Debounce)와 스로틀(Throttle ) 그리고 차이점


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/javascript/observer-pattern</guid>
      <title>Observer 패턴 알아보기 (hooks와 observables)</title>
      <link>https://www.howdy-mj.me/javascript/observer-pattern</link>
      undefined
      <pubDate>Wed, 05 Jan 2022 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>javascript</category>
      <content:encoded>
현 회사의 메인 프로젝트가 Angular로 개발되어 있다보니 자연스럽게 RxJS를 접하게 되었다.

그러나 Observable이 어떻게 그 객체의 변화를 감지하는지 모른채 사용했다. 그래서 조금이나마 이해하기 위해 Observer 패턴에 대해 찾아봤다.

## GoF 디자인 패턴이란?

간략하게 ‘패턴’이란 무엇인지 알아보자. 개발자라면 이게 무엇인지는 몰라도 한 번 쯤 **GoF 디자인 패턴**을 들어봤을 것이다.


  용어: GoF, 디자인 패턴
  
    GoF는 Gang of Four의 약자로 네 명의 개발자(Erich Gamma, Richard Helm, Ralph Johnson, John Vissides)를 뜻한다.
    디자인패턴은 공통적으로 발생하는 문제에 대한 표준적인 해결책, 일종의 템플릿이다.
  


GoF 디자인 패턴은 객체지향을 기반으로 23개의 디자인 패턴을 연구하여 정의한 것이다. 이는 크게 세 가지 영역으로 나뉘는데, **생성 패턴(Creational Patterns)**, **구조 패턴(Structural Patterns)** 그리고 **행동 패턴(Behavioral Patterns)**이 있다.



해당 글에서 다뤄볼 내용은 Observer 패턴은 행동 패턴에 속한다. 행동 패턴은 GoF 패턴의 가장 큰 부분으로 객체가 데이터를 공유하는 방법 혹은 객체 사이에서 데이터를 교환하는 방법에 대한 가이드를 제공한다.

그 중, Observer 패턴은 객체의 상태를 관찰하여, 객체 값의 변화를 감지할 때 사용된다. 하지만 이것만으로는 어떤 얘기인지 잘 와닿지 않는다. 해당 글에서는 `MutationObserver`로 간단하게 알아볼 예정인데, 그 외 MDN애 존재하는 웹 Observer API는 아래와 같다.

- Intersection Observer API: 타겟 요소와 상위 요소 혹은 document의 뷰포트 사이의 intersection(\*의역: 거리) 변화 감지
- MutationObserver: DOM 객체 변경 감지
- Resize Observer API: 객체의 크기(width, height) 변화 감지
- ReportingObserver: 웹 플랫폼의 기능 혹은 버그 관련 정책 등을 감지
- PerformanceObserver: 브라우저의 퍼포먼스 감지

## MutationObserver



Observer 아래의 `Start`와 `Disconnect` 버튼으로 객체(_여기서는 박스_)를 관찰할지 말지를 결정할 수 있으며, Target 박스 아래의 버튼으로 박스의 속성을 변경할 수 있다. 로직은 아래와 같다.

```js
// observe할 대상 node, 해당 예시에서는 박스
const target = document.getElementById('target')

// observe 설정 (MutationObserverInit)
const config = { attributes: true, childList: true }

// observer 생성
const observer = new MutationObserver(mutations => {
  console.log('mutations', mutations)
})

// observe 대상 및 설정 전달
document.querySelector('.start').addEventListener('click', () => {
  console.log('Start Observe')
  observer.observe(target, config)
})

// observe 중지
document.getElementById('disconnect').addEventListener('click', () => {
  console.log('Disconnect Observer')
  observer.disconnect()
})

document.getElementById('attributes').addEventListener('click', () => {
  target.setAttribute('class', 'red')
})

document.getElementById('childList').addEventListener('click', () => {
  target.textContent = '변경'
})

document.getElementById('reset').addEventListener('click', () => {
  target.removeAttribute('class', 'red')
  target.textContent = ''
})
```

1. **설정(MutationObserverInit)**

  - 가장 많이 사용되는 값은 아래와 같다.

   ```ts
   const config: MutationObserverInit = {
     childList, // node의 자식 요소가 추가/삭제를 감지
     attributes, // 타겟의 속성 감지
     characterData, // 타겟의 데이터(ex. text node) 감지
     // ...생략
   }
   ```

  - 최소한 `childList`, `attributes` 혹은 `characterData`를 true로 설정해야 한다.
  - 더 자세한 내용은 MDN - MutationObserverInit에서 볼 수 있다.

2. **observe(target, config)**
  - observer에게 감지할 대상 node와 어떤 변화를 감지할 것인지에 대한 설정을 알려준다.
3. **mutations**
  - `new MutationObserver()` 생성자의 콜백 함수는 DOM의 변화를 나타내는 MutationRecord 값이 배열로 넘겨진다.
  - 해당 글에서는 어떤 type이 변경되었는지만 다룰 예정이며, 자세한 내용은 MDN - MutationRecord에서 볼 수 있다.

### 문제점

위와 같이 하나의 이벤트에 하나의 변화만 있다면 문제될 건 없다. 하지만 어떠한 이벤트로 인해 바로 다른 객체가 변한다면 예기치 못한 사이드 이펙트가 일어날 수 있다.

위의 코드에서, `Make Red` 버튼을 누르면 박스에 trigger라는 글자가 생기도록하는 로직만 추가했다.

```js
const observer = new MutationObserver(mutations => {
  console.log('mutations', mutations)

  const currentAction = mutations[0] // 들어오는 변화의 첫 번째 것만 감지
  // 해당 코드에서 Make Red만 attributes이기 때문에 이렇게 작성했다
  if (currentAction.type === 'attributes') {
    target.textContent = 'trigger'
  }
})
```



Start 버튼을 눌러서 관찰을 시작한 후, `Make Red` 버튼을 누르면 박스가 빨간색으로 변화함과 동시에 trigger라는 글자가 생긴다. 그리고 이를 Reset하여 없앤다면, 박스는 흰색으로 돌아가지만 trigger라는 글자는 여전히 있다.

console을 보면 왜 이렇게 나오는지 알 수 있는데, 이는 빨간색 속성이 흰색으로 변경됨으로써 다시 attributes에 변화가 생겨서 trigger 문자가 다시 생기는 것이다.

이렇듯 하나의 이벤트에 다른 이벤트를 물고 있다면, 의도치 않은 사이드 이펙트가 일어날 확률이 크다.

따라서 객체에 필요없는 이벤트는 관찰하면 안되고, 우리가 원하는 순서대로 실행이 보장되어야 한다. 그래서 **ReactiveX(Rx)**가 나왔다고 생각된다.

> ReactiveX is a library for composing asynchronous and event-based programs by using observable sequences.
> It extends the observer pattern to support sequences of data and/or events and adds operators that allow you to compose sequences together declaratively...
>
> ReactiveX는 옵저버블 순서를 이용하여 비동기와 이벤트 기반 프로그램을 조합하는 라이브러리다. observer 패턴을 확장하여 데이터 및/또는 이벤트의 순서를 지원하고 선언적으로 순서를 조합할 수 있는 오퍼레이터를 추가해준다.

## React와 RxJS

React도 state의 변화를 감지하고 UI를 업데이트하기 때문에 ‘React가 Reactive의 뜻이지 않을까?’라는 생각을 해 본 적 있다. 하지만 공식문서를 보면 그렇지 않다는 걸 알 수 있었다.

> React, however, sticks to the “pull” approach where computations can be delayed until necessary.
> (중략)
> There is an internal joke in the team that React should have been called “Schedule” because React does not want to be fully “reactive”.

출처: React Design Principles


  용어: pull, push
  
    pull: Function, iterator 등 대부분의 자바스크립트 함수는 모두 pull 방식으로, 받은 값을 리턴하는 방식을 뜻한다.
    push: Promise와 Observalbe처럼 이벤트를 발생시켜 데이터를 변경하는 방식을 뜻한다.
  


React의 `setState()` UI가 바뀌어야만 할 때 사용하는 비동기 메서드로 pull 방식이다. 동시에 React는 glue 코드(\*호환되지 않는 코드를 실행하기 위한 코드)가 되고 싶다고 표명했다. 아마 UI를 렌더링하기 위해 유저들이 최소한의 코드만을 작성하는 것을 뜻하는 것 같다. _(단, 최근 Svelte의 등장으로 React가 어떻게 바뀔 지 모르겠다)_



### hooks와 observables의 차이

그럼에도 불구하고, hooks와 observables의 차이가 잘 와닿지 않았는데, RxJS의 핵심 개발자 Ben Lesh가 트윗에 hooks와 RxJS 차이에 대해 작성한 것이 있어 요약해봤다.

Hooks는 어떤 컴포넌트에 묶여있는 state인 반면, Observables는 독립적으로 존재하는 객체다.

Hooks로도 promises, async iterators, throttling, debouncing 등 비동기 이벤트를 처리할 수 있지만, Observables처럼 여러 개의 비동기 이벤트들을 한 번에 다룰 수 없다.

```jsx
new Observable(() => {
  /*do stuff */
  return () => {
    /* teardown */
  }
})

useEffect(() => {
  /*do stuff */
  return () => {
    /* teardown */
  }
})
```

이 둘은 비슷한 형태의 API를 갖고 있는데, 가장 큰 차이점은 아래와 같다.

Observables은 이벤트 실행이 되기 전까지, state의 값을 변경하지 않는다. 반면, useEffect는 React의 렌더가 될때까지 이벤트의 실행을 미루고, state를 관련되어 있는 컴포넌트에 바인딩한다. 또한, useEffect는 값을 방출하지 않지만, Observables은 변경된 값을 push하여 호출한 구독자에게 알려준다(여기서 사이드 이펙트가 일어날 수 있다).

Observable은 React에 속한 것이 아니기 때문에, 그 값을 자동으로 컴포넌트에 묶을 수 없다. 반면, Hooks는 여러 개의 이벤트를 trigger하여 발동되도록 조작하기 어렵다. 따라서 해당 기능들이 필요한 곳에 적재적소하게 사용할 줄 알아야 한다.



React를 사용 중인데 바로 RxJS 도입에 조금 허들을 느낀다면, LeetCode가 만든 RxJS hooks를 같이 사용해봐도 좋을 것 같다.

## 마치며

RxJS를 사용하고 있었지만 어떻게 변화를 감지하고 있는지는 몰랐다. 시간이 없다는 핑계로 계속 미루다가 이제서야 찾아보았다.

지금은 Angular로 진행중인 프로젝트에서는 당연하게 RxJS를 이용해서 개발해왔는데, 앞으로는 어떤 기능을 개발하기 전에 ‘여기서 RxJS를 사용하는게 맞나?’를 한 번 생각해볼 것 같다.



**참고**



- 자바스크립트 디자인 패턴, 에이콘출판, 2016
- React Hooks vs. RxJS


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/mj-log/2021</guid>
      <title>2021년 회고</title>
      <link>https://www.howdy-mj.me/mj-log/2021</link>
      undefined
      <pubDate>Thu, 30 Dec 2021 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>mj.log</category>
      <content:encoded>
회고를 공개적으로 쓰는 건 처음이라 많이 어색하다. 항상 해야지 해야지 하다가 지금까지 미루어왔다. 아직 문체랑 형식은 정하지 못해서 읽을 때 통일감이 없을 수 있는데, 아마 다른 글보다는 프리하게 하지 않을까 싶다 :)

## 올해 한 일은?

실력은 크게 늘지 않은 채, 2021년이 지나간 것 같아 조급함이 있었다. 그래도 정리해보니 꽤 많은 일을 한 것 같아 나름 뿌듯하다.

### 이직

사실 개발자로 전향하고 회사 운이 좀 없었다. 첫 번째 회사는 3개월, 두 번째 회사는 4개월 정도 다니다 모두 내부적인 이슈로 퇴사를 했고, 3월에 현 회사로 이직했다.

이전에는 주로 혼자 프로젝트를 하다 보니 나도 인지하지 못하는 안 좋은 습관(ex. 나만 알아볼 수 있는 변수명, 순수함수 사용 안 하기, mutable 한 방식 등)이 많이 있었는데, 같이 맞춰가면서 협업하기 좋은 동료가 되기 위해 노력 중이다. 입사 후 팀 내 개발 문화와 회사 복지가 점점 좋아지고 있다. 내년에도 지금처럼 점점 더 좋아지는, 성장하는 팀으로 만들어가고 싶다.

#### 약간 딴길로 새보자면..

사회생활 기간에 비해 여러 회사에서 일해보니, 내가 만족하면서 다닐 수 있는 기준이 어느 정도 세워졌다. 동시에 절대 오래 다니지 못할 기준도 생겼으며, 그 기준은 아래와 같다. (법에 어긋나는 조건은 제외했다)


  
    현재가 아닌 미래만 약속하는 곳
    같이의 가치 보다 실력이 뛰어난 한 명을 더 좋아하는 곳
    코드 품질보다 결과물을 만드는게 더 중요한 곳
    팀 혹은 개인이 주도적으로 일할 수 없는 곳
    다른 사람의 생각이나 의견에 관심이 없는 곳
    경영진 혹은 팀장급이 다른 직원 뒷담화하는 것이 일상인 곳
    보상 없이 열정만 요구하는 곳
    주 업무보다 잡일의 비중이 더 많은 곳
  


놀랍게도 여기에 거의 다 해당하는 회사도 있었다. 물론 회사가 아무리 좋아도, 같이 일하는 사람이 최악이라면.. 음..

#### 약간 딴길로 새보자면2..

팀장님 덕분에 하반기부터 채용에 관여할 수 있게 되었는데, 어렵다. 커뮤니티나 여론에 알려진 _개발자 초봉 XXXX만원, 주 xx시간 근무, 100% 재택근무_ 등 때문인지, 원래도 적었던 지원자가 더 줄어든 것 같다. (사실 나도 가고 싶다...)

전에는 몰랐으나 서류, 면접에 내가 생각했던 것보다 더 많은 시간과 체력이 소모된다. 채용 절차가 도중에 중단되는 상황은 자주 일어나지만, 가장 허무했던 적은 면접 노쇼다. 다른 곳에 합격했다면 서로를 위해 최소한의 연락은 해주자..

합류 후에 신규 입사자분이 팀에 적응을 잘 할 수 있도록 온보딩을 진행해야 하는데, 팀이 바쁠 경우 잘 봐주지 못해서 어떻게 밸런스를 유지해야 할지도 고민이다. 항상 막내였던지라, 누군가를 알려주는 이 상황이 낯설고 잘하고 있는지 계속 생각해보게 된다.



### 모던 자바스크립트 Deep Dive 스터디

작년에 모던 자바스크립트 Deep Dive 책을 사고 한 번 훑긴 했으나 대충 넘긴 부분도 많고, 이해하지 못한 부분도 많았다. 혼자 다시 읽을 엄두가 나지 않았는데 정말 운 좋게, 딱 그 때 해당 서적의 저자인 웅모님이 스터디를 여셨다.

3월 부터 12주 간 매주 수요일에 팀 별로 읽은 부분에 대해서 토론하는 방식으로 진행되었는데, 스터디 중간 웅모님이 들어오셔서 질의응답도 해주셨다.

아는 만큼 얻어갈 수 있는 스터디라는 생각이 들었는데, 역시나 그랬다. 웅모님은 우리가 질문한 모든 것에 자세히 설명해주셨으나, 제대로 소화하지 못하고 있는 내 모습을 보고 올해 다시 정독하기로 목표를 세웠다.

2회 독을 하니 처음 보는 내용도 많았고, '아 그때 이게 이 내용이었구나'라고 깨달은 부분도 많았다. 그리도 스터디를 할 때 작성했던 글들을 대폭 수정하기도 했다. (아직 수정이 필요한 글들도 많다..)

**자바스크립트와 친해지기 프로젝트**는 현재진행중이며 내년에도 2회독을 목표로 하고 있다.



### 글또

글또는 6개월 간 2주에 한 번씩 글을 작성하는 '글 쓰는 개발자 모임'이다. 글또 시작때 다짐했던 '한 번도 패스를 쓰지 않고 모두 작성하자'는 목표는 이루었다. 다만 한 번 깜빡하고 제출 이모지를 누르지 않아 보증금은 다 못받는건 상당히 아쉽다. (이때가 프로젝트 때문에 몇 주 야근하면서 틈틈히 작성했던거라 엄청 뿌듯했었는데ㅠㅠ.. 다음을 노려본다)

글을 쓸 때 항상 '어떻게 하면 내 글을 처음 읽는 사람이 막힘없이 읽을 수 있을까?'를 고민하며 쓰지만, 늘 어렵다. 가끔 무작위로 예전에 썼던 글도 읽어보는데, 왜 이렇게 썼는지 모를 글들이 너무나 많아서 틈틈히 수정중이다.



### 사이드 프로젝트

거창하진 않다. 무지성매매를 하지 않기 위해 차트 공부를 시작했고, 매매일지를 작성해야겠다 생각이 들었다. 그런데 마음에 드는 서비스가 없어서 trading-log를 만들었다.

이때 파이어베이스를 처음 사용해봐서 생소했다. 게다가 초기세팅하고 한동안 안 들어간 동안 파이어베이스 api 스펙이 바뀌어서 당황하기도 했었다. 그리고 간단하게 validation 체크를 위한 라이브러리도 배포해보면서, 오픈소스에 발자국만 남겼다.

사실 아직 진행중인 프로젝트이지만, 배포하지 않으면 영영 못 끝낼 것 같아서 최소한의 스펙만 먼저 배포했다. 시간 날때마다 이것저것 추가해볼 예정이다.

이 외에 팀 프로젝트도 몇 개 해봤지만, 제대로 마무리 한 프로젝트가 없었다. 지금 진행중인 팀 프로젝트도 있는데, 내년에 꼭! 배포했으면 좋겠다.



### 그 외

1. 올해 초부터 꾸준히 필라테스를 다니고 있다. 매달 인바디 수치가 좋아지고 있어서 무척이나 뿌듯하다.

2. 블로그 월 방문자 수가 3월부터 매달 최고치를 갱신하고 있다!:tada: &nbsp;가끔 귀찮아서 대충쓰고 싶다가도, 댓글이나 이메일로 글 잘 보고 있다고 연락이 오면 힘이 나서 열심히 쓰게 된다. (블로그 덕분에 강의도 찍었지만 많이 부끄럽다.. 꾸준히 공부해야겠다고 다짐하게 되는 계기가 되었다)

3. 지금은 Jbee님이 만들어주신 블로그 템플릿을 사용하고 있지만, Next.js로 만들어서 이전하고 싶다. 자꾸만 우선순위에서 밀리고 있지만, 3년 이내에는 만들고 싶다.

4. 원래 올해 목표에 UI 라이브러리 배포가 있었지만 우선순위를 조정하다보니 뒤로 밀렸다. 사실 회사에 계속 Storybook으로 디자인 시스템을 구축하고 싶다고 얘기는 하지만, 개인 욕심이 더 큰지라 쉽지 않다. 개인 UI 라이브러리도 당장 내년은 힘들겠지만 이것도 빠른 시일 내에 배포해보고 싶다.

5. 하고 싶은건 너무 많은데 시간과 체력이 부족하다..ㅠㅠ

## 내년 계획은?

2022년은 내 커리어를 보다 더 단단하게 다져보는 해로 만들고 싶다.

좋은 기회가 왔을 때 바로 잡을 수 있을만큼 실력을 키우고 싶다.

집중적으로 공부하고 싶은건 자바스크립트, 알고리즘, Three.js이며, 올해처럼 나만의 템포를 유지하면서 꾸준히 무언가를 하고 싶다.
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/general/otp</guid>
      <title>OTP 동작원리</title>
      <link>https://www.howdy-mj.me/general/otp</link>
      undefined
      <pubDate>Fri, 17 Dec 2021 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>general</category>
      <content:encoded>

필자가 이해한 내용을 최대한 간단하게 써내려가는 글로, 부족한 부분이나 틀린 내용이 있을 수 있습니다.

피드백은 언제나 환영합니다!





스마트폰이 나오기 전, 어느 사이트에 가입할 때 비밀번호를 까먹을 것을 대비하여 '초등학교 때 가장 기억에 남는 선생님 성함은?', '어렸을 적 키웠던 반려동물 이름은?' 등 유저가 여러 개의 질문 중 하나를 선택하고 답변을 저장했다. 하지만 나중에 내가 어떤 질문을 골랐는지 조차 기억이 나지 않는 참사가 일어난다.

이런 참사를 없애고자 문자 인증, 이메일 인증, 보안카드, 아이핀 등을 거쳐 휴대할 수 있는 토큰형 OTP가 나오고, 최근 은행에서는 카드 형태의 OTP를, 더 나아가 OTP를 앱으로 사용할 수 있게 되었다.


  
  https://blog.kakaobank.com/77


이처럼 유저의 신원을 한 번 더 인증하는 수단을 MFA(Multi-Factor Authentication)라 한다. 휴대폰 앱으로 은행 업무를 볼 때 공인인증서 외, 카드 비밀번호, 핸드폰 잠금패턴, 지문 혹은 생체인식 등 여러개의 인증 수단이 존재한다.

비밀번호 외 다른 하나의 인증 수단으로 신원을 인증이 가능한 것을 2FA(Two-Factor Authentication)라 한다. 대부분 다 2FA라 보면된다. 최근에 Github도 2FA를 필수로 설정하도록 되어 있고, AWS를 사용할 때도 반드시 설정해야 한다.



사용하다보니 OTP가 어떤 원리로 작동하는지 궁금해졌다.

> 이 숫자만 보고 어떻게 나라는걸 알 수 있을까? 그럼 이 숫자는 서버 어딘가에 있는건가? 인터넷에 연결이 안되어 있어도 사용할 수 있네? 처음 생성할 때 보여주는 Private key(혹은 recovery codes)를 갖고 있다면 언제든 복원이 가능하기도 하고... 등등

## OTP란?

OTP(One-Time Password)는 특정 알고리즘으로 숫자를 생성하여 본인 인증을 도와주는 프로그램이다. 크게 HOTP와 TOTP 두 종류로 나뉜다.

현재 많이 사용되고 있는 Google OTP, 은행 OTP 등 대부분 TOTP 기반으로 작동되고 있다.

흐름대로 소개하자면 HOTP를 먼저 하는게 맞지만, 우선 우리에게 익숙한 TOTP를 간단하게 설명한 후, HOTP를 살펴보기로 하자.

## TOTP(Time-based One-Time Password)

TOTP 스펙은 RFC6238에 정리되어 있다.

TOTP는 HOTP 기반으로 나왔으며, HOTP와 다른 점은 시간(Time) 기반이라는 점이다.


  
  Google OTP


우측의 원이 한 바퀴 다 돌면(Google OTP는 30초) 새로운 6자리 숫자가 뜬다.

```
TOTP = HOTP(K, T)
```

HOTP의 Counter에서 Time으로 바뀐 알고리즘이다. 기존에 HMAC이 연산 값을 단순하게 증가시키던 HMAC-SHA-1 알고리즘에서 일정 시간마다 값이 변경되도록 한 HMAC-SHA-256이나 HMAC-SHA-512 함수를 사용한다.



### TOTP 동작원리

```js
// 이해를 돕기 위해 임의로 만든 예시 코드입니다.
const secretKey = 'totp_scret_key' // 클라이언트와 서버가 각각 갖고 있는 시크릿 키
const totp = TOTP(secretKey) // 시크릿 키로 만들어진 TOTP 값

const currentOtpValue = totp.now() // output: '123456' (현재 OTP 값)
totp.exec(currentOtpValue) // output: true (현재 클라이언트의 OTP에 써져있는 값)

// 30초 후 실행시
totp.exec('123456') // output: false
```

TOTP는 처음에 바코드나 일정 길이의 문자열이 secretKey가 된다(간혹 recovery codes가 있는 곳도 존재한다). 따라서 이 키를 저장해두면, OTP를 잃어버려도 복구가 가능하다. 그리고 특정 시간(보통 30초 혹은 60초)마다 그 다음 값으로 변경된다. 하지만 클라이언트와 서버의 시간이 차이 때문에 제대로 인증이 되지 않는 경우도 있기 때문에 동기화할 수 있는 방법도 필요하다.

Google OTP에서도 비밀번호를 올바르게 입력했는데 인증 오류가 뜬다면 먼저 기기의 시간이 현지 시간과 일치한지, 그리고 OTP 내에서 시간 재동기화를 안내하고 있다.

카카오뱅크에도 이를 염두해두어 시간을 재설정하는 페이지가 존재한다.


  
  카카오뱅크 OTP 시간 재설정




## HOTP(HMAC-based One-Time Password)

HOTP 상세 스펙은 RFC4226에서 볼 수 있다.

스펙 문서에는 HOTP 알고리즘의 성립을 위한 최소 조건 6가지가 있는데, 그 중 가장 재미있었던 조건은 "핸드폰에서 입력하기 쉽도록 '오직 숫자'로만 하는것도 괜찮다"는 내용이었다. (지금은 별의 별 문자도 다 validation하는데 말이다..)

### HOTP 동작원리

다시 본론으로 돌아와서, TOTP가 HOTP 기반으로 만들어졌는데, 차이점은 counter 기반이라는 것이다. HOTP는 counter 값으로 클라이언트와 서버의 값이 일치하는지 확인한다. counter는 오직 클라이언트와 서버만 알 수 있는 대칭키 암호다.


  용어: 대칭키 암호(Symmetric-key)
  
    암호화와 복호화에 같은 암호 키를 쓰는 알고리즘으로 송/수신자가 같은 암호 키를 공유해야 한다
  


```js
// 이해를 돕기 위해 임의로 만든 예시 코드입니다.
const secretKey = 'hotp_secret_key' // 클라이언트와 서버가 각각 갖고 있는 시크릿 키
const hotp = HOTP(secretKey) // 시크릿 키로 만들어진 HOTP 값

const firstHotpValue = hotp.at(1) // output: '123' (counter가 1일때의 값)
hotp.exec('123', firstHotpValue) // output: true
hotp.exec('123', firstHotpValue) // output: false
```

secretKey는 클라이언트와 서버가 각각 갖고 있으며, 시크릿 키와 counter를 조합하여 값의 일치 여부를 판단한다.

하지만 HOTP의 취약점은 클라이언트와 서버의 counter의 업데이트 주기가 다르고 암호의 생명주기가 너무 길다는 것이다. 클라이언트의 counter 값은 인증을 요청할때마다 증가되고, 서버의 counter 값은 인증이 성공했을 때만 증가한다.

따라서 클라이언트 counter 값이 1일 때 요청을 보내면, 서버는 아직 1인데 클라이언트는 2로 변경된다. 그래서 서버는 그 다음 counter 값으로 넘어가 클라이언트 값과 일치하는지 확인해야 한다.

만약 유저가 인증 요청을 할 때마다 성공했으면 문제 되지 않지만, 만약 인증을 마치지 않은 채 재요청을 한다면, 클라이언트와 서버의 counter 값이 몇 단계 차이난다. 따라서 서버는 클라이언트와 counter 값을 맞추기 위해 이후의 counter 값을 순회하면서 맞는 값을 찾으려 한다. 만약 최대 허용 횟수를 초과했을 경우, 서버는 해당 계정을 잠그고 초기화한 다음 유저에게 알린다.

#### HMAC(Hash-based Message Authentication Code)이란?

HOTP 값은 RFC2104의 HMAC-SHA-1 알고리즘을 사용하여 구한다.

시크릿 키로 어떤 값을 확인하는 메커니즘을 message authentication codes(MAC)라 부른다. 그리고 이를 해싱 함수로 암호화한 것을 HMAC 메커니즘이라 한다.


  용어: 해시(Hash)
  
    해시(Hash)는 다양한 길이를 가진 데이터를 고정된 길이의 데이터로 반환한 값이다. 
    단방향으로만 사용할 수 있어서, 암호화된 결과 값과 암호화할 때 사용한 해시 값을 알더라도 원본이 무엇인지 찾을 수 없다.
    대표적으로 MD5, SHA-1 알고리즘이 존재한다.
  


### HOTP 알고리즘

```
HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))
```

HMAC-SHA-1이 반환한 값은 160 비트이기 때문에 유저가 입력하기 편하도록 변환(truncate)해야 한다.

|     |                                                                                                                                                                                   |
| :-- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| C   | 8 비트로 된 counter 값, moving factor(\*동적으로 변하는 값이라 의역). 이 값은 반드시 HOTP 생성기(클라이언트)와 HOTP 검증기(서버)와 동기화 되어야 한다. |
| K   | 클라이언트와 서버가 공유하는 시크릿 키이다. 각 HOTP 생성기마다 고유한 시크릿 키가 존재한다.                                                                                       |
| T   | 쓰로틀링(throttling) 파라미터. 만약 이 값이 성공적으로 인증을 시도하지 못한다면, 서버는 연결을 거부한다.                                                                          |
| s   | 재동기화(resynchronization) 파라미터. 서버는 연속된 counter 값을 대입해서 수신된 값과 일치한지 확인한다.                                                                          |

`T`와 `s`는 위에서 클라이언트와 서버의 counter 값이 일치하지 않을때 작동한다.

`T`는 핸드폰 비밀번호를 잘못 입력했을 경우, 그 횟수만큼 재시도할 수 있는 시간이 점점 길어지는 알고리즘이다. 예를 들어 T가 5라면, 처음 실패할 경우 `5*1`로 5초 뒤에 입력이 가능하고, 두 번째인 경우 `5*2`로 10초로 늘어나는걸 말한다. 그리고 입력 가능한 최대 횟수를 초과하면, 핸드폰이 완전히 잠긴다.

HOTP 서버의 counter 값은 오직 HOTP 인증이 성공한 후에 증가되지만, 클라이언트에 있는 counter 값은 유저가 인증 요청을 할 때마다 변경된다. 따라서 서버와 토큰의 counter 값이 달라질 수 있어서 재동기화가 필요하다. 따라서 `s`는 서버를 바라보고, 만약 서버의 값과 클라이언트 값이 일치하지 않는다면, 서버는 그 다음의 `s` 값을 확인하여 두 개의 값과 일치하는지 확인한다.

## 의문점

인증 서버는 어디에 있는걸까?

HOTP, TOTP의 서버는 동일한 데 시크릿 키에 따라 인증 값이 다른걸까? 찾게 된다면 추가할 예정이다.



**참고**



- RFC2104
- RFC4226
- RFC6238
- What is OTP/2FA/MFA?
- 
  What’s the Difference Between OTP, TOTP and HOTP?
- One Time Password(OTP)의 개념 및 동작방식. LDAP을 활용한 OTP 인증.



 -->


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/javascript/early-return</guid>
      <title>자바스크립트 Early return</title>
      <link>https://www.howdy-mj.me/javascript/early-return</link>
      undefined
      <pubDate>Thu, 02 Dec 2021 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>javascript</category>
      <content:encoded>
개발 하다보면 조건문 사용이 잦은데, 이를 어떻게 작성해야 가독성이 좋고 불필요한 로직 실행을 줄일 수 있을까 생각하게 된다.

switch문이나 삼항연산자는 어떤 값으로 분기처리 할 때 사용한다. 반면, 조건이 복잡한 경우 if문을 사용하지만 이를 중첩으로 사용할 경우 코드가 한 없이 복잡해진다.

제일 최악인 상황은 나중에 내가 짠 코드임에도 불구하고 다시 처음부터 어떤 조건으로 분기 처리했는지 봐야할 때다. 이런 고통스러운 상황을 피하기 위해 Early return을 하려는 편이다.

### Early return

Early return은 조건과 맞지 않는 결과를 일찍 반환하는 것이다. 그래서 `if/else` 대신 `if/return`을 사용한다.

#### 장점

- 소거법을 사용하여 빠르게 return하기 때문에 코드 전체를 보지 않아도 된다
- 코드 가독성이 좋아진다



기존 회원에게는 5% 할인 쿠폰을, 오늘 이후에 가입한 회원에게 신규회원 이벤트 팝업을 띄워주는 조건문을 만들어보자.

```js
const openEventPopup = () => {
  const isCreatedBeforeEventUser = userCreatedDate - new Date() 
  } else {
    return 
  }
}
```

이는 주로 운영한지 오래 되어 신규 회원보다 기존 회원이 더 많을 경우에 사용한다.

만약 서비스를 갓 오픈 하여 기존 회원보다 신규 회원이 더 많을 경우, 위의 코드는 불필요한 일을 여러 번 반복하는 꼴이다. 따라서, 신규 회원 팝업을 early return 하는 것이 좋다.

```js
// 기존 회원보다 신규 회원이 더 많을 경우
const openEventPopup = () => {
  const isCreatedAfterEventUser = new Date() - userCreatedDate 
  }
  return 
}
```

만약 성별에 따라 주고자하는 할인 쿠폰이 다를 경우를 가정해보자.

```js
const getRoom = (userGender, category) => {
  const gender = ['male', 'female']
  if (!gender.includes(userGender)) {
    return '성별을 입력해주세요'
  }

  const isMale = userGender === 'male'
  const isFemale = userGender === 'female'

  if (isMale) {
    if (category) {
      // 특정 카테고리에 따른 할인 쿠폰
    }
    // 남성 제품 중 어디서나 사용 가능한 할인 쿠폰
  }

  if (isFemale) {
    if (category) {
      // 특정 카테고리에 따른 할인 쿠폰
    }
    // 여성 제품 중 어디서나 사용 가능한 할인 쿠폰
  }
}
```

만약 성별을 정확히 입력하지 않았다면, 바로 에러 메세지를 보여주기 때문에 아래의 로직을 수행하지 않는다.
성별을 입력했고, 특정 카테고리 내에 들어갔을 경우 그에 대응하는 할인 쿠폰을 보여준다.



하지만 필요없는 곳까지 early return을 쓸 경우, 되려 가독성을 해할 수도 있다.

```js
const updateName = name => {
  // 불필요한 return
  if (!name) {
    return
  }
  this.name = name
}
```

위 코드는 아래처럼 사용하면 더 깔끔하게 읽힌다.

```js
const updateName = name => {
  if (name) {
    this.name = name
  }
}
```



**참고**



- Are Early Returns Any Good?
- Return Early Pattern


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/typescript/access-modifiers</guid>
      <title>타입스크립트 접근제한자(public, protected, private)</title>
      <link>https://www.howdy-mj.me/typescript/access-modifiers</link>
      undefined
      <pubDate>Wed, 10 Nov 2021 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>typescript</category>
      <content:encoded>
자바스크립트에는 마땅히 Class 내부의 값을 은닉화를 할 수 있는 방법이 없었다.

다행히 타입스크립트에는 접근 제한자(Access modifier)인 `public`, `protected`, `private`를 지원하며, 이를 통해 외부에서 특정 메서드나 프로퍼티에 접근 범위를 지정할 수 있다.

## public

public은 어디에서나 접근할 수 있으며 생략 가능한 default 값이다.

```ts
class Hello {
  name: string

  constructor(name: string) {
    this.name = name
  }

  // public 생략 가능
  public greet() {
    console.log(`hi! ${this.name}`)
  }
}

const hello = new Hello('kmj')
hello.greet() // output: 'hi! kmj'
```

name을 선언해주기 위해서 꽤나 많은 양의 코드를 작성해야 하는데, 이를 constructor에서 한 번에 선언할 수 있다.

```ts
class Hello {
  constructor(public name: string) {}
  // 생략
}
```

## protected

protected는 해당 클래스 혹은 서브클래스의 인스턴스에서만 접근이 가능하다.

```ts
// 1. 해당 클래스에서 접근
class Hello {
  constructor(public name: string) {}

  greet() {
    console.log(`hi! ${this.name}, log: ${this.test()}`)
  }

  protected test() {
    return 'test'
  }
}

const hello = new Hello('kmj')
hello.greet() // output: 'hi! kmj, log: test'

// 2. 서브클래스에서 접근
class Hi extends Hello {}

const hi = new Hi('howdy')
hi.greet() // output: 'hi howdy, log: test'
```

단, 서브클래스에서 `protected`로 된 값을 `public`으로 오버라이딩한다면 해당 값은 `public`으로 취급된다.

```ts
class Hi extends Hello {
  test() {
    return 'override'
  }
}

const hi = new Hi('howdy')
hi.greet() // output: 'hi howdy, log: override'

const test = hi.test()
console.log(test) // output: 'override'
```

오버라이딩할 경우, 상위클래스의 return 타입과 같아야 한다 그렇지 않으면 에러를 반환한다.

## private

`private`는 해당 클래스의 인스턴스에서만 접근 가능하다.

```ts
class Hello {
  constructor(private name: string) {}
}

const hello = new Hello('kmj')
hello.name // Property 'name' is private and only accessible within class 'Hello'.
```

위의 예시에서 name을 가져오려하려면, 위와 같은 에러가 뜬다.

그리고 서브클래스에서 name을 `public`으로 바꾸어주려고 해도 에러가 뜬다.

```ts
class Hi extends Hello {
  constructor(public name: string) {
    super(name)
  }
  // Class 'Hi' incorrectly extends base class 'Hello'.
  // Property 'name' is private in type 'Hello' but not in type 'Hi'.ts(2415)
}
```

## Caveats

하지만 `private`와 `protected`로 지정한 값들이 항상 보호되는 것이 아니라, key 값으로는 접근이 가능하다.

```ts
const hello = new Hello('kmj')
console.log(hello['name']) // output: 'kmj'
```

따라서 온전히 보호하기 위해서는 다른 장치가 필요하다. (추후 보충)

### readonly

만약 정말 수정되면 안되는 값이 있다면, `readonly` 접근자를 활용해야 한다.

```ts
class Hello {
  readonly hey: string = 'Hey'

  constructor(private name: string) {}
}

const hello = new Hello('kmj')
console.log(hello.hey) // output: 'Hey'

hello.hey = 'test' // Error: Cannot assign to 'hey' because it is a read-only property.
```



_추후 추가할 내용_

- getter, setter



**참고**



- TypeScript: Documentation


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/html/script-element</guid>
      <title>script 요소 알아보기</title>
      <link>https://www.howdy-mj.me/html/script-element</link>
      undefined
      <pubDate>Sat, 30 Oct 2021 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>html</category>
      <content:encoded>
HTML의 `script` 요소는 보통 JavaScript를 불러오기 위해 사용된다. 그 외, WebGL의 GLSL 셰이더 프로그래밍 언어, JSON 등 다른 언어와도 사용이 가능하다.

```html


  

```

`script`의 interface는 HTMLScriptElement이며 여러 프로퍼티들이 존재한다.

## src

src 속성은 외부 스크립트의 URI를 적어준다. 프로젝트 내부의 스크립트라 상대주소일 수도 있고, 외부 라이브러리일 경우 절대 주소일 수도 있다.

## async와 defer

일반적으로 스크립트 파일은 화면이 다 그려진 후에 가져온다.

그러나 async나 defer 속성이 존재하면, 화면이 다 그려지기 전에도 스크립트를 가져올 수 있다. (단, 인라인에서 src 속성이 없을 때 async와 defer를 사용하면 안된다.)

async나 defer 속성 모두 boolean 타입으로 태그에 속성만 작성하면 된다

```html

  
  
  

```

두 속성 모두 false가 기본 값이다.



스크립트를 불러오는 데는 크게 세 가지 유형이 존재한다.


  
  https://www.josefzacek.cz/blog/whats-the-difference-between-async-vs-defer-attributes/


1. async 속성이 있다면, 스크립트가 다운되자마자 비동기적으로 실행된다.
2. async 속성이 없고, defer가 존재한다면, 스크립트는 페이지가 파싱이 끝나고 화면에 콘텐츠가 로딩되기 전에 실행된다.
3. 만약 둘 다 없다면, 스크립트를 곧바로 불러오고 실행하지만, 페이지 파싱이 멈춘다.

페이지의 콘텐츠 로딩 여부는 아래 코드로 확인이 가능하다.

```js
window.addEventListener('DOMContentLoaded', event => {
  console.log('DOM fully loaded and parsed')
})
```

defer 속성은 HTML 파싱이 끝나고, 화면에 콘텐츠가 그려지기 전에 스크립트가 실행된다. 따라서, 화면이 렌더되기 전에 스크립트를 가져오고 순서를 보장받고 싶다면 defer 속성을 사용하면 된다.

## type

해당 스크립트의 타입을 나타내는 것으로, 자주 사용하는 유형은 두 가지가 있다.

### JavaScript MIME

```html

```

해당 스크립트가 자바스크립트인 것을 뜻하며, 기본 값이라 생략해도 무관하다.

### module

모듈은 하나의 클래스 혹은 특정 목적을 가진 함수다. 모듈 스코프가 따로 존재하여 외부에 공개하려면 export로 내보내야 하며, 사용하려면 import로 가져와야 한다.

```html

```

스크립트를 자바스크립트 모듈(`mjs` 확장자가 모듈임을 명시)로 간주한다. 자바스크립트 모듈은 항상 지연 실행되어, defer와 동일하게 실행된다. _(모듈은 추후 다른 글에서 자세히 다뤄 볼 예정이다)_

## crossorigin

현재와 다른 도메인에서 스크립트를 불러올 때, 해당 스크립트를 어떻게 다룰 것인지 설정하는 속성으로, `script`뿐만 아니라, `audio`, `img`, `link`, `video`에도 사용 가능하다.

```html

```


  
  script만 작성했을 경우


일반 `script`는 표준 CORS를 통과하지 못했을 때 window.onerror에 최소한의 정보만 넘긴다. 따라서 정확히 어떤 원인인지 파악하기 어렵다.

반면 crossorigin 속성은 다른 도메인을 사용하는 사이트의 에러 기록을 자세히 알려준다. 해당 속성에는 anonymous, use-credentials이 들어갈 수 있다. 만약 빈 문자열이나 잘못된 값이 들어간다면 anonymous와 동일하게 동작한다.

```html

```


  
  crossorigin이 anonymous인 경우


crossorigin도 나중에 다양한 예시를 갖고 다시 글에 다뤄보고 싶다.



**참고**



- MDN - script


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/storybook/setting-emotion</guid>
      <title>Storybook에서 Emotion 설정하기</title>
      <link>https://www.howdy-mj.me/storybook/setting-emotion</link>
      undefined
      <pubDate>Tue, 12 Oct 2021 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>storybook</category>
      <content:encoded>
> 해당 글에서 사용된 packages 버전은 아래와 같습니다.

package.json

```json
{
  // ...생략
  "dependencies": {
    "@emotion/babel-preset-css-prop": "^11.2.0",
    "@emotion/react": "^11.4.0",
    "@emotion/styled": "^11.3.0",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-router-dom": "^5.2.0",
    "react-scripts": "4.0.3",
    "typescript": "^4.1.2"
  },
  "devDependencies": {
    "@babel/preset-react": "^7.13.13",
    "@emotion/babel-plugin": "^11.3.0",
    "@storybook/addon-actions": "^6.3.8",
    "@storybook/addon-essentials": "^6.3.8",
    "@storybook/addon-links": "^6.3.8",
    "@storybook/node-logger": "^6.3.8",
    "@storybook/preset-create-react-app": "^3.2.0",
    "@storybook/react": "^6.3.8",
    "babel-loader": "8.1.0"
  }
}
```

만약 react와 storybook의 babel-loader가 상충되어 에러가 뜬다면, `package-lock.json` 혹은 `yarn.lock` 그리고 `node_modules`를 삭제 후 재설치한다.

그 다음에도 에러가 뜬다면 `npm ls babel-loader`로 가장 낮은 babel-loader 버전을 프로젝트에 설치한다. 해당 프로젝트는 8.1.0 버전으로 설치했다.

## Cannot read properties of undefined 에러 해결하기

스토리북을 설치하고, `yarn storybook`으로 스토리북 서버까지 잘 실행되지만, 막상 작성한 Button.stories.index를 열려니 emotion으로 설정한 값을 제대로 불러오지 못했다.


  
  Cannot read properties of undefined (reading 'mobile')


src/styles/theme.ts

```ts
const theme: Theme = {
  // ...생략
  mq: {
    laptop: `only screen and (min-width: ${size.largest})`,
    tablet: `only screen and (max-width: ${size.large})`,
    mobile: `only screen and (max-width: ${size.small})`,
  },
}
```

이는 로컬서버에서는 emotion으로 정의한 theme이 잘 적용되었지만, 스토리북에서는 해당 설정을 찾지 못해 뜨는 에러였다.



스토리북 설정은 `.storybook/main.js`와 `.storybook/preview.js`에서 가능하며, 해결 방법은 아래와 같다.

.storybook/main.js

```js
const path = require('path')

const toPath = _path => path.join(process.cwd(), _path)

module.exports = {
  stories: ['../src/**/*.stories.mdx', '../src/**/*.stories.@(js|jsx|ts|tsx)'],
  addons: [
    '@storybook/addon-links',
    '@storybook/addon-essentials',
    '@storybook/preset-create-react-app',
  ],
  webpackFinal: async config => ({
    ...config,
    resolve: {
      ...config.resolve,
      alias: {
        ...config.resolve.alias,
        '@emotion/core': toPath('node_modules/@emotion/react'),
      },
    },
  }),
}
```

따로 설정한 emotion 전역 스타일이 있을 경우, 프로젝트의 `App.tsx`에 설정하는 것처럼, 스토리북에서는 `preview.js`에서 설정해준다.

.storybook/preview.js

```js
import { ThemeProvider } from '@emotion/react'

import theme from '../src/styles/theme'
import GlobalStyle from '../src/styles/global'

export const decorators = [
  Story => (
    
      
       // Canvas 영역을 뜻함
    
  ),
]
```

위처럼 decorators를 통해서 stories 컴포넌트에 공통으로 사용할 스타일이나 요소를 설정할 수 있다. `preview.js`는 모든 stories에 전역으로 설정하는 것이고, 개별 stories내에서도 설정이 가능하다.

```js
// 예시: YourComponent.stories.js | YourComponent.stories.jsx
export default {
  component: YourComponent,
  decorators: [
    Story => (
      
        
      
    ),
  ],
}
```

## What & Why

### @emotion/core

해당 프로젝트에서는 `@emotion/core` 패키지가 없는데 왜 넣었는지 궁금했다.

그래서 해당 줄을 지우고 다시 켜봤더니, 작동은 하지만, Docs를 들어가보면 에러가 뜬다.


  
  Uncaught TypeError: Cannot read properties of undefined (reading 'content')


해당 버전의 Storybook에서는 `@storybook/addon-essentials` 안에 `@storybook/addon-docs`가 포함되어 있다. 그리고 addon-docs의 package.json을 보니 emotion을 보니 `@emotion/core 10.1.1` 버전이었다. (참조)

따라서 스토리북이 구동할 때 필요한 패키지가 무엇인지 알려줘야 한다. 그리고 그 일을 도와주는 것이 resolve의 역할이다.

### webpackFinal

Storybook은 webpack을 통해서 프로젝트에서 만든 컴포넌트들을 우리가 만든 웹 어플리케이션에 보여준다. 그리고 관련 webpack 설정은 `.storybook/main.js` 파일에서 가능하다. (참조)

위처럼 Storybook 설정을 변경하기 위해서는 webpack config를 따로 설정해줘야 한다.

resolve.alias는 모듈 내에서 import를 쉽게 생성해주는 것이다. 사용법은 아래와 같다.

```js
const path = require('path')

module.exports = {
  //...
  resolve: {
    alias: {
      Utilities: path.resolve(__dirname, 'src/utilities/'),
      Templates: path.resolve(__dirname, 'src/templates/'),
    },
  },
}
```

해당 글에서는 `toPath`라는 함수를 만들어 사용했다.

```js
const toPath = _path => path.join(process.cwd(), _path)
```

`process.cws()`는 현재 프로젝트의 최상단 폴더를 뜻하고, `__dirname`는 현재 연 파일이 위치한 폴더를 뜻하는 것이다. 만약 여기서도 `__dirname`을 썼더라면, 상대경로로 해당 패키지가 어디 있는지 설정해줘야 한다.



**참고**



- Github: Storybook throw error if used emotion 11
- Storybook


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/typescript/extends-and-implements</guid>
      <title>extends와 implements</title>
      <link>https://www.howdy-mj.me/typescript/extends-and-implements</link>
      undefined
      <pubDate>Mon, 04 Oct 2021 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>typescript</category>
      <content:encoded>
자바스크립트에서 어떤 클래스를 상속받고 싶을 때는 하위 클래스에서 `extends` 키워드를 통해 상속 받을 수 있다. 그리고 타입스크립트에서는 `implements` 키워드를 통해서, interface와 class를 동시에 확장 가능한 것을 알고 있었다.

하지만 늘 그렇듯, 이 두 가지의 정확한 차이점은 알지 못했다.

## extends vs. implements

### extends

`extends` 키워드는 class 선언문이나 class 표현식에서 만들고자하는 class의 하위 클래스를 생성할 때 사용한다.

```js
class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
  }
}

class KMJ extends Person {
  sayHi() {
    console.log(`hi, ${this.name}`)
  }
}

const mj = new KMJ('kmj', 10)
console.log(mj.sayHi()) // output: hi, kmj
```

클래스의 `.prototype`은 반드시 Object이거나 null이어야 한다. null일 경우, 프로토타입 체인의 최상단을 뜻한다.


  
  console.dir(mj)



  
  Person.prototype


### implements

`implements` 키워드는 class의 interface에 만족하는지 여부를 체크할 때 사용된다. `implements`한 interface의 타입이 없다면 에러를 반환한다.

```ts
interface Person {
  name: string
  age: number
}

// 에러: age 미정의
class Howdy implements Person {
  // Class 'Howdy' incorrectly implements interface 'Person'.
  // Property 'age' is missing in type 'Howdy' but required in type 'Person'.
  name = 'howdy'
}
```

여기서 주의할 점은, `implements`는 오직 타입 체크를 위해 사용되는 것이지, 안의 값을 자동으로 바꾸어주지 않는다.

```ts
interface Person {
  name: string
  age: number
  isMJ(name: string): boolean
}

class Howdy implements Person {
  name = 'howdy'
  age = 20

  isMJ(name) {
    // 에러: parameter의 타입 미지정
    // Parameter 'name' implicitly has an 'any' type, but a better type may be inferred from usage.
    return this.name === 'kmj'
  }
}
```

### 소결론

`extends` 키워드는 새로운 클래스의 '상속'을 위해 사용한다. 상위 클래스의 모든 프로퍼티와 메서드들을 갖고 있으므로 일일이 정의하지 않아도 된다. 상위 클래스의 프로퍼티를 지정하지 않으면, 초기값으로 선언되며 에러는 반환하지 않는다.

`implements` 키워드는 새로운 클래스의 모양을 동일하게 정의하고 싶을 때 사용한다. 따라서, interface로 정의한 값들은 모두 필수적으로 들어가야 하며, 하나라도 빠질 경우 에러를 반환한다. 타입으로 지정한 메서드 모두 내부에서 재정의가 필요하다.

이는 `extends`와 `implements`의 차이점에 대해 정리한 것으로, 모든 기능에 대해 정리한 것은 아니다.

## React의 extends와 Angular의 implements

그러다 문득, React와 Angular가 컴포넌트 정의하는 방식이 다른 것이 생각났다.

React의 class 컴포넌트는 `extends`로 확장한다.

```js
class Welcome extends React.Component {
  render() {
    return Hello, {this.props.name}
  }
}
```

반면, Angular는 `implements`로 대부분의 구성요소(ex. Component, Directive, Service, Module)를 정의한다.

```ts
export class CounterComponent implements OnInit {}
```

공식문서를 보니 React의 Component는 class로 정의되어 있었고, Angular는 대부분 interface로 정의되어 있었다.

React의 Component:

```ts
class Component {
  static contextType?: Context | undefined
  context: any
  constructor(props: Readonly | P)
  setState(
    state:
      | ((prevState: Readonly, props: Readonly) => Pick | S | null)
      | (Pick | S | null),
    callback?: () => void
  ): void
  forceUpdate(callback?: () => void): void
  render(): ReactNode
  readonly props: Readonly & Readonly
  state: Readonly
  refs: {
    [key: string]: ReactInstance
  }
}
```

Angular의 OnInit:

```ts
interface OnInit {
  ngOnInit(): void
}
```

처음에는 왜 프레임워크인 Angular가 `extends`가 아닌 `implements`일까 궁금했다. 공식문서에는 Angular는 TypeScript가 기본으로 내제되어 있는 프레임워크로 모든 핵심 및 선택 기능을 TypeScript의 라이브러리처럼 참조해 개발할 수 있다고 나와있다.

이것만으로는 명쾌한 답을 내릴 수 없었지만, 이 외의 내용은 찾을 수 없어 필자 나름의 추측을 해보았다.

Angular에서 어떠한 기능을 추가하려면 Angular에서 만든 특정 규칙에 맞게 사용해야만 한다. 따라서 불필요하게 모든 프로퍼티와 메서드를 상속을 하는 `extends` 보다는 딱 그 형식에 맞는 `implements`로도 충분한게 아닐까는 생각이다. (닭이 먼저, 달걀이 먼저의 문제 같지만...) 또한, 해당 상황에 맞게 내용은 모두 재정의해야 한다.

그리고 Angular는 일반적으로 프로젝트의 규모가 크기 때문에 모든 것이 `extends`로 얽혀있다면 객체지향 프로그래밍이 추구하는 방향과도 맞지 않는 것 같다.



그렇다면 또 궁금한 것이 생겼다.

React가 추구하는 방향은 무엇일까? 라이브러리인데 굳이 왜 Component를 상속받으면서 프로퍼티와 메서드를 갖고 있게 하는 것일까? 그러다 hooks를 개발하게 된 이유는 무엇일까?

> 더 공부한 후 블로깅 해보려 한다.



**참고**



- TypeScript
- MDN - extends
- What's the difference between 'extends' and 'implements' in TypeScript


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/general/regular-expression-intro</guid>
      <title>정규표현식 알아보기</title>
      <link>https://www.howdy-mj.me/general/regular-expression-intro</link>
      undefined
      <pubDate>Sun, 19 Sep 2021 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>general</category>
      <content:encoded>
정규표현식(Regular Expression)은 일정한 패턴을 가진 문자열의 집할을 표현하기 위해 사용하는 형식 언어(Formal Language: 특정 법칙에 따라 적절하게 구성된 문자열들의 집합)다.

쉽게 말해, 내가 작성한 값이 어떠한 패턴을 준수하고 있는지를 알려준다. 주로 이메일, 비밀번호, 휴대폰번호 등의 패턴이 맞는지 확인할 때 사용한다.

ECMAScript 262에서도 정규표현식 객체를 정의하고 있으며, 정규표현식 리터럴과 RegExp 생성자 함수로 생성할 수 있다.

```js
// 1. 정규표현식 리터럴
const regex = /hi/g

// 2. RegExp 생성자 함수
const regex = new RegExp('hi', 'g')
```

일반적으로 자주 사용되는 방법은 정규표현식 리터럴이며, 아래 그림과 같이 구성되어 있다.


  
  https://poiemaweb.com/js-regexp




정규표현식은 RegEx Tester, regex101, RegExr 등에서 테스트해 볼 수 있다.

## 플래그

정규표현식의 플래그는 총 여섯 개가 있으며 검색 방식을 정할 수 있다. 선택적으로 사용할 수 있으며, 순서 구분은 따로 없으며, 하나 이상의 플래그도 사용할 있다.

만약 아무것도 설정하지 않는다면 대소문자를 구별하며, 첫 번째 매칭 대상만 검색한다.


  
    
    
    
  
  
    
      g
      Global
      모든 문자열(전역) 검색
    
    
      i
      Ignore case
      대소문자 구분 없이 검색
    
    
      m
      Multi-line
      여러 행 검색
    
    
      s
      dotAll
      `.`에 개행 문자도 매칭(ES2018)
    
    
      u
      Unicode
      유티코드, 패턴을 유니코드로 취급
    
    
      y
      Sticky
      sticky 검색 수행, 문자열의 현재 위치부터 검색 수행
    
  


가장 자주 사용하는 플래그는 `g`, `i`, `m` 이 세가지다.

## 정규표현식 메서드

정규표현식에서 주로 사용되는 메서드는 RegExp.prototype.exec, RegExp.prototype.test, String.prototype.match다.

### RegExp.prototype.exec

exec 메서드는 문자열을 검색하여 매칭 결과를 배열로 반환한다. 만약 매칭되는 것이 없으면 null을 반환한다.

```js
const regExp = /hi/

const target = 'hi howdy-mj'
regExp.exec(target) // output: ['hi', index: 0, input: 'hi howdy-mj, Hi!', groups: undefined]

const noTarget = 'howdy-mj'
regExp.exec(noTarget) // output: null
```

또한, exec 메서드는 플래그를 `g`로 설정하더라도 첫 번째 타겟만 반환한다.

```js
const regExp = /hi/
const hasTwoTarget = 'hi howdy-mj, hi!'
regExp.exec(hasTwoTarget) // output: ['hi', index: 0, input: 'hi howdy-mj, Hi!', groups: undefined]

const regExpWithG = /hi/g
regExpWithG.exec(hasTwoTarget) // output: ['hi', index: 0, input: 'hi howdy-mj, Hi!', groups: undefined]
```

### RegExp.prototype.test

test 메서드는 문자열을 검색하여 매칠 결과를 boolean 값으로 반환한다. 회원가입 시 입력한 값이 설정한 패턴과 부합한지 알아보기 위해 주로 사용하는 메서드다.

```js
const regExp = /hi/

const target = 'hi howdy-mj'
regExp.test(target) // output: true

const noTarget = 'howdy-mj'
regExp.test(noTarget) // output: false
```

### String.prototype.match

match 메서드는 String 표준 빌트인 객체에서 제공하며, 정규 표현식과 매칠 경과를 배열로 반환하며 exec 메서드와 비슷하다. 다만, `g` 플래그를 사용할 경우, 모든 매칭 결과를 배열로 반환한다.

```js
const regExp = /hi/
const hasTwoTarget = 'hi howdy-mj, hi!'
hasTwoTarget.match(regExp) // output: ['hi']

const regExpWithG = /hi/g
hasTwoTarget.match(regExpWithG) // output: ['hi', 'hi']
```



이 외, String.prototype.search, String.prototype.replace, String.prototype.split 메서드도 자주 사용된다.

## 특수문자로 패턴 만들기

위의 `/hi/`처럼 정규표현식을 만들 수 있지만, 휴대폰번호를 찾기 위해 `01*-`부터 모든 번호를 다 입력할 수 없다. 따라서 휴대폰 번호와 부합한 특정 패턴을 입력해야하는데, 이때 특수 문자를 사용해 그 패턴을 정의할 수 있다.

> _밑의 예시는 편의상 모두 플래그를 작성하지 않았다_

### 시작 문자

`^`로 찾을 수 있다.

```js
const startWithZeroRegExp = /^0/
const str = '010-1234-1234'
startWithZeroRegExp.test(str) // output: true
```

### 마지막 문자

`$`로 찾을 수 있다.

```js
const endWithZeroRegExp = /0$/
const str1 = '010-1234-1234'
const str2 = '010-1234-1230'
endWithZeroRegExp.test(str1) // output: false
endWithZeroRegExp.test(str2) // output: true
```

### 반복 패턴

`{m,n}`은 최소 m번, 최대 n번이 반복되는 문자열을 뜻한다. 이때 m과 n사이에 띄어쓰기가 있으면 안되며, 둘 다 양인 정수로, m 
  
    
    
    
  
  
    
      \d
      숫자
      [0-9]
    
    
      \D
      숫자가 아닌 것
      [^0-9]
    
    
      \n
      줄 바꿈 (U+000A)
    
    
      \s
      스페이스, 탭, 줄 바꿈 등을 포함한 하나의 공백
      [ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff].
    
    
      \S
      공백이 아닌 것
      [^ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff].
    
    
      \w
      밑줄(_)을 포함한 영문자, 숫자
      [A-Za-z0-9_]
    
    
      \W
      밑줄(_), 영문자, 숫자가 아닌 것
      [^A-Za-z0-9_]
    
  


## 자주 사용하는 정규표현식

### 이메일

```js
const emailRegExp = /^[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*\.[a-zA-Z]{2,3}$/
```

### 비밀번호

```js
// 1. 특수문자가 없는 8-20자리 비밀번호
const passwordRegExp = /[A-Za-z0-9]{8,20}/

// 2. 특수문자가 포함된 8-20자리 비밀번호
const passwordRegExp = /^.*(?=^.{8,20}$)(?=.*\W).*$/

// 3. 영어 대문자, 소문자, 숫자, 특수문자 각 1개가 포함된 8-20자리 비밀번호
const passwordRegExp = /^.*(?=^.{8,20}$)(?=.*\d)(?=.*[a-zA-Z])(?=.*[^a-zA-Z0-9]).*$/
```

### 핸드폰

```js
// 1. 헨드폰 번호 (ex. 010123401234)
const phoneRegExp = /^01\d{7,8}/

// 2. -를 갖고 있는 핸드폰 번호 (ex. 010-123-1234)
const phoneWithDashRegExp = /^\d{3}-\d{3,4}-\d{4}/

// 3. 지역번호를 포함한 연락처 (ex. 02-1234-1234)
const contactNumber = /^\d{2,3}-\d{3,4}-\d{4}/
```

### 기타

```js
// 숫자로만 이루어진 패턴
const onlyNumberRegExp = /^\d+$/

// 영문자로만 이루어진 패턴
const onlyAlphabetRegExp = /^[a-zA-Z]+$/

// 특수문자로만 이루어진 패턴
const symbolRegExp = /[^a-zA-Z0-9]/

// 특정 확장자 파일 (ex. tx, tsx, js, jsx 확장자)
const fileTypeRegExp = /^[\S]+\.(ts|tsx|js|jsx)$/
```



**참고**



- MDN - 정규표현식
- 모던 자바스크립트 Deep Dive, 이웅모 (2020)


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/general/raster-and-vector</guid>
      <title>이미지: 래스터와 벡터</title>
      <link>https://www.howdy-mj.me/general/raster-and-vector</link>
      undefined
      <pubDate>Thu, 09 Sep 2021 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>general</category>
      <content:encoded>
프로젝트에 사용할 이미지를 고를 때, 항상 PNG를 먼저 찾는다.

아이콘이나 로고는 확대해도 깨지지 않는 SVG로 하지만 정확한 이유를 잘 몰라서 알아보았다.



### 래스터와 벡터

이미지의 종류는 크게 래스터와 벡터 두 가지로 나뉘며, 요약하면 아래의 표와 같다.

| 래스터(Raster)          | 벡터(Vector)        |
|:---------------------|:------------------|
| 픽셀 기반                | 수학적 연산 기반         |
| 사진, 그림               | 아이콘, 로고           |
| 다양한 색상               | 색 표현에 한계          |
| 비교적 작은 용량            | 비교적 큰 용량          |
| JPG(JPEG), GIF, PNG  | SVG, AI, PDF      |


  
  https://cottonginprinting.com/image-file-types/



  
  https://vector-conversions.com/vectorizing/raster_vs_vector.html


## 래스터(Raster)

픽셀(점)이 모여 이루어진 이미지로, 사진과 그림 같이 섬세한 색상을 표현해야 하는 이미지에서 사용된다.

이미지를 늘리거나 줄이면 원본 이미지에 손상이 가서 가장자리가 매끄럽지 않게 계단처럼 보이는 현상(without anti-alias)이 나타나며, 우리는 통상 '이미지가 깨졌다'고 한다.


  
  https://www.computerhope.com/jargon/a/antialias.htm


래스터에 다양한 확장자가 존재하는데, 그 중에서도 가장 자주 쓰이는 JPEG, GIF와 PNG에 대해 알아보자.

### JPEG(Joint Photographic Experts Group)

JPEG는 정지된 이미지를 위해 만들어진 손실 압축 파일 형식이다. 손실 압축은 사람의 눈에 거슬리지 않을 정도로 원본을 훼손하여 압축 효과를 극대화 시키는 알고리즘이다. 이미지를 압축하면 이미지의 뭉개짐이 심해지지만, 크기가 작아져서 웹에서 많이 사용되고 있다.

하지만 JPEG는 투명 색상을 지원하지 않으며, 선명한 선, 문자 등이 많은 이미지는 JPEG보다 비손실 압축 방식인 GIF나 PNG 형식을 사용하는 것이 좋다.

### GIF(Graphics Interchange Format)

GIF는 비손실 압축 방식이며 원본을 훼손하지 않는다. 그래픽을 압축하여 빠르게 전송하기 위해 개발된 형식이다. 이미지 손상이 비교적 적고 용량이 작아서 전송속도가 빠르다. GIF는 투명도 지원 외에도, 애니메이션도 지원하지만 256색 제한이 존재한다.

### PNG(Portable Network Graphics)

PNG는 GIF의 256색 제한을 극복하여 트루 컬러를 표현할 수 있으며, GIF에는 없는 브라우저의 투명성을 지원하여 인터넷 그래픽에 최적화 되어있다. 또한, PNG 역시 비손실 압축 방식으로 압축을 하더라도 이미지의 품질을 저하하지 않는다.

PNG는 텍스트, 선 등에 적합하고 주로 투명 배경이 필요한 경우에 사용된다. 색상이 화려하거나 선이 많은 이미지의 경우 JPEG 대비 용량이 꽤 증가한다.

프로젝트 내에 포함한 이미지는 투명한 배경색이 있으며 한 번 압축시킨 후에 올리기 때문에 비손실 압축인 PNG를 주로 사용한다.

## 벡터(Vector)

벡터는 수학적 연산에 의해 선분과 면으로 이루어진 이미지라 확대해도 깨지지 않아, 로고나 아이콘 작업에 많이 사용된다. 하지만 다양한 색을 표현하는 데는 한계가 있어 최대한 단순한 색상으로 조합해서 사용한다.

웹 개발 할때 가장 자주 사용하는 SVG가 벡터의 대표적인 예다.

### SVG(Scalable Vector Graphics)

SVG는 XML 기반 마크업 언어로 W3C의 주도하에 오픈 웹 표준이고, 대부분의 브라우저가 SVG를 지원한다.

SVG는 x, y 좌표값을 갖으며 ``의 path로 이를 정확히 그려낼 수 있다. 또한, path에는 색상, 모양, 굵기 등의 다양한 정보를 입력할 수 있다. 그 외에도 circle, rect를 통해 해당 모양도 만들 수 있다. 다양한 SVG 요소 레퍼런스는 여기에서 볼 수 있다.



**참고**



- Raster vs Vector
- 벡터와 래스터는 어떻게 다를까?
- 래스터(Raster) 이미지와 벡터(Vector) 이미지 for CSS 속성
- Adding vector graphics to the Web
- What’s the Difference Between JPG, PNG, and GIF?


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/angular/router-guard-resolver</guid>
      <title>Angular 라우터의 Guard와 Resolver</title>
      <link>https://www.howdy-mj.me/angular/router-guard-resolver</link>
      undefined
      <pubDate>Fri, 20 Aug 2021 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>angular</category>
      <content:encoded>
> 본 글은 feature/guard-init을 clone 받아 따라할 수 있으며, 완성된 코드는 feature/guard에서 확인 가능하다.



Angular 라우터는 각 컴포넌트의 `module.ts`에 작성한다.

```ts
// 생략

const appRoutes: Routes = [
  { path: '/', component: HomeComponent },
  { path: '**', component: PageNotFoundComponent }
];

@NgModule({
  imports: [
    RouterModule.forRoot(
      appRoutes
    )
    // ...생략
  ],
  ...
})
export class AppModule {}
```

기본적인 라우팅 설정은 최상단 모듈인 `app.module.ts`에 위 코드처럼 path와 component를 작성하고, import하면 된다. 단, 하위 페이지 module에는 `RouterModule.forRoot`가 아닌 `RouterModule.forChild`로 import한다.

이 외, 앵귤러 라우터에서는 **Guard**를 지원한다.

보통 guard를 이용해 로그인한 유저만 볼수 있는 페이지를 구축한다. 이 외에도 해당 페이지에 진입할때 필요한 api를 호출하는 것과 미리 필요한 데이터를 보여주는 것, 해당 페이지에서 다른 곳으로 이동할 때 alert 경고를 띄우는 것이 모두 가능하다.



#### RouterModule.forRoot와 RouterModule.forChild

해당 프로젝트에는 모든 페이지의 url이 `/`로 시작하기 때문에 `RouterModule.forRoot`가 비어 있다. 만약 메인에서 서로 다른 url이 분기된다면 아래 처럼 작성할 수 있다.

src/app/app-routing.module.ts

```ts
import { NgModule } from '@angular/core'
import { RouterModule, Routes } from '@angular/router'

const routes: Routes = [
  {
    path: '',
    loadChildren: () =>
      import('./pages/home/home.module').then(module => module.HomeModule),
  },
  // 다른 path와 module
]

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule],
})
export class AppRoutingModule {}
```

단 위처럼 작성해도, `home.module.ts`에 `RouterModule.forChild`를 명시해줘야 화면에 정상적으로 반영된다.

## 라우터 설정

다시 본론으로 돌아와, 프로젝트를 실행해보자.


  
  메인 화면


본 글에서는 `/counter` 페이지에 guard와 resolve를 만들어 볼 것이다.


  
  counter 화면


counter 페이지는 간단하게 숫자를 더하고 뺄수 있는 화면이다.



앵귤러 라우터는 기본적으로 제공하는 기능이 다양하다. 이 중, 가장 많이 사용하는 CanActivate, CanDeactivate, Resolve를 다뤄보겠다.

### CanActivate

해당 데이터가 있을 때만 라우팅을 할 수 있도록 설정하는 것이기 때문에 CanActivate를 선택한다.

```shell
# 원하는 위치에 guard를 생성
$ ng g guard pages/counter/guard/counter-data
# 선택지에서 CanActivate 선택
```

src/app/pages/counter/guard/counter-data.guard.ts

```ts
import { Injectable } from '@angular/core'
import {
  ActivatedRouteSnapshot,
  CanActivate,
  RouterStateSnapshot,
} from '@angular/router'

@Injectable({
  providedIn: 'root',
})
export class CounterRouteGuard implements CanActivate {
  // 우선 필요없는 return 타입 제거
  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
    // return 값이 true여야 해당 페이지로 이동 가능
    return true
  }
}
```

그리고 module에 생성한 guard를 추가해준다.

src/app/pages/counter/counter.module.ts

```ts{14}
// 생략...
@NgModule({
  declarations: [
    CounterComponent,
    CounterOutputComponent,
    CounterButtonsComponent,
  ],
  imports: [
    CommonModule,
    RouterModule.forChild([
      {
        path: 'counter',
        component: CounterComponent,
        canActivate: [CounterDataGuard],
      },
    ]),
    StoreModule.forRoot({ counter: counterReducer }),
  ],
})
```

이번에는 api를 먼저 호출하고 그 값이 존재할때 true를 반환해주는 guard를 만들어보겠다. 해당 프로젝트에서 설정한 api는 Angular에서 http 초기 세팅하기를 참고하면 된다.

src/app/pages/counter/guard/counter-data.guard.ts

```ts
import { Injectable } from '@angular/core'
import {
  ActivatedRouteSnapshot,
  CanActivate,
  RouterStateSnapshot,
} from '@angular/router'
import { Observable } from 'rxjs'

import { map } from 'rxjs/operators'
import { ApiService } from '../../../api/api.service'

@Injectable({
  providedIn: 'root',
})
export class CounterDataGuard implements CanActivate {
  constructor(private api: ApiService) {}

  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): Observable {
    return this.api.get('/todos').pipe(
      map(todos => {
        if (todos) {
          return true
        }
        return false
      })
    )
  }
}
```

위처럼 작성하고 counter 페이지를 진입하면, network 탭에서 먼저 api를 호출한 후, counter UI가 보이는 것을 확인할 수 있다.



### CanDeactivate

CanActivate와는 반대로 해당 페이지에서 나갈 때 확인한다. 보통 어떤 작성 중인것을 저장 안하고 다른 페이지로 이동할때 사용된다.

```shell
# 원하는 위치에 guard를 생성
$ ng g guard pages/counter/guard/counter-deactivate
# 선택지에서 CanDeactivate 선택
```

src/app/pages/counter/guard/counter-deactivate.guard.ts

```ts
import { Injectable } from '@angular/core'
import {
  ActivatedRouteSnapshot,
  CanDeactivate,
  RouterStateSnapshot,
  UrlTree,
} from '@angular/router'
import { Observable } from 'rxjs'
import { CounterComponent } from '../containers/counter.component'

@Injectable({
  providedIn: 'root',
})
export class CounterDeactivateGuard implements CanDeactivate {
  canDeactivate(
    component: CounterComponent, // 사용할 컴포넌트
    currentRoute: ActivatedRouteSnapshot,
    currentState: RouterStateSnapshot,
    nextState?: RouterStateSnapshot
  ): boolean {
    return true
  }
}
```

간단하게 boolean으로 return 값을 받을 거기 때문에 필요없는 type은 제거했다. module에 잊지말고 import해주자.

src/app/pages/counter/counter.module.ts

```ts{17}
// ...생략
import { CounterDeactivateGuard } from './guard/counter-deactivate.guard'

@NgModule({
  declarations: [
    CounterComponent,
    CounterOutputComponent,
    CounterButtonsComponent,
  ],
  imports: [
    CommonModule,
    RouterModule.forChild([
      {
        path: 'counter',
        component: CounterComponent,
        canActivate: [CounterDataGuard],
        canDeactivate: [CounterDeactivateGuard],
      },
    ]),
    StoreModule.forRoot({ counter: counterReducer }),
  ],
})
export class CounterModule {}
```

`CanDeactivate`는 페이지를 이탈할 때, 현재 route 정보와 이동할 페이지의 url를 알 수 있다. 이를 통해 특정 페이지로 이동할때 어떤 조건을 체크한다던지, 라우팅을 못하게 막는다던지 등의 행위를 할 수 있다. 여기서는 '/counter' 페이지에서 '/text-directive'로 이동하지 못하게 막아보자.

src/app/pages/counter/guard/counter-deactivate.guard.ts

```ts
// ...생략
@Injectable({
  providedIn: 'root',
})
export class CounterDeactivateGuard implements CanDeactivate {
  canDeactivate(
    component: CounterComponent,
    currentRoute: ActivatedRouteSnapshot,
    currentState: RouterStateSnapshot,
    nextState?: RouterStateSnapshot
  ): Observable | boolean {
    if (nextState.url === '/text-directive') {
      return false
    }
    return true
  }
}
```

이렇게 하면 text-directive 버튼을 눌러도 페이지가 이동되지 않는다. 이 외, 페이지를 이탈할 때 component 안에 있는 함수를 실행할 수도 있다.

```ts
// ...생략
@Injectable({
  providedIn: 'root',
})
export class CounterDeactivateGuard implements CanDeactivate {
  canDeactivate(component: CounterComponent): Observable | boolean {
    return component.checkIsTrue()
  }
}
```



### Resolver

Resolver는 라우팅이 완료 되기 전에 원하는 값을 가져와 준다. `counter/resolver` 안에 title을 가져오는 resolver를 만들어보자.

```shell
$ ng g resolver pages/counter/resolver/counter-title
```

src/app/pages/counter/resolver/counter-title.resolver.ts

```ts
import { Injectable } from '@angular/core'
import {
  Resolve,
  RouterStateSnapshot,
  ActivatedRouteSnapshot,
} from '@angular/router'

@Injectable({
  providedIn: 'root',
})
export class CounterTitleResolver implements Resolve {
  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): string {
    // 기존 코드는 제거하고 간단하게 아래의 string을 반환
    return 'Counter 페이지'
  }
}
```

만약 api에서 호출하는 값이라면 Observable로 return되기 때문에 타입도 잘 명시해주는걸 잊지 말자.

src/app/pages/counter/counter.module.ts

```ts{18-20}
// ...생략
import { CounterTitleResolver } from './resolver/counter-title.resolver'

@NgModule({
  declarations: [
    CounterComponent,
    CounterOutputComponent,
    CounterButtonsComponent,
  ],
  imports: [
    CommonModule,
    RouterModule.forChild([
      {
        path: 'counter',
        component: CounterComponent,
        canActivate: [CounterDataGuard],
        canDeactivate: [CounterDeactivateGuard],
        resolve: {
          title: CounterTitleResolver, // title이란 이름으로 저장
        },
      },
    ]),
    StoreModule.forRoot({ counter: counterReducer }),
  ],
})
export class CounterModule {}
```

src/app/pages/counter/containers/counter.component.ts

```ts
import { Component, OnInit } from '@angular/core'
import { ActivatedRoute } from '@angular/router'
import { Observable } from 'rxjs'
import { pluck } from 'rxjs/operators'

@Component({
  selector: 'app-counter',
  templateUrl: './counter.component.html',
  styleUrls: ['./counter.component.scss'],
})
export class CounterComponent implements OnInit {
  title: Observable

  constructor(private route: ActivatedRoute) {}

  ngOnInit(): void {
    this.title = this.route.data.pipe(pluck('title'))
    // this.title.subscribe(console.log); // console로 확인
  }
}
```

src/app/pages/counter/containers/counter.component.html

```html{7}



  


{{ title | async }}
```


  
  counter 화면


Resolver항상 라우팅이 완료되기 전에 해당 값을 가져오기 때문에, `title`이 없는 경우의 상황을 고려하지 않아도 되는 장점이 있다.

## 특정 url에만 설정하기

만약 아무런 설정을 하지 않으면, module에 있는 guard와 resolver는 라우팅 될 때마다 실행된다. RunGuardsAndResolvers를 통해 해당 페이지의 params나 query가 바뀔 때 실행하게도 설정할 수 있다.

src/app/pages/counter/counter.module.ts

```ts
// 생략...
@NgModule({
  declarations: [
    CounterComponent,
    CounterOutputComponent,
    CounterButtonsComponent,
  ],
  imports: [
    CommonModule,
    RouterModule.forChild([
      {
        path: 'counter',
        component: CounterComponent,
        canActivate: [CounterDataGuard],
        runGuardsAndResolvers: 'always', // default가 'always'
      },
    ]),
    StoreModule.forRoot({ counter: counterReducer }),
  ],
})
```



**참고**



- @angular/router


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/angular/http-setting</guid>
      <title>Angular에서 http 초기 세팅하기</title>
      <link>https://www.howdy-mj.me/angular/http-setting</link>
      undefined
      <pubDate>Tue, 03 Aug 2021 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>angular</category>
      <content:encoded>
프로젝트 초기에 api 설정 파일을 만들어두면 나중에 작업하기 편하다.

Angular는 `@angular/common` 안에 존재하는 http 패키지를 사용하면 된다.

## 프로젝트 생성

```shell
# 앵귤러가 없을 시 설치
$ npm install -g @angular/cli

# 앵귤러 프로젝트 생성
$ ng new 프로젝트명

# 로컬에서 실행
$ ng serve
# or
$ yarn start
```

http 작업을 하기 위해 `src/app.module.ts`에서 HttpClientModule을 import 해야 한다.

src/app.module.ts

```ts
import { NgModule } from '@angular/core'
import { BrowserModule } from '@angular/platform-browser'
import { HttpClientModule } from '@angular/common/http'
import { AppRoutingModule } from './app-routing.module'
import { AppComponent } from './app.component'

@NgModule({
  declarations: [AppComponent],
  // BrowserModule 다음에 HttpClientModule를 작성해야 한다
  imports: [BrowserModule, HttpClientModule, AppRoutingModule],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {}
```

## ApiService 구축

api는 전역에서 사용하는 것이기 때문에 service로 만든다. (Angular 파일 구조 소개 참고)

필자는 `src/api` 폴더 아래에 `api.service.ts` 파일을 만들었다.

src/api/api.service.ts

```ts
import { Injectable } from '@angular/core'

@Injectable({
  providedIn: 'root',
})
export class ApiService {
  constructor() {}
}
```

> Injectable이기 때문에 다른 module에서 import하지 않아도 바로 사용할 수 있다.



### baseUrl 설정

이제 불러 올 api의 baseUrl을 설정해준다.

```ts
import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'

@Injectable({
  providedIn: 'root',
})
export class ApiService {
  public BASE_URL = 'https://jsonplaceholder.typicode.com'

  constructor(private http: HttpClient) {}
}
```

보통 `BASE_URL`은 각 프로젝트의 `.env`에서 환경 별로 다르게 설정한다.

src/environments/environments.ts

```ts
// environment.test.ts
export const environment = {
  production: false,
  baseUrl: 'https://test.api.example.com',
}

// environment.prod.ts
export const environment = {
  production: true,
  baseUrl: 'https://api.example.com',
}
```

이렇게 설정한 후, `src/api/api.service.ts`에 아래 처럼 불러오면 된다.

```ts
import { environment } from '../../environments/environment'
// ...생략
export class ApiService {
  public BASE_URL = environment.baseUrl
}
```



### http 메서드 설정

src/api/api.service.ts

```ts
import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { Observable } from 'rxjs'

@Injectable({
  providedIn: 'root',
})
export class ApiService {
  public BASE_URL = 'https://jsonplaceholder.typicode.com'

  constructor(private http: HttpClient) {}

  get(endPoint: string): Observable {
    return this.http.get(`${this.BASE_URL}${endPoint}`)
  }

  post(endPoint: string, body: any): Observable {
    return this.http.post(`${this.BASE_URL}${endPoint}`, body)
  }

  put(endPoint: string, body: any): Observable {
    return this.http.put(`${this.BASE_URL}${endPoint}`, body)
  }

  delete(endPoint: string): Observable {
    return this.http.delete(`${this.BASE_URL}${endPoint}`)
  }
}
```

Angular의 http의 return 타입은 모두 Observable이기 때문에, 할당할 변수의 타입도 Observable로 지정해야 한다.

src/pages/home.components.ts

```ts
import { Component, OnInit } from '@angular/core'
import { Observable } from 'rxjs'
import { ApiService } from 'src/app/api/api.service'

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html',
  styleUrls: ['./home.component.scss'],
})
export class HomeComponent implements OnInit {
  todos$: Observable

  constructor(private api: ApiService) {
    this.todos$ = this.api.get('/todos')
    this.todos$.subscribe(console.log) // console 확인
  }

  ngOnInit(): void {}
}
```


  
  todos console


console로도 데이터가 잘 들어오는 걸 확인할 수 있다.

## Error 처리

만약 에러를 처리하고 싶다면, 각 api 요청마다 설정할 수도 있지만 `api.service.ts`에서 설정 해줘도 된다.

src/api/api.service.ts

```ts
import { catchError } from 'rxjs/operators'
// ...생략

export class ApiService {
  private handleError(error: HttpErrorResponse) {
    if (error.status === 0) {
      console.error('Error:', error.error)
    } else {
      console.error(`Backend error ${error.status}, ${error.error}`)
    }
    return throwError('예기치 못한 에러가 발생했습니다. 다시 시도해주세요.')
  }

  get(endPoint: string): Observable {
    return this.http
      .get(`${this.BASE_URL}${endPoint}`)
      .pipe(catchError(this.handleError))
  }
}
```



**참고**



- [Communicating with backend services using HTTP](https://angular.io/guide/http#requesting-data-from-a-server)


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/bookmark/vr-ar-xr-mr</guid>
      <title>VR, AR, XR, MR</title>
      <link>https://www.howdy-mj.me/bookmark/vr-ar-xr-mr</link>
      undefined
      <pubDate>Sun, 20 Jun 2021 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>bookmark</category>
      <content:encoded>

마지막 업데이트: 2021.11.3


 -->

VR(가상현실), AR(증강현실), XR(확장현실), MR(융합현실) 관련 북마크 모음



> Web 관련 내용은 WebXR에서 볼 수 있습니다.

## Developer Docs

### VR

- Oculus - For Developers

### AR

- Facebook - Spark AR
- Apple - ARKit
- Google - ARCore

### XR

- OpenXR

### MR

- Microsoft - Mixed Reality

## Tools

- Unity
- Unreal Engine
- Vuforia

## Platforms

- NVIDIA OMNIVERSE
- Hubs - mozilla

## 블로그

### 해외

- DotNetByExample - The Next Generation (Joost van Schaik)

## 산업 분석

- Meta: 메타버스 진화 방향과 기업 페이스북/기업 메타의 미래 (2021.11.01)
- XIA, 2040년까지의 미래 - 신동형 (2021.11.01)
- 메타버스는 미래의 인터넷이다. Web을 대하는 태도가 바뀐 메타/페이스북 진심이다. (2021.10.30)
- 가상 증강현실에서의 OpenXR과 WebXR (2021.1.13)

 -->
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/javascript/array-and-array-like-object-and-iterable</guid>
      <title>배열, 유사 배열 객체 그리고 이터러블</title>
      <link>https://www.howdy-mj.me/javascript/array-and-array-like-object-and-iterable</link>
      undefined
      <pubDate>Fri, 18 Jun 2021 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>javascript</category>
      <content:encoded>
배열(Array)이란 여러 개의 값을 순차적으로 나열한 자료구조이며, 안의 값을 요소(Element)라 한다.

단순히 나열된 구조로 보이는 배열이 자바스크립트에서는 다소 독특한 데이터 같다. 자바스크립트에는 배열이라는 타입이 존재하지 않으며, 배열의 타입을 찍어보면 객체(object)라 나온다.

```js
const arr = [1, 2, 3]
typeof arr // output: 'object'
```

하물며 배열의 형태가 아닌 일반 객체로도 반복문을 돌릴 수 있다. 도대체 어떻게 객체로 반복문을 돌릴 수 있는 걸까?



MDN은 배열을 아래와 같이 정의했다.

> 배열은 프로토타입으로 탐색과 변형 작업을 수행하는 메서드를 갖는, 리스트와 비슷한 객체(list-like objects)입니다.

여기서 말하는 리스트와 비슷한 객체란 무슨 뜻 일까? 이걸 알기 위해서는 우선 자료구조에서 말하는 배열이 무엇인지 알아야 한다.


  
  https://www.geeksforgeeks.org/array-data-structure/


자료구조에서 말하는 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료구조를 말한다. 즉, 배열의 요소는 하나의 데이터 타입으로 통일되어 있으며 서로 연속적으로 이어져 있다. 이러한 배열을 밀집 배열(Dense Array)이라 한다. 따라서 인덱스를 통해 단 한 번의 연산으로 임의의 요소에 접근(임의 접근, Random Access)이 가능하다.

하지만 배열에서 특정한 요소를 검색할 때, 배열의 모든 요소를 처음부터 특정 요소를 발견할 때까지 차례대로 검색(선형 검색, Linear Search)해야 한다. 또한 배열에 요소를 삽입하거나 삭제하는 경우, 배열의 요소를 연속적으로 유지하기 위해 요소를 이동시켜야 하는 단점도 있다.

하지만 자바스크립트의 배열의 요소는 동일한 크기의 메모리 공간은 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있다. 즉, 원시값, 객체, 함수, 배열 등 어떤 값이든 모두 배열의 요소가 될 수 있다. 이러한 배열을 희소 배열(Sparse Array)이라 한다.


  
  https://matteding.github.io/2019/04/25/sparse-matrices/


이처럼 자바스크립트의 배열은 엄밀히 말해 일반적인 의미의 배열이 아니며, 일반적인 배열의 동작을 흉내 낸 특수한 객체다.

## 자바스크립트의 배열

자바스크립트의 배열은 객체이지만, 일반 객체와 달리 인덱스와 length 프로퍼티가 존재한다.

```js
const num = [1, 2, 3]
```

### 인덱스

배열의 요소는 자신의 위치를 나타내는 0 이상의 정수인 인덱스(index)를 갖는다. 인덱스는 배열의 요소에 접근할 때 사용한다. 대부분의 프로그래밍 언어에서 인덱스는 0부터 시작한다.

요소에 접근할 때는 대괄호 표기법을 사용한다. 대괄호 내에는 접근하고 싶은 요소의 인덱스를 지정한다.

```js
num[0] // output: 1
num[1] // output: 2
num[2] // output: 3
```

### length

배열은 요소의 개수, 즉 배열의 길이를 나타내는 length 프로퍼티를 갖는다.

```js
num.length // output: 3
```

배열은 인덱스와 length 프로퍼티를 갖기 때문에 반복문(ex. for문)을 통해 순차적으로 요소에 접근이 가능하다.

```js
for (let i = 0; i Array Methods)가 존재한다.

## 유사 배열 객체

유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고, length 프로퍼티를 갖는 객체를 말한다. (참고: ECMAScript: LengthOfArrayLike)

유사 배열 객체는 마치 배열처럼 for문으로 순회할 수도 있다.

```js
const kmj = {
  0: 'kmj',
  1: 'howdy-mj',
  2: 'FE',
  length: 3,
}

for (let i = 0; i arguments, HTMLCollection, NodeList가 있다.

```js
// HTMLCollection
const htmlCollection = document.body.children
```


  
  HTMLCollection


```js
// NodeList
const allDiv = document.querySelectorAll('div')
```


  
  NodeList


언뜻보면 배열과 비슷하게 생겼지만, `Array.isArray()`로 확인해보면 두개 다 false로 나온다.

```js
Array.isArray(htmlCollection) // output: false
Array.isArray(allDiv) // output: false
```

유사 배열 객체는 `Array.prototype.slice.call()`로 배열로 만들 수 있다.

```js
Array.prototype.slice.call(htmlCollection)
Array.prototype.slice.call(allDiv)
```

## 이터러블 객체

Symbol(심벌)은 변경 불가능한 원시 타입이다. 심벌은 중복되지 않는 고유 값을 갖기 때문에 기존 코드에 영향을 주지 않고 새로운 프로퍼티를 추가하기 위해 사용된다. React에서도 JSX를 생성할때 Symbol을 사용하고 있다. (참고: Why Do React Elements Have a \$\$typeof Property?)

이 외, Symbol은 ES6에서 추가된 데이터 타입으로 브라우저 console 창에서도 바로 확인할 수 있다.


  
  Symbol 프로퍼티


이러한 프로퍼티들을 ECMAScript에서는 Well-Known Symbol이라 부르며, 자바스크립트 내부 알고리즘에서 사용된다.

위 이미지에서 볼 수 있듯이, Symbol에는 `Symbol.iterator` 메서드가 있는데, 이는 Array, String, Map, Set, TypedArray, arguments, DOM 컬렉션(NodeList, HTMLCollection)과 같은 이터러블 객체를 `for...of`문으로 순회할 수 있다. 이터러블 객체는 스프레드 문법과 배열 구조 분해가 가능하다.

```js
const num = [1, 2, 3]

// 이터러블 객체
console.log(Symbol.iterator in num) // output: true

// for...of문
for (const n of num) {
  console.log(n) // output: 1 2 3
}

// 스프레드 문법과 배열 구조 분해
console.log([0, ...num]) // output: [0, 1, 2, 3]
```

하지만 유사 배열 객체는 이터러블 객체가 아닌 일반 객체이므로 `for...of`문으로 순회할 수 없고, 배열 구조 분해도 불가하다. 하지만 객체 리터럴 내부에서는 스프레드 문법 사용이 가능하다. (단, arguments, NodeList, HTMLCollection은 유사 배열 객체이면서도 이터러블이다)

```js
const kmj = {
  0: 'kmj',
  1: 'howdy-mj',
  2: 'FE',
  length: 3,
}

// 이터러블 객체
console.log(Symbol.iterator in kmj) // output: false

// for...of문
for (const n of kmj) {
  console.log(n) // output: Uncaught TypeError: kmj is not iterable
}

// 배열 구조 분해
const [0, 1, 2] = kmj; // output: Uncaught SyntaxError: Invalid destructuring assignment target

// 스프레드 문법
console.log({ ...kmj }) // output: {0: "kmj", 1: "howdy-mj", 2: "FE", length: 3}
```

하지만 일반 객체에서도 이터러블 프로토콜을 준수하여 구현한다면 이터러블이 될 수 있다.





**추가할 내용**

- 유사 배열 객체, 이터러블 활용 예제





**참고**



- Advanced Javascript: Objects, Arrays, and Array-Like objects
- 모던 자바스크립트 Deep Dive, 이웅모 (2020)
- What is Array Like Object in JavaScript


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/angular/angular-structure</guid>
      <title>Angular 파일 구조 소개</title>
      <link>https://www.howdy-mj.me/angular/angular-structure</link>
      undefined
      <pubDate>Tue, 18 May 2021 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>angular</category>
      <content:encoded>
최근 Angular 대비 상대적으로 러닝커브가 낮고 사용하기 편한 React, Vue, Svelte 등이 나오면서 Angular의 사용률이 전체적으로 낮아지고 있는 추세다. (참고)

필자도 React만 사용해보다 처음으로 Angular를 사용해봤는데, 확실히 러닝커브가 높은 편이지만 그만큼 매력적인 면도 많다고 생각한다. 본 글에서는 Angular의 특징이나 원칙 등의 원론적인 내용은 제외하고 사용할 때 꼭 알아야 할 내용을 다룬다.

## Angular 설치

```shell
# Angular CLI 설치
$ npm install -g @angular/cli

# Angular 프로젝트 생성
# 본 글에서는 angular routing을 설치했으며, scss를 선택했다
$ ng new 
$ cd 
```

> 본 글에서 @angular/core는 `~11.2.12`, rxjs는 `~6.6.0`, typescript는 `~4.1.5` 버전을 사용했다.

```shell
# 로컬에서 실행 및 창 열기
$ ng serve --open
```


  


잘 실행되었다면, `http://localhost:4200/`에 위와 같은 화면이 보인다.

실행 포트를 바꾸고 싶다면,

```shell
$ ng serve --open --port 4300
```

위 처럼 실행하면 된다.

폴더의 기본 구조는 아래와 같으며, 본 글에서는 `/src/app` 폴더 안에서 필수적으로 알아야 할 것들 위주로 다룬다.


  
  폴더 구조


## Angular 구조

Angular에는 크게 Component(컴포넌트), Template(템플릿), Directive(디렉티브), Service(서비스) 그리고 Module(모듈)이 존재한다.


  
  https://www.ngdevelop.tech/angular/architecture/


Angular 프로젝트를 생성하면 기본으로 만들어지는 모듈과 컴포넌트가 있다. 모듈은 `app-routing.module.ts`와 `app.module.ts`가 있으며, 컴포넌트는 `app.component.html`, `app.component.scss`, `app.component.ts`, `app.component.spec.ts`가 있다.

### 구성 요소 생성 방법

| 생성할 구성 요소       | 명령어                                |
|:----------------| :------------------------------------ |
| 컴포넌트            | ng generate component  |
| 디렉티브            | ng generate directive  |
| 서비스             | ng generate service      |
| 모듈              | ng generate module         |

혹은 Angular Schematics Extension을 설치 한 후, 폴더에서 마우스 우클릭을 해서 component, service, module 등을 만들 수 있다.


  
  생성


### NgModule(Module)

NgModule은 Angular에서 가장 중요한 구성 요소로 관련 있는 다른 요소를 묶는 역할을 한다. NgModule에는 사용할 컴포넌트나 서비스 프로바이더 등이 포함할 수 있으며, 외부로 공개(공유)할 지 아니면 다른 곳에서 해당 NgModule로 가져와 사용할 지 등을 정할 수 있다.

모든 Angular 프로젝트에는 **반드시 하나 이상의 모듈이 존재**하며, 그 중 보통 AppModule (`app.module.ts`)이 단 하나의 최상위 모듈이다. 프로젝트 규모가 작으면 AppModule 하나만 있는 경우도 있다. React의 `App.js`와 비슷하다.

src/app/app.module.ts

```ts
import { NgModule } from '@angular/core'
import { BrowserModule } from '@angular/platform-browser'

import { AppRoutingModule } from './app-routing.module' // routing 설치 시 생성
import { AppComponent } from './app.component'

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule, AppRoutingModule],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {}
```

새로 생성된 컴포넌트는 하나의 NgModule에서 불러와야 사용할 수 있다.

- **declarations**: 해당 모듈에 포함될 구성요소(컴포넌트나 디렉티브, 파이프)의 리스트를 선언한다.
- **exports**: 해당 모듈의 컴포넌트나 디렉티브을 다른 모듈에서 사용하고 싶을 때 작성. AppModule(최상위 모듈)에는 존재하지 않는다.
- **imports**: FormsModule, AppRoutingModule 등과 같은 외부 모듈(혹은 라이브러리)을 사용하고 싶을 때 추가한다. 외부 모듈은 앵귤러 모듈일수도 있고, 사용자가 정의한 모듈일수도 있다.
- **providers**: 모듈 내에 생성된 서비스 프로바이더를 작성한다. injector가 여기에서 서비스의 존재를 알아 차릴 수 있다.
- **bootstrap**: 프로젝트의 진입점으로 최상위 컴포넌트(일반적으로 app.module.ts)에만 작성한다.



### Component

AppComponent를 보면 네 개의 파일이 존재한다.

- app.component.html: HTML 템플릿 파일
- app.component.scss: SCSS 파일 (기본은 CSS 파일)
- app.component.ts: 컴포넌트 파일 (TypeScript)
- app.component.spec.ts: 테스트 파일

src/app/app.component.ts

```ts
import { Component } from '@angular/core'

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss'],
})
export class AppComponent {
  title = 'rxjs-angular' // 처음에 설정한 프로젝트명이 title의 기본값으로 설정
  // 컴포넌트 클래스 영역
}
```

@Component 데코레이터에는 메타데이터 객체를 인자로 전달하며, 컴포넌트 생성에 필요한 정보를 담고 있다.

- **selector**: HTML 템플릿의 이름이며, 다른 템플릿에서 ``으로 import 할 수 있다.
- **templateUrl**: 해당 컴포넌트의 HTML 템플릿과 매핑한다.
- **styleUrls**: 해당 컴포넌트의 스타일 파일과 매핑한다.

혹은 HTML 템플릿과 CSS를 따로 파일로 만들지 않고, template, styles를 이용해 ts 파일에 바로 만들 수도 있다.

```ts
import { Component } from '@angular/core'

@Component({
  selector: 'app-root',
  template: `
    {{ title }}
  `,
  styles: [
    `
      h1 {
        color: red;
      }
    `,
  ],
})
export class AppComponent {
  title = 'Angular 구조 및 사용법' // 제목 변경
  // 컴포넌트 클래스 영역
}
```

컴포넌트 클래스 영역은 해당 컴포넌트 뷰를 관리하기 위한 로직을 담은 클래스를 정의한다. 여기에는 프로퍼티, 메서드 그리고 input/output 이벤트와 ngOnInit, ngOnDestroy 등과 같은 라이프싸이클 메서드를 작성할 수 있다. 라이프싸이클은 아래에서 다시 살펴보도록 하자.



### Service

서비스는 주로 쿠키나 스토리지, 채널톡, 카카오톡 상담, 모달 등 어느 컴포넌트에서든 사용할 수 있는 공통 로직을 작성한다.

```ts
@Injectable()
export class ExampleService {
  // ...
}
```

그리고 @Injectable 데코레이터틀 작성하여 데이터 공유 클래스와 비즈니스 로직으로 동시에 사용이 가능하다.



### Directive

Angular가 제공하는 디렉티브는 크게 어트리뷰트 디렉티브(Attribute Directive)와 구조 디렉티브(Structural Directive)로 나뉜다.

디렉티브는 DOM의 모든 것을 직접 관리할 수 있다. HTML 요소 또는 어트리뷰트의 형태로 사용하여 디렉티브가 사용된 요소에게 무언가를 하라는 지시(directive)를 전달한다. 디렉티브는 프로젝트 전역에서 사용할 수 있는 공통 관심사를 컴포넌트에서 분리한 것으로 구현하여 컴포넌트의 복잡도를 낮추고 가독성을 향상시킨다.

#### 어트리뷰트 디렉티브

- NgClass: CSS 클래스 추가/제거
- NgStyle: HTML 스타일 추가/제거
- NgModel: HTML 폼 요소에 양방향 데이터 바인딩 추가

#### 구조 디렉티브

- NgIf: 조건에 따라 DOM에 추가/제거
- NgFor: 배열 항목마다 DOM에 추가
- NgSwitch: 조건에 맞는 것을 선택해서 DOM에 추가



기본으로 내장되어 있는 것 외, 사용자가 직접 만들어 쓸 수도 있다. 글자의 색상을 파란색으로 바꾸는 디렉티브를 만들어보자.

```shell
# 명령어 실행 후, 자동으로 app.module.ts의 declarations에 추가 됨
$ ng generate directive blueText
```

src/app/shared/blue-text.directive.ts

```ts
import { Directive, ElementRef } from '@angular/core'

@Directive({
  selector: '[blueText]',
})
export class BlueTextDirective {
  constructor(el: ElementRef) {
    el.nativeElement.style.color = 'blue'
  }
}
```

```html
{{ title }}

blue title: {{ title }}
```


  


잘 적용되었다면 위처럼 파란색으로 바뀐 것을 알 수 있다.



### Pipe

파이프(pipe)는 템플릿에서 사용되며, 화면에 표시하는 형식만 변경하고 싶을 때 사용한다.

```shell
$ ng generate component components/pipe
```

src/app/components/pipe/pipe.component.ts

```ts
import { Component, OnInit } from '@angular/core'

@Component({
  selector: 'app-pipe',
  templateUrl: './pipe.component.html',
  styleUrls: ['./pipe.component.scss'],
})
export class PipeComponent implements OnInit {
  now = new Date()

  constructor() {}

  ngOnInit(): void {}
}
```

src/app/components/pipe/pipe.component.html

```html
{{ now }}


{{ now | date }}


{{ now | date: "y년 MM월 dd일" }}

```

날짜 외에도, 화폐, 대소문자, 소숫점, 퍼센트, 비동기 등의 pipe가 있다.

```html
{{ 'howdy-mj' | uppercase }}


{{ 10000 | currency }}



{{ 1.2345 | number: "1.2-2" }}

{{ 1.2345 | number: "3.2-2" }}


{{ 0.1234 | percent }}

{{ 0.1234 | percent: "2.1" }}

```

더 자세한 건 공식문서의 Pipe API List를 참고하면 된다.





**참고**



- [Angular](https://angular.io/)
- [Angular Architecture](https://www.ngdevelop.tech/angular/architecture/)


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/rxjs/reactive-programming-and-rxjs</guid>
      <title>반응형 프로그래밍과 RxJS</title>
      <link>https://www.howdy-mj.me/rxjs/reactive-programming-and-rxjs</link>
      undefined
      <pubDate>Sun, 02 May 2021 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>rxjs</category>
      <content:encoded>

  해당 글은 Angular를 사용하면서 반응형 프로그래밍, RxJS에 대해 궁금한 것을 작성한 글입니다.
  오역이 있을 수 있습니다. 피드백은 언제나 환영합니다:)




대부분 어플리케이션에는 비동기 작업 처리가 필수다. 그리고 그 어플리케이션의 규모가 커지면서 많은 양의 데이터를 처리해야 하는데, 데이터를 가공하고 올바른 시점에 데이터를 반환하게 하기 위해 코드가 점점 더 복잡해질 수 있다.

이런 복잡한 데이터를 처리하기 위해 반응형 프로그래밍(Reactive Programming)이 등장하였다.

## 반응형 프로그래밍(Reactive Programming)

위키피디아에서 반응형 프로그래밍은 데이터 스트림과 변화의 전파(propagation of change)와 관련된 선언형 프로그래밍(Declarative Programming) 패러다임이다. 해당 패러다임으로 정적(ex. arrays), 동적(ex. 이벤트 이미터) 데이터 스트림을 쉽게 표현할 수 있으며, 변경된 데이터의 흐름 전달이 용이하다.

RxJS의 컨트리뷰터 André Staltz는 Reactive programming is programming with asynchronous data streams, 즉 반응형 프로그래밍을 비동기 데이터 스트림을 이용한 프로그래밍이라 정의했다.

여기서 데이터 스트림은 키 입력, 마우스, 터치, HTTP 호출 등의 이벤트를 뜻한다. 그리고 명령형 프로그래밍(Imperative Programming)이 어떤 방식으로 하는지(How)에 알려준다면, 선언형 프로그래밍(Declarative Programming)은 무엇(What)과 같은지를 반환하여, 반응형 프로그래밍은 데이터가 어떤 값으로 변경되는지 직관적으로 보여준다.

간단한 수식으로 명령형 프로그래밍과 반응형 프로그래밍을 비교해 보자.

```js
// 명령형 프로그래밍
let b = 1
let c = 2
let a = b + c
console.log(a) // 3
b = 10
console.log(a) // 3 ('=' 연산자 이전의 b, c 값으로 a를 반환)

// 반응형 프로그래밍
// '$'는 참조되는 값이 변경되면 실시간으로 해당 값을 따른다
let b = 1
let c = 2
let a$ = b + c
console.log(a$) // 3
b = 10
c = 5
console.log(a$) // 15 ('=' 연산자 이후에 변경된 b, c 값으로 a를 반환)
```

반응형 프로그래밍에서 `$`는 스트림을 가리키는 변수를 한정하는 데 사용하며, 변경 된 값을 실시간으로 참조한다.



그렇다면 Rx(Reactive eXtension)는 무엇일까?

공식 문서에서 Rx는 옵저버블 스트림을 사용하는 비동기 프로그래밍용 API(An API for asynchronous programming
with observable streams)라고 정의하고 있다.

## Observable

Rx를 설명하는데 가장 핵심이 되는 단어가 바로 Observable(옵저버블)인데, 공식문서에서 이를 여러 개의 값을 Push하는 것으로 정의하고 있다.


  
  https://rxjs-dev.firebaseapp.com/guide/observable


### Pull vs. Push

Pull과 Push는 두개의 다른 프로토콜로, 데이터 생산자(Data Producer)와 데이터 소비자(Data Consumer)가 통신하는 방법을 제공한다.

처음에는 데이터 생산자가 서버, 데이터 소비자가 클라이언트인줄 알았다. 하지만 Rx 내에서 말하는 생산자는 데이터 변경을 수행하는 이벤트, 소비자는 데이터 변경 이벤트를 처리하는 것이다.

|          |                     생산자                      |               소비자                |
| :------: | :---------------------------------------------: | :---------------------------------: |
| **Pull** |        Passive: 요청이 올때 데이터 생산         | Active: 데이터가 언제 요청될지 결정 |
| **Push** | Active: 자신의 페이스(phase)에 맞춰 데이터 생산 |     Passive: 받은 데이터에 반응     |


  * Pull은 function, iterator를 Push는 Promise, Observable을 말한다.
  * Passive는 이벤트를 기다리는 수동적인 상태, Active는 이벤트를 발동시키는 능동적인 상태를 나타내는 것으로 추측한다.



  
  https://livebook.manning.com/book/rxjs-in-action/chapter-2/164




#### Pull

Pull은 소비자가 언제 생산자에서 데이터를 받아올지 결정한다. 생산자는 언제 소비자에게 데이터를 전달해야 하는지 모른다.

자바스크립트의 모든 함수는 Pull에 해당한다. 함수는 데이터의 생산자이며, 함수를 호출하는 코드는 단일 반환 값을 '꺼냄'(pull)으로써 데이터를 소비한다.

ES2015에서 소개 된 제너레이터 함수와 이터레이터(function\*) 역시 pull에 해당한다. iterator.next()은 소비자로 여러 개의 값을 iterator(생산자)에서 '꺼낸다'(pull).

어떠한 조건 혹은 소비자 값에 따라 이벤트가 발동(active)되며, 이 때 생산자를 호출(passive)한다.

#### Push

Push는 생산자가 언제 소비자에게 데이터를 보낼지 결정하며, 소비자는 언제 데이터를 받을지 모른다.

Promise는 자바스크립트에서 가장 많이 쓰이는 Push다. Promise(생산자)는 callback(소비자)에서 나온 값을 전달하고, 함수와 다르게 언제 해당 callback 값을 보낼지(push) 결정한다.

RxJS에서는 Observable이라는 새로운 Push를 내보였다. Observable은 여러 값의 생산자로 값들을 Observer(소비자)에게 보낸다(push).

생산자가 변화를 감지하고 이벤트를 발동(active)시키며, 이벤트 처리는 소비자(passive)에게 맡긴다. 이때 데이터 스트림은 생산자에서 소비자로만 이동하며 다른 방향으로 이동하지 않는다. 즉, RxJS와 관련된 스트림은 항상 업스트림 Observable에서 다운스트림 Observer로 흐른다.


  
  https://livebook.manning.com/book/rxjs-in-action/chapter-1/147


### 정리

- Function은 호출할 때, 단일 값을 동기적으로 반환하는 느긋한 계산법이다.
- Iterator는 반복(iteration)할 때, 0에서 (잠재적으로) 무한 값을 동기적으로 반환하는 느긋한 계산법이다.
- Promise는 단일 값을 반환할 수 있는(혹은 반환하지 않을 수 있는) 계산법이다.
- Observable은 동기 또는 비동기적으로 호출될 때부터 0에서 (잠재적으로) 무한대의 값을 반환할 수 있는 느긋한 계산법이다.


  * 느긋한 계산법(Lazy evaluation, 혹은 지연 평가)은 계산의 결과값이 필요할 때까지 계산을 늦추는 기법이다. 값을 미리 저장하지 않아 공간을 절약할 수 있고, 값이 꼭 필요할 때만 계산하기 때문에 성능에도 좋은 영향을 준다.




즉, Observable은 서버가 클라이언트에게 데이터를 보내주며 해당 값을 UI 단에 실시간으로 반영할 수 있게 도와준다.

## Promise vs. Observable

RxJS를 써보지 않은 상태에서 위의 내용만 봤을 때, Promise와 Observable이 얼마나 다른지 와닿지 않는다. 본 글에서는 두 개의 작동 방식 차이만 알아보고, 다음 글에서 아래에 나온 메서드들을 자세히 다룰 예정이다.

### 실행 시점

- Promise는 객체를 생성할 때 바로 실행되어 즉시 로딩(eager)이라 부른다. 모든 `then()`은 같은 계산 값을 공유한다.

```js
// 최초 실행 (생성 및 실행)
let promise =
  new Promise() 
  ((resolve, reject) => {
    // ...
  })
promise.then(value => {
  // 결과 처리
})
```

- Observable은 소비자가 구독(subscription)하기 전까지는 실행되지 않아 지연 로딩(lazy)이라 부른다. `subscribe()`는 여러 번 호출될 수 있으며, 각각의 구독은 모두 자신만의 계산 값을 갖고 있다.

```js
import { Observable } from 'rxjs'
// 선언 (생성)
const observable$ =
  new Observable() 
  (observer => {
    // ...
  })

// 최초 실행 (구독)
observable$.subscribe(value => {
  // observer 처리
})
```

### return 개수

- Promise는 하나만 보낼 수 있으며, 여러 개 보낼 경우 나중에 보낸 건 무시된다.

```js
const promise = new Promise(resolve => {
  resolve(1)
  resolve(2) // 무시
})
promise.then(console.log) // output: 1
```

- Observable은 데이터를 여러 개 보낼 수 있다.

```js
const observable$ = new Observable(observer => {
  observer.next(1)
  observer.next(2)
})
observable$.subscribe(console.log) // output: 1 2
```

### 조작과 반환

- Promise는 `then()` 하나로 데이터의 조작과 반환을 같이 진행한다.

```js
promise.then(v => 2 * v)
```

- Observable은 데이터의 조작과 구독(반환)을 나눌 수 있다. 오직 구독자가 있을 때만 subscriber 함수가 실행되어 값을 계산한다. 다른 곳에서 데이터를 복잡하게 가공해야 한다면 Observable이 더 효율적이다.

```js
observable$.pipe(map(v => 2 * v))
```

### 취소(해제)

- Promise는 실행 도중에 취소할 수 없지만, Observable은 구독을 취소(해제)할 수 있다. 구독 취소는 이벤트 리스터가 받을 값을 제거하고, subscriber 함수에게 취소하라고 알린다.

```js
const subscription = observable$.subscribe(() => {
  // ...
})
subscription.unsubscribe()
```

### 에러 처리

- Promise는 `then()`이나 `catch()`를 사용하는데, 위치에 따라 에러를 처리하는 로직이 달라져야 한다.

```js
promise
  .then(() => {
    throw new Error('my error')
  })
  .catch(error => {
    alert(error)
  })
```

- Observable은 `subscribe()`는 에러도 함께 처리할 수 있으며, 자동으로 구독을 취소한다. Observable은 에러 처리 로직을 한 군데에 집중할 수 있다.

```js
observable$.subscribe(() => {
  throw new Error('my error')
})
```

## Observable는 동기, 비동기 모두 처리 가능하다

Observable이 Promise와 비슷한 선상에서 이야기를 나누고 있기 때문에, Observable도 비동기로만 처리할 수 있다고 생각이 들 수 있다. 하지만 예상과 다르게 Observable은 동기, 비동기 모두 처리가 가능하다.

아래에 같은 동작을 하는 일반 함수와 Observable이 존재한다.

```js
// 일반 함수
function foo() {
  console.log('Hello')
  return 42
}

const x = foo()
console.log(x) // output: "Hello" 42
```

```js
// Observable
import { Observable } from 'rxjs'

const foo$ = new Observable(subscriber => {
  console.log('Hello')
  subscriber.next(42)
})

foo$.subscribe(x => {
  console.log(x) // output: "Hello" 42
})
```

만약, 일반 함수로 만든 `foo()`를 다른 console 사이에 둘 경우 아래와 같이 값이 출력 된다.

```js
console.log('before')
console.log(foo())
console.log('after')

// output:
// "before"
// "Hello"
// 42
// "after"
```

이를 Observable인 `foo()`로 실행하여도 똑같은 값이 출력된다.

```js
console.log('before')
foo$.subscribe(x => {
  console.log(x)
})
console.log('after')

// output:
// "before"
// "Hello"
// 42
// "after"
```

그렇다면 함수와 Observable의 차이는 무엇일까? 그건 바로 **Observable은 여러 개의 값을 return할 수 있다**는 것이다.

일반적으로 함수는 return을 두 번이상 사용할 수 없다. 만약 사용할 경우 무시된다.

```js
function foo() {
  console.log('Hello')
  return 42
  return 100 // 무시
}
```

하지만 Observable은 가능하다.

```js
const foo$ = new Observable(subscriber => {
  console.log('Hello')
  subscriber.next(42)
  subscriber.next(100) // 두 번째 return
  subscriber.next(200) // 세 번째 return
})

console.log('before')
foo$.subscribe(x => {
  console.log(x)
})
console.log('after')

// output:
// "before"
// "Hello"
// 42
// 100
// 200
// "after"
```

그리고 이 값을 비동기로도 반환할 수 있다.

```js
const foo$ = new Observable(subscriber => {
  console.log('Hello')
  subscriber.next(42)
  subscriber.next(100)
  subscriber.next(200)
  setTimeout(() => {
    subscriber.next(300) // 비동기로 값이 반환
  }, 1000)
})

console.log('before')
foo$.subscribe(x => {
  console.log(x)
})
console.log('after')

// output:
// "before"
// "Hello"
// 42
// 100
// 200
// "after"
// 300
```

Observable은 나중에 다른 글에서 더 자세하게 작성할 예정이다.

## RxJS의 이점

- for, while 등 반복문에서는 비동기를 인식하지 못하는 문제(주로 반복 사이의 지연 시간 또는 대기 시간을 인식하지 못함)를 해결할 수 있다.
- 각 콜백 내에서 try/catch 블록을 중첩할 경우 코드가 금방 복잡해지는데, 이를 깔끔하게 작성할 수 있다.
- 비즈니스 로직을 실행해야 할 경우, 중첩된 콜백 구조가 아닌 데이터 흐름을 파악할 수 있는 코드 작성이 가능하다.
- 이벤트 또는 장기 실행 작업이 멋대로 작동되어 취소해야 할 때, 미리 정한 시간이 지나면 이벤트를 자동으로 취소할 수 있다.
- 스로틀링, 디바운싱을 사용하여 프로그램에 전반적으로 안정성을 줄 수 있다.
- UI 단에서 발생하는 이벤트들의 메모리 누수와 브라우저 프로세스의 크기를 제어할 수 있다.

## 번외) 함수형 프로그래밍(Functional Programming)

공식문서에서 'Rx는 옵저버 패턴, 이터레이터 패턴 그리고 함수형 프로그래밍(Functional Programming)을 조합하여 이벤트 시퀀스를 이상적으로 관리할 수 있다'고 정의하고 있다.

> ReactiveX combines the Observer pattern with the Iterator pattern and functional programming with collections to fill the need for an ideal way of managing sequences of events.

이 중, 반응형 프로그래밍은 함수형 프로그래밍을 기반으로 구축되어 Rx에서 가장 중요한 개념이라 볼 수 있다. 본 글에서 함수형 프로그래밍에 대해서만 간략하게 다뤄보겠다. (추후 다른 글에서 따로 작성할 예정이다)


  - 옵저버 패턴은 객체의 상태 변화를 관찰하는 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴이다.
  - 이터레이터 패턴은 객체 지향 프로그래밍에서 반복자(iterator)를 사용하여 내부에 있는 요소들을 노출시키지 않고 접근하는 디자인 패턴이다. 반복 자체에서 강 요소에 적용된 비즈니스 로직을 분리하는 데 효과적이다.


### 함수형 프로그래밍 특징

#### - 부가작용이 없다(Side effect free)

- 반드시 하나 이상의 인자(입력)를 받고, 항상 같은 결과 값을 반환하는 순수 함수이다.
- 함수 범위는 인수와 그 안에 선언된 모든 지역 변수로 구성되며, 이 외의 작업(외부 변수 수정, console 출력, HTML 페이지 요소 렌더링 등)은 부가 작용으로 간주하여 피하거나 최소한으로 격리해야 한다.



#### - 명령형(Imperative)이 아닌 선언형(Declarative)이다.

- 명령형 프로그램은 원하는 결과를 얻기 위해 특정 단계를 설명하는 코드(ex. for, if, switch 등)를 사용하는 반면, 선언형 프로그램은 흐름 제어를 추상화하고 데이터 흐름을 설명하는 코드(ex. map, filter 등)를 사용한다.

#### - 불변성(Immutable)

- 데이터를 생성하거나 변수가 선언된 후, 이를 변경하거나 수정하지 않는다.
- 데이터 변경이 필요한 경우, 원본 데이터의 복사본을 만들어 수정 작업을 진행한다.

#### - 고차함수를 통한 재사용(HoF)

- 함수에 함수를 파라미터로 전달할 수 있으며, 함수의 반환값으로 함수를 사용할 수 있다.
- 콜백 함수, 프로미스, 모나드 등을 사용하여 액션, 효과 또는 비동기 흐름을 추상화하거나 분리시킨다.



**참고**



- ReactiveX
- RxJS
- RxJS 반응형 프로그래밍, 2019
- Observable vs. Promise
- 5 Things to Know About Reactive Programming
- JavaScript Theory: Promise vs Observable
- 번역 - 함수형 프로그래밍이란 무엇인가?


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/javascript/why-does-typeof-function-return-function</guid>
      <title>왜 함수의 타입은 object가 아닌 function을 반환할까?</title>
      <link>https://www.howdy-mj.me/javascript/why-does-typeof-function-return-function</link>
      undefined
      <pubDate>Thu, 15 Apr 2021 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>javascript</category>
      <content:encoded>
자바스크립트에는 크게 원시 타입(Primitive Type), 참조 타입(Reference Types)으로 분류된다. 내가 갖고 있는 데이터가 정확히 어떤 타입인지 알고 싶으면 `typeof` 메서드를 사용하는데, 이때 원시 타입은 그대로 타입이 반환 되지만 참조 타입은 그렇지 않았다.

맨 처음 자바스크립트를 공부했을 때 가장 의아했던 점 중 하나였다.

가령 배열의 `map()`을 돌려야해서, 배열로 잘 들어왔는지 확인해보고싶어서 `typeof`를 사용했지만, 결과는 object로 나올 뿐이었다. 조금 공부하다보니, 자바스크립트의 참조타입은 모두 객체이기 때문에 object라 반환되었던 것이었다. 때문에 MDN에서도 이를 참조 타입이 아닌 객체(Objects)라 정의하고 있는 것 같다.

하지만 그 중에서도 함수만은 달랐다. 그 어떠한 함수의 형태를 쓰더라도 항상 function이 반환됐다.

```js
typeof [] // output: 'object'
typeof {} // output: 'object'
typeof new Date() // output: 'object'
typeof function() {} // output: 'function'
```

처음에는 function 키워드 때문일거라 생각을 했지만, function 키워드를 쓰지 않는 화살표 함수 역시 타입이 function으로 나왔다.

```js
const arrFunc = () => {}
typeof arrFunc // output: 'function'
```

그리고 생성자 함수에 의해 만들어진 객체도 함수만 타입이 object가 아닌 function으로 반환된다.

```js
typeof new String('a') // output: 'object'
typeof new Number(123) // output: 'object'
typeof new Boolean(true) // output: 'object'
typeof new Array(1, 2, 3) // output: 'object'
typeof new Object() // output: 'object'
typeof new Function('x', 'return x') // output: 'function'
```

도대체 왜 자바스크립트에서 함수만 타입을 제대로 반환해주는 걸까?



이를 대답하기 위해서 다시 한 번 강조해야 할 것은, 함수도 객체라는 점이다. 그리고 자바스크립트에서 모든 객체는 내부 슬롯(internal slot)과 내부 메서드(internal method)를 갖는다.

### 내부슬롯과 내부 메서드

ECMA-262에 따르면, 내부 슬롯과 내부 메서드는 자바스크립트의 구현 알고리즘을 위해 존재하며, 개발자들이 직접 접근할 수 없다.

내부 메서드는 다형성을 띄우며, 각기 다른 객체 값이 다른 알고리즘을 수행할 수 있으며, 만약 해당 객체에서 지원하지 않는 메서드를 실행할 경우 **TypeError**를 반환한다.
내부 슬롯은 객체와 연결되고 다양한 ECMAScript 규격 알고리즘에 사용되는 내부 상태(state)이다. 내부 슬롯은 객체 프로퍼티가 아니며, 상속되지 않는다. 또한 명시되지 않는한, 내부 슬롯은 객체를 생성하는 과정 중 하나이며 동적으로 추가될 수 없으며, 초기 값은 **undefined**이다.

자바스크립트에서 모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다. 그리고 이는 직접 접근이 불가하며 \_\_proto\_\_틑 통해 간접 접근할 수 있다. (이전글: [[Prototype]], \_\_proto\_\_와 prototype)

자바스크립트 객체의 필수 내부 메서드는 [[GetPrototypeOf]], [[SetGPrototypeOf]], [[IsExtensible]], [[PreventExtensions]], [[GetOwnProperty]], [[DefineOwnProperty]], [[HasProperty]], [[Get]], [[Set]], [[Delete]], [[OwnPropertyKeys]]가 있다.

## 함수의 내부 메서드

함수도 객체이므로 일반 객체와 동일하게 동작하여 위에 언급한 일반 객체의 내부 슬롯과 내부 메서드 모두를 갖고 있다.

하지만 함수는 일반 객체와 다르게 **'호출이 가능'**하다. 함수 객체는 함수로서 동작하기 위해 함수 객체만을 위한 [[Environment]], [[FormalParameters]] 등의 내부 슬롯과 [[Call]], [[Construct]] 같은 내부 메서드를 추가로 갖고 있다. (ECMA-262: 함수 객체의 내부 메서드)



### 자바스크립트에서 함수를 인지하는 단계

자바스크립트에서 `typeof`를 할 때, 해당 객체 안에 [[Call]]이란 내부 메서드가 있으면 function으로 반환되는 것을 알았다.

그렇다면 다시 의문점이 생긴다. 도대체 자바스크립트는 어떻게 함수 객체를 만들 때, 다른 객체와 다르게 함수인걸 인지하고 [[Call]]을 생성해주는 걸까?

ECMA-262의 [[Call]] 내용을 읽어보니, 해당 객체가 **함수 정의 방법**을 통해 실행 되었을 때 [[Call]]이 호출된다. 그리고 [[Construct]]는 객체를 생성할 때, **super**나 **new** 연산자가 실행되었을 때 호출된다.

함수 정의 방법에는 함수 선언문, 함수 표현식, Function 생성자 함수 그리고 화살표 함수 이렇게 크게 4가지가 존재한다.

```js
// 1. 함수 선언문
function hello(name) {
  return `Hello ${name}`
}

// 2. 함수 표현식
const hello = function(name) {
  return `Hello ${name}`
}

// 3. Function 생성자 함수
const hello = new Function('name', 'return name')

// 4. 화살표 함수
const hello = name => `Hello ${name}`
```

_(결국은 function 키워드 일것이란 생각이 어느정도 맞았다...)_



### [[Call]]과 [[Construct]]

내부 메서드 [[Call]]을 갖는 함수 객체는 callable이라 하며, 내부 메서드 [[Construct]]를 갖는 함수 객체를 constructor, [[Construct]]를 갖지 않는 함수 객체를 non-constructor라고 부른다.

```js
function func() {}

// 1. [[Call]]를 갖는 callable 함수 객체
func()

// 2. [[Construct]]를 갖는 함수 객체
new func()
```

즉, 함수 객체는 모두 callable하여 호출할 수 있지만, constructor와 non-constructor로 나뉘어 생성자 함수로서 호출 여부는 갈린다.

#### constructor와 non-constructor

함수 객체를 정의하는 방식에 따라 두 개로 나뉜다.

- constructor: 함수 선언문, 함수 표현식, 클래스
- non-constructor: 화살표 함수, 메서드(ES6 메서드 축약 표현)

즉, ES6 이전의 모든 함수는 일반 함수로 호출 가능한 callable이면서도, 생성자 함수로 호출할 수 있는 constructor이다.

```js
const a = function() {}
const b = function b2() {}
const c = () => {}

typeof a // output: 'function'
typeof b // output: 'function'
typeof c // output: 'function'

a.prototype // // output: { constructor: f }
b.prototype // // output: { constructor: f }

// c는 non-constructor이기 때문에 .prototype이 나타나지 않으며,
// 생성자 함수로서의 호출이 불가하다.
const arrowC = new c() // output: Uncaught TypeError: c is not a constructor
```

## 객체의 타입을 알고 싶을 땐 어떻게 해야하는가?

`typeof`를 쓰면 함수를 제외한 객체는 object로 반환되는 것을 확인했다.

그렇다면 만약 객체에서 해당 객체의 실제 타입을 알고 싶다면 어떻게 해야할까?

이는 `instanceof` 메서드를 사용하면 알 수 있다. `instanceof`는 해당 값의 프로토체인을 타고 올라가 그 위 객체의 타입을 반환해준다.

```js
const func = a => a
func instanceof Function // true
func instanceof Object // true

const arr = []
arr instanceof Array // true
arr instanceof Object // true

const obj = {}
obj instanceof Object // true

const current = new Date()
current instanceof Date // true
current instanceof Object // true
```





**추후 추가할 내용**

- constructor, non-constructor의 실질적인 차이





**참고**



- ECMAScript 2020
- 모던 자바스크립트 Deep Dive, 이웅모 (2020)
- Why does typeof function return “function”?
- What are “Internal Slots” and “Internal Methods” in JavaScript?


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/javascript/prototype-and-proto</guid>
      <title>프로토타입: [[Prototype]], __proto__, prototype 프로퍼티</title>
      <link>https://www.howdy-mj.me/javascript/prototype-and-proto</link>
      undefined
      <pubDate>Sat, 03 Apr 2021 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>javascript</category>
      <content:encoded>

마지막 업데이트: 2021.08.31




> 자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어다.



클래스의 가장 큰 특징은 상속이다. 상속은 객체지향 프로그래밍의 핵심 개념으로, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 그대로 사용할 수 있는 것을 말한다.

자바스크립트는 ES6에서 Class(이하 클래스)가 도입되었지만 프로토타입 기반 언어라, 다른 언어에서 사용되는 클래스와 동작 방식이 약간 다르다.

```js
// 클래스의 상속
function Greeting(name) {
  this.name = name;
  this.hello = function () {
    console.log(`hello ${this.name}`);
  };
}

const mj = new Greeting('mj');
mj.hello(); // output: hello mj
```

하지만 새로운 클래스를 생성할 때마다 모두 `hello` 함수를 갖고 있어 메모리가 낭비된다.

이때 자바스크립트는 프로토타입을 기반으로 상속을 구현하여, 새로운 클래스 몇 개를 만들든 하나의 `hello` 함수를 사용하여 불필요한 중복을 제거할 수 있다.

```js
// 자바스크립트 프로토타입 기반의 상속
function Greeting(name) {
  this.name = name;
}

Greeting.prototype.hello = function () {
  console.log(`hello ${name}`);
};

const mj = new Greeting('mj');
mj.hello(); // output: hello mj
```

그렇다면 **프로토타입**이 정확히 무슨 뜻일까?

## 프로토타입(prototype) 객체

ECMA-262에서 prototype은 **object that provides shared properties for other objects**로, 다른 객체에 공유 프로퍼티(메서드 포함)를 제공하는 객체이다.

모든 객체는 `[[Prototype]]`이라는 내부 슬롯(자바스크립트 엔진의 내부 로직)을 갖으며, 상속을 구현하는 프로토타입 객체를 가리킨다.


  
  모던 자바스크립트 Deep Dive, 이웅모


하지만 `[[Prototype]]` 내부 슬롯에는 직접 접근이 불가하다. 이는 프로토타입 체인의 단방향을 지키기 위해서다. 만약 직접 접근가능하다면, 서로가 서로의 프로토타입이 되면서 프로토타입 체인이 무한으로 돈다. 따라서 `__proto__` 프로퍼티로만 접근할 수 있다.

```js
const a = {};
const b = {};

a.__proto__ = b;
b.__proto__ = a; // Uncaught TypeError: Cyclic __proto__ value
```

### \_\_proto\_\_

모든 객체는 `__proto__`를 통해 자신의 프로토타입(`[[Prototype]]` 내부 슬롯)에 접근할 수 있다.


  
  hello.__proto__


ES6에서 `__proto__`를 표준으로 채택되었다. 하지만 여전히 코드 내에서 `__proto__`보다는 `Object.getPrototypeOf()`의 사용을 권장한다.

```js
const hello = { name: 'kmj' };
Object.getPrototypeOf(hello);
// {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}
```



### 함수 객체의 prototype 프로퍼티

`prototype` 프로퍼티는 생성자 함수로 호출할 수 있는 객체, 즉 constructor를 소유하는 프로퍼티다. 일반 객체와 생성자 함수로 호출할 수 없는
non-constructor에는 `prototype` 프로퍼티가 없다.

```js
// 함수 객체는 prototype 프로퍼티가 있음
function func() {}
func.hasOwnProperty('prototype'); // output: true

// 일반 객체는 prototype 프로퍼티가 없음
const obj = {};
obj.hasOwnProperty('prototype'); // output: false
```

단, 화살표 함수와 ES6 메서드 축약 표현으로 정의된 메서드는 non-constructor로 `prototype` 프로퍼티가 없다.

```js
// 화살표 함수
const arrowFunc = () => {};
arrowFunc.hasOwnProperty('prototype'); // output: false

// ES6 축약 메서드
const es6 = {
  test() {},
};
es6.test.hasOwnProperty('prototype'); // output: false
```

## 생성자 함수와 프로토타입

생성자 함수에 의해 생성된 객체는 constructor 프로퍼티를 통해 생성자 함수와 연결된다.

```js
function Person(name) {
  this.name = name;
}
const me = new Person('kmj'); // Person 생성자로 만들어진 me 객체
me.constructor === Person; // output: true
```

생성자 함수로 생성한 것이 아닌, 리터럴 표기법으로 생성하여도 constructor 프로퍼티가 연결된다.

```js
const person = function (name) {
  this.name = name;
};
person.constructor === Function; // output: true
```

이처럼 리터럴 표기법에 의해 생성된 객체도 상속을 위해 프로토타입이 필요하며, 이는 곧 constructor 프로퍼티와 연결된다. 즉, **프로토타입과 생성자 함수는 늘 함께 존재**한다.



### 추상 연산 OrdinaryObjectCreate

객체를 생성하는 방식에는 `객체 리터럴`, `Object 생성자 함수`, `생성자 함수`, `Object.create 메서드`, `클래스` 등 다양한 방법이 존재한다.

세부적인 생성 방식에는 차이가 있으나, 모두 추상 연산 OrdinaryObjectCreate에 의해 생성된다는 공통점이 있다.

```js
OrdinaryObjectCreate(proto [ , additionalInternalSlotsList ])
```

추상 연산 **OrdinaryObjectCreate**는 proto(객체 혹은 null)와 선택 인자 *additionalInternalSlotsList*를 받아 런타임에 새로운 객체(ordinary objects)를 만든다. *additionalInternalSlotsList*이 있다면, 전달받은 프로토타입(프로퍼티)을 자신이 생성한 객체의 `[[Prototype]]` 내부 슬롯에 할당 한 후, 생성한 객체를 반환한다. 여기서 전달되는 인수는 객체가 생성되는 시점에 객체 생성 방식에 의해 결정된다.

#### 추상 연산(Abstract Operations)이란?

추상 연산은 ECMAScript의 일부가 아닌, ECMAScript 언어의 상세를 돕기 위해 정의된 것이다. 해당 규격은 다른 알고리즘 내에서 참조될 수 있도록 매개변수화(parameterized)된 함수 형태로 사용된다. 보다 자세한 내용은 여기에서 확인 가능하다.



**참고**



- 모던 자바스크립트 Deep Dive, 이웅모 (2020)
- ECMAScript® 2022 Language Specification
- What are “Internal Slots” and “Internal Methods” in JavaScript?


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/javascript/var-let-const</guid>
      <title>var, let, const의 차이 ⏤ 변수 선언 및 할당, 호이스팅, 스코프</title>
      <link>https://www.howdy-mj.me/javascript/var-let-const</link>
      undefined
      <pubDate>Fri, 19 Mar 2021 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>javascript</category>
      <content:encoded>
자바스크립트에서 var로 변수 선언이 가능했는데, 왜 const와 let이 나왔으며 이 둘의 사용을 권장할까?

이를 정확하게 알기 위해서는, 변수의 선언 및 할당 과정, 호이스팅, 스코프를 알아야한다.

## 변수

먼저 자바스크립트에서 변수가 무엇인지 알아보자.
**변수(variable)는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름**을 말한다.



https://medium.com/@ethannam/javascripts-memory-model-7c972cd2c239


```js
const myNumber = 23
// 변수명(식별자): myNumber
// 해당 값의 위치(메모리 주소): 0012CCGWH80
// 변수 값(저장된 값): 23
```

자바스크립트는 매니지드 언어(managed language)이기 때문에 개발자가 직접 메모리를 제어하지 못한다. 따라서 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없고 변수를 통해 안전하게 값에 접근이 가능하다.

변수명(식별자)인 myNumber는 변수의 값이 아닌 메모리 주소를 기억하고 있다. 변수명을 사용하면, 자바스크립트 엔진이 변수명과 매핑된 메모리 주소를 통해 거기에 저장된 값(23)을 반환한다.

이처럼 변수에 값을 저장하는 것을 **할당**(assignment, 대입, 저장)이라 하며 변수에 저장된 값을 읽어 들이는 것을 **참조**(reference)라 한다. 그리고 변수명을 자바스크립트 엔진에 알리는 것을 **선언**(declaration)이라 한다.

### 변수 선언

변수의 선언은 `var`, `const`, `let` 키워드로 할 수 있으며, ES6에서 const와 let이 추가되었다.

자바스크립트에서 변수 선언은 `선언 → 초기화` 단계를 거쳐 수행된다.

- **선언 단계**: 변수명을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다.
- **초기화 단계**: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

```js
var kmj
console.log(kmj) // output: undefined
```

var 키워드를 이용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행되어, kmj에 암묵적으로 undefined를 할당해 초기화한다.

그런데 반대로, console을 먼저 찍어도 반환 값이 undefined로 나온다.

```js
console.log(kmj) // output: undefined
var kmj
```

이는 변수 선언이 런타임에서 되는 것이 아니라, 그 이전 단계에서 먼저 실행되기 때문이다. 자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서, 변수 선언을 포함한 모든 선언문(ex. 변수 선언문, 함수 선언문 등)을 찾아내 먼저 실행한다. 즉, 변수 선언이 어디에 있든 상관없이 다른 코드보다 먼저 실행되는 특징을 **호이스팅**(hoisting)이라 한다.

변수 선언 뿐만 아니라, `var`, `let`, `const`, `function`, `function*`, `class` 키워드를 사용해 선언한 모든 식별자(변수, 함수, 클래스 등)는 호이스팅이 된다.

### 변수 할당

변수에 값을 할당 할 때에는 할당 연산자(=)를 사용한다.

```js
var kmj // 변수 선언
kmj = 'howdy-mj' // 값의 할당

var kmj = 'howdy-mj' // 변수 선언과 할당
```

변수 선언과 할당은 하나의 문(statement)으로 단축 표현할 수 있지만, 두 개의 실행 시점이 다르다. 변수 선언이 호이스팅되어 런타임 이전에 실행되지만, 값의 할당은 소스코드가 순차적으로 실행되는 런타임에 실행된다.

따라서 변수의 할당과 console을 실행하는 위치에 따라 반환되는 값이 다르다.

```js
console.log(kmj) // output: undefined

var kmj = 'howdy-mj'
console.log(kmj) // output: howdy-mj
```

kmj라는 변수에 새로운 값을 재할당할 수도 있다.

```js
console.log(kmj) // output: howdy-mj

kmj = 'mj'
console.log(kmj) // output: mj
```

재할당은 변수에 저장된 값을 다른 값으로 변경하는 것으로, 만약 변경할 수 없는 값이라면 이는 변수가 아니라 상수(constant)라 부른다.



### 함수 호이스팅

위에서 `function` 키워드로 선언한 모든 식별자도 호이스팅이 된다고 했는데, 정확히 어떻게 이루어질까?

먼저 함수가 정의되는 방식 네 가지를 살펴보자.

```js
// 1. 함수 선언문
// 함수 이름 생략 불가능
function add(x, y) {
  return x + y
}

// 2. 함수 표현식
// 함수 이름 생략 가능
var add = function(x, y) {
  return x + y
}
// 함수 이름 작성 시,
// var add = function plus(x, y) {
//   return x + y
// }

// 3. Function 생성자 함수
var add = new Function('x', 'y', 'return x+ y')

// 4. 화살표 함수
var add = (x, y) => x + y
```

위에서 함수 선언문과 함수 표현식의 호이스팅 결과를 먼저 보자.

```js
// 함수 참조
console.dir(add) // output: f add(x, y)
console.dir(sub) // output: undefined

// 함수 호출
console.log(add(2, 5)) // output: 7
console.log(sub(2, 5)) // output: Uncaught TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y
}

// 함수 표현식
var sub = function(x, y) {
  return x + y
}
```

**함수 선언문**의 경우, 런타임 이전에 자바스크립트 엔진에서 먼저 실행되어, 함수 자체를 호이스팅 시킬 수 있다. 반면, **함수 표현식**은 위에서 봤던 변수 호이스팅과 같이 런타임 이전에 해당 값을 `undefined`로 초기화만 시키고, 런타임에서 해당 함수 표현식이 할당되어 그때 객체가 된다.

## 스코프

스코프(scope)는 식별자(ex. 변수명, 함수명, 클래스명 등)의 유효범위를 뜻하며, 선언된 위치에 따라 유효 범위가 달라진다. 전역에 선언된 변수는 전역 스코프를, 지역에 선언된 변수는 지역 스코프를 갖는다.

전역 변수는 어디에서든지 참조가 가능한 값이다. 반면, 지역 변수는 함수 몸체 내부를 말한다. 따라서 지역 변수는 자신의 지역 스코프와 그 하위 지역 스코프에서 유효하다.

한 가지 주의해야 할 점은, 자바스크립트에서 모든 코드 블록(if, for, while, try/catch 등)이 지역 스코프를 만들며, 이러한 특성을 **블록 레벨 스코프**라 한다. 하지만 var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 이를 **함수 레벨 스코프**라 한다.

```js
var a = 1

if (true) {
  var a = 5
}

console.log(a) // output: 5
```

함수가 아닌 곳에서 var 키워드를 이용해 a를 선언했기 때문에 전역 변수로 취급한다. 기존에 있던 a 변수가 중복 선언되면서, 최하단의 console에서도 출력 값이 5로 바뀐 것을 확인할 수 있다.

해당 예제는 코드가 짧아서 어디에서 문제가 일어난지 바로 알 수 있었지만, 실무에서는 그렇지 않다. 전역 변수로 인해 재할당이 발생하거나, 전역 스코프를 공유하기 때문에 어딘가에 동일한 이름이 있다면 예상치 못한 결과를 가져올 수 있는 위험이 있다. 따라서 오로지 함수 코드 블록만을 지역 스코프로 인정하는 `var` 대신, 블록 레벨 스코프를 지원하는 `const`와 `let`을 사용하는 것을 권장한다.

## var, let, const의 차이

앞에서 발견한 `var` 키워드의 문제점은 크게 세 가지가 존재한다.

- 변수 중복 선언 가능하여, 예기치 못한 값을 반환할 수 있다.
- 함수 레벨 스코프로 인해 함수 외부에서 선언한 변수는 모두 전역 변수로 된다.
- 변수 선언문 이전에 변수를 참조하면 언제나 undefined를 반환한다.



ES6에서 나온 `let`과 `const` 키워드는 위의 세 가지 문제점을 해결했다.

### 1. 변수 중복 선언 불가

(1) let

let 키워드로는 변수 중복 선언이 불가하지만, 재할당은 가능하다.

```js
let name = 'kmj'
console.log(name) // output: kmj

let name = 'howdy' // output: Uncaught SyntaxError: Identifier 'name' has already been declared

name = 'howdy'
console.log(name) // output: howdy
```

(2) const

const가 let과 다른 점이 있다면, **반드시 선언과 초기화를 동시에 진행되어야 한다.**

```js
const name; // output: Uncaught SyntaxError: Missing initializer in const declaration
const name = 'kmj'
```

const도 let과 마찬가지로 재선언이 불가하며, 더 나아가 재할당도 불가하다. 재할당의 경우, 원시 값은 불가능하지만, 객체는 가능하다. const 키워드는 재할당을 금지할 뿐, '불변'을 의미하지 않는다.

```js
// 원시값의 재할당
const name = 'kmj'
name = 'howdy' // output: Uncaught TypeError: Assignment to constant variable.

// 객체의 재할당
const name = {
  eng: 'kmj',
}
name.eng = 'howdy'

console.log(name) // output: { eng: "howdy" }
```

### 2. 블록 레벨 스코프

let, const 키워드로 선언한 변수는 모두 코드 블록(ex. 함수, if, for, while, try/catch 문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.

위 var 키워드로 예를 들었던 것을 그대로 가져와 바꾸면 아래와 같은 결과가 나온다.

```js
let a = 1

if (true) {
  let a = 5
}

console.log(a) // output: 1
```

var 키워드로 선언한 경우 5가 나왔지만, let 키워드로 선언한 경우 if 문 안에 있는 것은 지역 스코프를 가져 전역에서 console을 찍었을 경우, 전역에 있는 a가 결과 값으로 출력된다. (const 키워드도 let 키워드와 동일하게 동작한다)

### 3. 변수 호이스팅

(1) let

let 키워드로 선언한 변수는 **선언 단계와 초기화 단계가 분리되어 진행**된다. 즉, 런타임 이전에 자바스크립트 엔진에 의해 선언 단계가 먼저 실행되지만, 초기화 단계가 실행되지 않았을 때 해당 변수에 접근하려고 하면 참조 에러가 뜬다.

```js
console.log(name) // output: Uncaught ReferenceError: name is not defined

let name = 'kmj'
```

따라서 let 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점까지 변수를 참조할 수 없는 **일시적 사각지대(Temporal Dead Zone: TDZ)** 구간에 존재한다.

(2) const

const 키워드는 **선언 단계와 초기화 단계가 동시에 진행**된다.

```js
console.log(name) // output: Uncaught ReferenceError: Cannot access 'name' before initialization

const name = 'kmj'
```

let 키워드로 선언한 경우, 런타임 이전에 선언이 되어 자바스크립트 엔진에 이미 존재하지만 초기화가 되지 않았기 때문에 `name is not defined`라는 문구가 떴다. 하지만 const 키워드로 선언한 경우, 선언과 초기화가 동시에 이루어져야 하지만 런타임 이전에는 실행될 수 없다. 따라서 초기화가 진행되지 않은 상태이기 때문에 `Cannot access 'name' before initialization` 에러 문구가 뜬다.

## 정리

기본적으로 변수의 스코프는 최대한 좁게 만드는 것을 권장한다. 따라서, var 키워드 보다는 let과 const 키워드를 사용하며, 변경하지 않는 값(상수)이라면 let 보다는 const 키워드를 사용하는 것이 안전하다.



**참고**



- 모던 자바스크립트 Deep Dive, 이웅모 (2020)


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/html/html-template-and-content-model</guid>
      <title>HTML 템플릿 및 HTML Content Model</title>
      <link>https://www.howdy-mj.me/html/html-template-and-content-model</link>
      undefined
      <pubDate>Mon, 01 Mar 2021 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>html</category>
      <content:encoded>
## HTML 기본 템플릿

기본적인 HTML 템플릿과 각 태그가 어떤 역할을 하는지 알아보자.

```html


  
    HTML Title
    
    
  
  
    
  

```

VSCode를 사용하고 있을 경우, `html:5`를 작성한 경우 Emmet이 위의 내용을 템플릿을 자동으로 만들어준다.

### DOCTYPE

```html

```

DOCTYPE은 항상 첫번 째 줄에서 작성하며, HTML, XML, SGML, SVG 등 다양한 마크업 기반 언어에서 사용되며, 브라우저에게 해당 문서의 타입과 버전을 알려준다.

현재 웹 브라우저는 완전 표준 모드(Full standards mode)는 HTML과 CSS에 따라 웹 페이지가 표시되고, 거의 표준 모드(Almost standard mode)는 소수의 호환 모드 요소만 지원한다. DOCTYPE은 브라우저에게 완전 표준 모드를 활성화하기 위해 작성하는데, 만약 이를 선언하지 않으면 Quirks mode(호환 모드)로 읽는다. 이는 예상치 못한 동작이 발생할 수 있으며, 브라우저의 구현 상황에 따라 조금씩 상이하게 동작하기도 한다. 다만 이메일에서 사용하는 HTML을 작성할 때는 명시적으로 작성하지 않는다.

### Head

head 태그에는 문서의 메타데이터(metadata)가 있으며, 다른 문서나 기기에게 이 문서에 대한 정보를 제공하는 데이터가 작성된다. 주로 아래 세 가지가 존재한다.

```html
HTML title
```

해당 문서의 제목

```html

```

해당 문서의 문자 인코딩 방식을 나타내며, 유니코드(Unicode)를 위한 문자셋인 UTF-8을 가장 많이 사용한다. 작성하지 않을 경우, 해당 문서를 보는 사용자의 브라우저가 제대로 해석하지 못해 임의의 문자를 표시할 수도 있다.

```html

```

viewport는 브라우저에서 볼 수 있는 콘텐츠 영역을 말하며, 모바일 유저를 위해 사용하는 것을 권장한다. 이는 웹 표준 태그는 아니며 Apple에서 지원하는 것이다.

### Body

body 태그는 나중에 다른 글에서 설명하려 한다.



## HTML Content Model

모든 HTML 요소는 콘텐츠 모델을 가지고 있으며, 두 가지 이상의 모델에 속할 수 있다. 콘텐츠 모델은 콘텐츠의 포함 관계를 나타내거나, 어떤 요소가 어떤 콘텐츠에 속해있는지를 볼 때 도움이 된다.

크게 Main, Secondary 카테고리 그리고 Transparent content Model로 나뉘며, Main 카테고리는 크게 7가지의 콘텐츠 모델로 나뉜다.


  
  https://developer.mozilla.org/ko/docs/Web/Guide/HTML/Content_categories


자세한 건 여기서 확인할 수 있다.


## Main

### Metadata content

메타 데이터 콘텐츠는 문서의 표현이나 동작을 수정하거나, 다른 문서와 이 문서 간의 관계를 나타내고 이 문서에 대한 정보를 표현할 때 사용한다.

- ``, ``, ``, ``, ``, ``, ``, ``

### Flow content

문서의 body 요소 내부에 들어갈 수 있는 대부분의 요소는 여기에 속한다.

### Sectioning content

heading, footer 그리고 제목 콘텐츠의 범위를 정한다.

- ``, ``, ``, ``

### Heading content

섹션의 헤더를 정의한다. 섹션의 헤더에는 명시적으로 sectioning content를 사용하는 방법과 암묵적으로 생성할 수도 있다.

- ``, ``, ``, ``, ``, ``, ``

> 'header' 는 보통 제목을 포한하지만 heading content는 아니다.

> 'hgroup'은 HTML5의 완성 전, W3C HTML에서 제거되었으나, 여전히 WHATWG 명세의 일부이며 대부분의 브라우저에서 부분적으로 지원하고 있다.

### Phrasing content

HTML 문서 내에서 텍스트를 표시하는 요소이다. Text 노드를 포함하는 경우 대부분 여기에 해당한다.

### Embedded content

주로 문서 내에서 외부 콘텐츠(ex. 이미지, 비디오, 오디오, 외부 문서 등)를 가져올 때 사용한다.

- ``, ``, ``, ``, ``, ``, ``, ``, ``, ``

### Interactive content

유저와 상호작용이 발생하는 모든 요소를 말한다.

- ``, ` (controls)`, ` (controls)`, ``, ``, ``, ` (usemap)`, ` (usemap)`, ` (type이 hidden이 아닌 경우)`, ``, ``, ``

### Palpable content

palpable는 감지할 수 있는, 뚜렷한 이라는 뜻이며, 비어 있거나 hidden인 콘텐츠를 뜻한다.

Flow 콘텐츠나 Phrasing 콘텐츠는 자식 노드가 적어도 1개 이상 존재해야 하는데, 만약 해당 콘텐츠에 자식 노드가 없거나, 숨겨져 있는 경우를 Palpable 콘텐츠라 부른다.



## Secondary

### Script-supporting content

이 자체로는 문서에 무언가를 렌더하지 않지만, 스크립트를 지원하기 위해 사용하는 요소이다.

- ``, ``



## Transparent content Model

일부 요소는 이 콘텐츠 모델을 지니는데, 어떤 콘텐츠에 속하느냐에 따라 콘텐츠 모델이 달라지는 걸 의미한다.
예를 들어 `a 태그가` `p 태그` 내부에 있는 경우 `a`는 Phrasing content 처럼 취급된다.

## Paragraphs

이는 콘텐츠 모델은 아니지만, Flow 콘텐츠 내에 텍스트가 들어가 있거나, Phrasing content가 여럿 묶여 있는 경우를 Paragraph라 취급한다.

## The nothing content model

Text 노드가 없거나, 다른 자식 노드가 전혀 없는 것을 말한다.



**참고**



- https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories
- https://developer.mozilla.org/ko/docs/Web/HTML/Quirks_Mode_and_Standards_Mode
- https://html.spec.whatwg.org/multipage/dom.html#kinds-of-content


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/javascript/map-filter-reduce</guid>
      <title>자바스크립트 map, filter, reduce 동작 원리 알아보기</title>
      <link>https://www.howdy-mj.me/javascript/map-filter-reduce</link>
      undefined
      <pubDate>Mon, 22 Feb 2021 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>javascript</category>
      <content:encoded>
자바스크립트에서 `map()`, `filter()`, `reduce()` 메소드는 배열 요소를 나열하거나, 특정 조건에 맞게 보여줄 때 자주 쓰인다.

이번 글에서는 해당 메소드들의 사용방법 보다는 동작 원리를 알아보고자 해당 메소드들이 for문으로 어떻게 돌아가는지 작성하려 한다.

```js
// 아래 예제에서 모두 해당 데이터를 사용한다
const listData = [
  {
    id: 1,
    text: 'hello',
  },
  {
    id: 2,
    text: 'everyone',
  },
  {
    id: 3,
    text: 'welcome',
  },
  {
    id: 4,
    text: 'to',
  },
  {
    id: 5,
    text: 'my blog',
  },
];
```

### map()

```js
// Array.prototype.map()
arr.map(callback(currentValue[, index[, array]])[, thisArg])
```

```js
const realMapResult = listData.map((list) => list.text);
console.log(realMapResult);
// output: ["hello", "everyone", "welcome", "to", "my blog"]
```

실제 `map()`과 같은 결과를 얻기 위해 아래 처럼 만들었다.

```js
const mockMap = (list) => {
  let result = []; // map()은 새로운 배열을 반환
  for (const i of list) {
    result.push(i.text);
  }
  return result;
};

const result = mockMap(listData);
console.log(result);
// output: ["hello", "everyone", "welcome", "to", "my blog"]
```

### filter()

```js
// Array.prototype.filter()
arr.filter(callback(element[, index[, array]])[, thisArg])
```

`filter()`와 `map()`의 구조는 거의 비슷하다.

```js
const realFilterResult = listData.filter((list) => list.text !== 'everyone');
console.log(realFilterResult);
// output: [
//   {
//     id: 1,
//     text: 'hello',
//   },
//   {
//     id: 3,
//     text: 'welcome',
//   },
//   {
//     id: 4,
//     text: 'to',
//   },
//   {
//     id: 5,
//     text: 'my blog',
//   },
// ]
```

`filter()`는 해당 조건에 맞는 요소가 아닌, 객체들을 반환한다.

```js
const mockFilter = (list) => {
  let result = []; // filter() 역시 새로운 배열을 반환
  for (const i of list) {
    if (i.text !== 'everyone') {
      result.push(i); // 해당 조건에 맞는 객체를 push
    }
  }
  return result;
};

const result = mockFilter(listData);
console.log(result);
// output: [
//   {
//     id: 1,
//     text: 'hello',
//   },
//   {
//     id: 3,
//     text: 'welcome',
//   },
//   {
//     id: 4,
//     text: 'to',
//   },
//   {
//     id: 5,
//     text: 'my blog',
//   },
// ]
```

### reduce()

```js
// Array.prototype.reduce()
arr.reduce(callback[, initialValue])
```

`reduce()` 메서드는 첫 번째 callback 함수에서 reducer() 함수를 실행하고 하나의 결과 값을 반환한다.

reducer() 함수는 네 개의 인자를 받는다.

1. 누산기accumulator (acc): `initialValue`가 있을 경우 `initialValue`이며, 없을 경우 콜백의 반환값을 누적
2. 현재 값 (cur)
3. 현재 인덱스 (idx): `initialValue`가 있을 경우 0, 아니면 1부터 시작
4. 원본 배열 (src)

```js
const array1 = [1, 2, 3, 4];
const resultOfReducer = array1.reduce((accumulator, currentValue, currentIndex, array) => {
  console.log('accumulator', accumulator); // output: 10 11 13 16
  console.log('currentValue', currentValue); // output: 1 2 3 4
  console.log('currentIndex', currentIndex); // output: 0 1 2 3
  console.log('array', array); // output: [1, 2, 3, 4]
  return accumulator + currentValue;
}, 10);
console.log(resultOfReducer); // output: 20
```

```js
// console로 확인해보자면 이와 같다
const resultOfReducer = array1.reduce((accumulator, currentValue, currentIndex, array) => {
  console.log('accumulator', accumulator);
  // output: 10 11 13 16
  // 두 번째 인자의 initialValue가 10이기 때문에 10에서 시작한다
  console.log('currentValue', currentValue);
  // output: 1 2 3 4
  // array1의 값을 하나씩 반환한다
  console.log('currentIndex', currentIndex);
  // output: 0 1 2 3
  // 현재의 index를 하나씩 반환 한다
  console.log('array', array);
  // output: [1, 2, 3, 4]
  // array1을 반환한다
  return accumulator + currentValue;
  // 두개의 값이 더한 채로 accumulator에 누적된다
}, 10);
console.log(resultOfReducer); // output: 20
```

reduce()로 문자열을 출력하면 아래와 같다.

```js
const resultOfReducer = listData.reduce((accumulator, currentValue, currentIndex, array) => {
  return accumulator + currentValue.text + ' ';
}, '');
console.log(resultOfReducer);
// output: "hello everyone welcome to my blog "
```

이를 for문으로 돌리면 아래처럼 작성할 수 있다.

```js
const mockReducer = (list) => {
  let result = '';
  for (const data of list) {
    result += data.text + ' ';
  }
  return result;
};
console.log(mockReducer(listData));
// output: "hello everyone welcome to my blog "
```



### 보완할 점

- 설명 보완
- find(), some()도 작성해보기



**참고**



- MDN


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/bookmark/flutter</guid>
      <title>Flutter 북마크</title>
      <link>https://www.howdy-mj.me/bookmark/flutter</link>
      undefined
      <pubDate>Thu, 11 Feb 2021 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>bookmark</category>
      <content:encoded>

마지막 업데이트: 2021.07.27


 -->



Flutter(플러터) 개발자가 참고하면 좋은 글, 문서, 사이트 모음

## 공식 문서

- Flutter
- Dart Packages
- Flutter Medium

## Tutorials

- Building a Cupertino app with Flutter
- Flutter Todos Tutorial with “flutter_bloc” (2019.05.17)
- awesome-flutter (Github)

## UI

- Flutter Awesome
- Flutter Gallery
- Flutter-UIs-Collection (Github)

## Post

- [번역] Flutter는 왜 혁명적인가? (2018.05.17)
- Keys! What are they good for? (2019.03.29)
- Common Workflow in Flutter (2019.03.27)
- Creating services to do the work in your Flutter app
  
- Clean Architecture Using GetX in Flutter. (2021.02.22)
- Complete Flutter app walkthrough part 1 (2021.02.10)

## Packages

### State Management

- get (State, Navigation, Dependencies Manager)
- flutter_bloc
- provider

### Local Storage

- shared_preferences

### User Action

- pull_to_refresh

### UI & Resource

- carousel_slider
- google_fonts
- animated_text_kit
- convex_bottom_bar
- flutter_native_splash

### Connect other platforms

- firebase_core
- googleapis
- sign_in_with_apple

### Etc.

- flutter_local_notifications
- url_launcher
- location
- intl

 -->
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/dom/event-capturing-and-bubbling</guid>
      <title>이벤트 캡쳐링과 버블링 알아보기</title>
      <link>https://www.howdy-mj.me/dom/event-capturing-and-bubbling</link>
      undefined
      <pubDate>Mon, 08 Feb 2021 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>dom</category>
      <content:encoded>
필자는 모달을 구현하고, 모달 밖을 누르면 모달이 꺼지고, 모달 내부를 누르면 아무 반응도 없게 구현하고 싶었다. 하지만 분명 모달의 바깥을 눌러야 모달이 닫히는 함수를 만들었음에도 불구하고, 내부를 클릭했을 때도 같이 꺼지는 문제가 발생했다.

이런 현상이 바로 이벤트 버블링(Event Bubbling) 때문이었다.

## 이벤트 버블링, 캡쳐링이란?

```html

  
    
      
    
    
      const html = document.querySelector('html')
      const body = document.querySelector('body')
      const greenDiv = document.querySelector('.green-div')
      const pinkDiv = document.querySelector('.pink-div')

      html.addEventListener('click', function() {
        console.log('html')
      })

      body.addEventListener(
        'click',
        function() {
          console.log('body')
        },
        false
      )

      pinkDiv.addEventListener(
        'click',
        function() {
          console.log('pink div')
        },
        false
      )

      greenDiv.addEventListener(
        'click',
        function() {
          console.log('green div')
        },
        false
      )
    
  

```

가장 간단하게 이벤트 버블링, 캡쳐링을 이해할 수 있도록 click 이벤트를 만들어보았다. (아래 codesandbox에 코드 존재)

이벤트가 실행되면 캡쳐링(Capturing), 버블링(Bubbling) 두 가지 단계(two phases)가 존재한다.



@howdy-mj


위 이미지에서 보듯이, 이벤트 캡쳐링은 위에서 아래로 내려가며, 이벤트 버블링은 밑에서 위로 올라가는 단계이다.


  이벤트 캡쳐링: html > body > ... > target
  이벤트 버블링: target > ... > body > html


`addEventListener()`의 세 번째 인자가 캡쳐링 여부를 결정한다.

```js
target.addEventListener(type, listener[, useCapture]);
```

기본 값은 false로 되어있기 때문에 버블링만 발생하며 이를 true로 바꾸면 캡쳐링이 발생한다.

```js
const body = document.querySelector('body')

body.addEventListener(
  'click',
  function() {
    console.log('clicked body')
  },
  true
)
```



아래에서 실제 코드를 보고 실습을 해보자.

### 이벤트 캡쳐링



아래 console을 열고 클릭해보면 이벤트 버블링이 일어나는 순서를 알 수 있다.

회색부분을 누르면 `html > body`가, 분홍색을 누르면 `html > body > pink div`, 초록색을 누르면 `html > body > pink div > green div` 순으로 console이 찍힌다.

### 이벤트 버블링



console을 열고 회색부분을 누르면 `body > html`이, 분홍색을 누르면 `pink div > body > html`, 초록색을 누르면 `green div > pink div > body > html` 순으로 찍히는 걸 볼 수 있다.

이처럼 가장 내부를 클릭하지만, 실제로는 그 클릭 이벤트가 최상단의 body, html에까지 전달이 된다. 처음에 필자가 만들었던 모달도, 내부를 누르면 그 위의 element까지 같이 눌리게 되기 때문에 이벤트가 발동되어 모달이 닫혔던 것이다.

## 이벤트 전파 막기

그렇다면 과연 어떻게 이런 이벤트 전파를 막을 수 있을까?

`e.stopPropagation()`을 사용하면 된다.

버블링 상태에서 pink div에만 해당 함수를 걸면 아래와 같은 결과를 볼 수 있다.

```js
pinkDiv.addEventListener('click', function(e) {
  e.stopPropagation()
  console.log('pink div')
})
```



그랬더니 pink div를 클릭 할 때에는 오직 'pink div'만 console에 찍히는 것을 확인할 수 있다. 이는 클릭한 element의 이벤트만 발생시키고 상위로 이벤트 전달하는 것을 막아준다. 캡쳐링에서 e.stopPropagation()을 걸 경우, 클릭한 element의 최상위 이벤트만 동작하고, 하위 이벤트는 발생하지 않는다.

이 외, `e.stopImmediatePropagation()`을 사용하면 동일한 대상의 이벤트 흐름뿐만 아니라 다른 유사 이벤트도 중지시킬 수 있다. (추후 추가)

## 이벤트 버블링, 취소 가능 여부

가장 자주 사용하는 이베트의 버블링 및 취소 가능 여부를 알아보자.

UI Events에서 전체 이벤트를 볼 수 있다.

### Focus Event

|   Type    |  Bubbles  |  Cancelable  |
|:---------:|:---------:|:------------:|
|  `blur`   |    No     |      No      |
|  `focus`  |    No     |      No      |



### Mouse Event

|      Type      |  Bubbles  |  Cancelable  |
|:--------------:|:---------:|:------------:|
|    `click`     |    Yes    |     Yes      |
|  `mousedown`   |    Yes    |     Yes      |
|  `mouseenter`  |    No     |      No      |
|  `mouseleave`  |    No     |      No      |
|  `mousemove`   |    Yes    |     Yes      |
|   `mouseout`   |    Yes    |     Yes      |
|  `mousemover`  |    Yes    |     Yes      |
|   `mouseup`    |    Yes    |     Yes      |



### Wheel Event

|    Type    |  Bubbles  |  Cancelable  |
|:----------:|:---------:|:------------:|
|  `wheel`   |    Yes    |     Yes      |
|  `scroll`  |    Yes    |      No      |



### Keyboard Event

|    Type     |  Bubbles  |  Cancelable  |
|:-----------:|:---------:|:------------:|
|  `keydown`  |    Yes    |     Yes      |
|   `keyup`   |    Yes    |     Yes      |



**참고**



- https://www.w3.org/TR/uievents/
- https://joshua1988.github.io/web-development/javascript/event-propagation-delegation/
- https://ko.javascript.info/bubbling-and-capturing
- https://www.tutorialrepublic.com/javascript-tutorial/javascript-event-propagation.php


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/bookmark/javascript-and-typescript</guid>
      <title>JavaScript & TypeScript 북마크</title>
      <link>https://www.howdy-mj.me/bookmark/javascript-and-typescript</link>
      undefined
      <pubDate>Sun, 31 Jan 2021 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>bookmark</category>
      <content:encoded>

마지막 업데이트: 2021.07.22


 -->



자바스크립트, 타입스크립트 좋은 글 or 사이트 모음

## JavaScript

- '자바스크립트는 왜 이모양인가' 읽기

### Trend

- TC39: Specifying JavaScript.
- Best Of JavaScript

### Docs & PDF

- Deep JavaScript
- 2ality – JavaScript and more
- JavaScript Promise (ebook 무료)

 -->

#### ES6+

- The Top 3 New JavaScript ES 2021 (ES 12) (2020.11.18)
- 개발자가 필히 알아야 할 ES6 10가지 기능 (2017.08.14)

### How to use...

- map, reduce, filter를 유용하게 활용하는 15가지 방법 (2019.01.29)
- How JavaScript works: Under the hood of custom elements + Best practices on building reusable components (2018.08.06)
- Using switch(true) in JavaScript (2019.09.23)

### Tips

- 7 Tips for Clean Code in JavaScript You Should Know (2021.01.06)
- 자바스크립트는 어떻게 작동하는가: 메모리 관리 + 4가지 흔한 메모리 누수 대처법 (2017.12.19)

### Async

- Advanced Promise Patterns: Promise Memoization (2021.01.11)
- JavaScript async and await in loops (2019.05.01)

### Design Pattern

- 10 Javascript Design Patterns To Improve Your Code With (2021.01.27)

### Etc.

- JavaScript Event KeyCodes
- ES6 Browser Compatibility Table

## TypeScript

### Docs

- TypeScript-Handbook 한글 문서
- TypeScript Deep Dive
- 자바스크립트를 개발자를 위한 타입스크립트
- React TypeScript Cheatsheets

### How to use...

- 왜 타입스크립트에서 Generic을 사용해야하는지와 타입스크립트 Generic 을 쓰게 되는 이유에 대한 사유 (2020.08.06)
- TypeScript enum을 사용하지 않는 게 좋은 이유를 Tree-shaking 관점에서 소개합니다. (2020.09.10)
- 올해 버려야 할 타입스크립트 나쁜 버릇 10가지 (2021.02.17)

### Etc.

- TypeScript: Search for typed packages

 -->
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/next/how-to-detect-device</guid>
      <title>Next.js에서 userAgent 정보 가져오기</title>
      <link>https://www.howdy-mj.me/next/how-to-detect-device</link>
      undefined
      <pubDate>Tue, 19 Jan 2021 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>next</category>
      <content:encoded>

  업데이트: 2021.01.26
  
  
  업데이트: 2021.05.23 - 주요 내용: getServerSideProps (댓글 달아주신 sixmen님 감사합니다)




Next.js에서 라이브러리 설치 없이 유저가 사용하는 기기를 탐지하는 방법에 대해 알아보자.

해당 글은 next `^10.0.3`, react `^17.0.1`, typescript `^4.1.3` 버전으로 작성되었다.

## userAgent 정보 가져오기

만들어진 Next 프로젝트의 `pages/index.tsx`에서 아래와 같이 작성하면 된다.

```tsx
// 'pages/index.tsx'에서 getInitialProps 사용
import { NextPage, NextPageContext } from 'next';
import Head from 'next/head';

interface Props {
  userAgent: string;
}

const Home: NextPage = ({ userAgent }) => {
  console.log('index', userAgent);
  return (
    
      
        howdy-mj
        
      

      Hello World!
    
  );
};

Home.getInitialProps = async ({ req }: NextPageContext) => {
  const userAgent = req ? req.headers['user-agent'] : navigator.userAgent;
  return { userAgent };
};

export default Home;
```

그럼 console에서 아래와 같이 정상적으로 필자가 사용하는 기기의 정보를 가져올 수 있다.

```
Mozilla/5.0 (Macintosh; Intel Mac OS X 11_1_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36
```



하지만 이렇게 사용하기에 걸리는 점이 있었다. 필자는 어느 페이지를 띄우든 특정 브라우저(ex. IE)를 통해 들어오는 유저에게 모달창을 띄우고 싶었다. 그래서 서버사이드 렌더링 단에서 구해보기로 했다.

### 1. getStaticProps

Next 9.3 이상에서 `getInitialProps` 대신 `getStaticProps` 사용을 권장하고 있지만, 정작 `getStaticProps`으로는 사용중인 기기 정보를 얻을 수 없었다.

```tsx {25-26}
// 'pages/index.tsx'에서 getStaticProps를 사용하면 에러 발생
import { NextPage, NextPageContext } from 'next';
import Head from 'next/head';

interface Props {
  userAgent?: string;
}

const Home: NextPage = ({ userAgent }) => {
  console.log('index', userAgent);

  return (
    
      
        howdy-mj
        
      

      Hello World!
    
  );
};

export const getStaticProps = ({ req }: NextPageContext) => {
  const userAgent =
    typeof navigator === 'undefined' ? req.headers['user-agent'] : navigator.userAgent;

  return { props: { userAgent } };
};
```

처음에 navigator가 undefined되어 `typeof navigator === 'undefined'` 조건을 넣었지만, 여전히 `TypeError: Cannot read property 'headers' of undefined`라는 타입 에러를 뱉으며 결과를 얻을 수 없었다.

이는 `getStaticProps`가 정적 화면인 HTML 페이지만을 보여주기 때문이다. 따라서, 이 화면이 완성되는 시점에서 브라우저는 어느 기기에서 볼지 알 수 없다.

### 2. getServerSideProps

`getStaticProps`이 빌드 타임에 데이터를 가져오는 정적 생성이라면, `getServerSideProps`는 매 요청때마다 데이터를 가져오는 서버사이드 렌더링이다.

```tsx {22-25}
import Head from 'next/head';

interface Props {
  userAgent: string;
}

const Home = ({ userAgent }: Props) => {
  console.log('index page', userAgent);

  return (
    
      
        howdy-mj
        
      

      Hello World!
    
  );
};

export const getServerSideProps = ({ req }) => {
  const userAgent = req.headers['user-agent'];
  return { props: { userAgent } };
};

export default Home;
```

`getServerSideProps` 역시 서버에서 렌더링이 되기 때문에, 아직 브라우저는 이를 인지하지 못하기 때문에 `window`가 undefined이다. 그렇기 때문에 서버에 요청 보낸 후 응답으로 받는 `req`로 값을 가져와야 한다.

```tsx
interface Props {
  userAgent: string
  header: any
}

const Home = ({ userAgent, header }: Props) => {
  console.log('index page', userAgent)
  console.log('header', header)

  return (
    // ...생략
  )
}

export const getServerSideProps = ({ req }) => {
  const userAgent = req.headers['user-agent']
  return { props: { userAgent, header: req.headers } }
}

export default Home
```

console을 찍어보면, 아래처럼 header가 잘 들어오는 것을 확인할 수 있다.

```
header {
  host: 'localhost:3000',
  connection: 'keep-alive',
  'cache-control': 'max-age=0',
  'sec-ch-ua': '" Not A;Brand";v="99", "Chromium";v="90", "Google Chrome";v="90"',
  'sec-ch-ua-mobile': '?0',
  'upgrade-insecure-requests': '1',
  'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36',
  accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',
  'sec-fetch-site': 'same-origin',
  'sec-fetch-mode': 'navigate',
  'sec-fetch-dest': 'document',
  referer: 'http://localhost:3000/',
  'accept-encoding': 'gzip, deflate, br',
  'accept-language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7',
}
```

### getStaticProps와 getServerSideProps의 차이

Next.js에서는 `getStaticProps`의 사용을 추천하는 주요 이유는 성능 때문이다. `getStaticProps`은 빌드 될 때 생성된 HTML을 나중에 요청할 때 재사용하는 형태이다. 그리고 사용자의 요청 전에 CSR을 통해 데이터를 추가적으로 가져올 수 있다.

반면, `getServerSideProps`는 매 요청때마다 HTML이 다시 생성되고, 정적으로 페이지가 생성되는 것보다 느리다. 매 렌더링 마다 데이터를 다시 요청하기 때문에 반드시 필요한 경우에만 사용하는 것을 권장한다.

## 모든 페이지에서 userAgent 알아내기

`pages/_app.tsx`에서 제일 처음에 `getInitialProps`를 사용한 코드를 넣으면 `ReferenceError: navigator is not defined`와 같은 에러가 나왔다. 이는 SSR이기 때문에 CSR에서 알 수 있는 window나 브라우저 관련 변수를 잡아내지 못하는 것이다.

위에서 쓴 것처럼 서버 사이드 단에서 잡고 싶었지만, 공식문서를 보면 현재 `App`에서는 `getStaticProps`나 `getServerSideProps`와 같은 데이터 fetching 메서드를 지원하지 않기 때문에 사용이 불가하다. 따라서 useEffect를 사용할 수 밖에 없었다.

### 1. \_app에서 getInitialProps 사용

```tsx {13, 23-26}
import { useEffect, useState } from 'react';
import type { AppProps } from 'next/app';
import { ThemeProvider } from 'styled-components';

import GlobalStyle from '../styles/reset';
import theme from '../styles/theme';

interface userAgentProps {
  userAgent: string;
}

function MyApp({ Component, pageProps }: AppProps, { userAgent }: userAgentProps) {
  console.log('_app userAgent:', userAgent); // output: undefined

  return (
    
      
      
    
  );
}

MyApp.getInitialProps = async ({ req }) => {
  const userAgent = req ? req.headers['user-agent'] : navigator.userAgent;
  return { userAgent };
};

export default MyApp;
```

### 2. \_app에서 useEffect 사용

```tsx
import { useEffect, useState } from 'react';
import type { AppProps } from 'next/app';
import { ThemeProvider } from 'styled-components';

import GlobalStyle from '../styles/reset';
import theme from '../styles/theme';

function MyApp({ Component, pageProps }: AppProps) {
  const [isIE, setIsIE] = useState(false);
  const [isChrome, SetIsChrome] = useState(false);

  useEffect(() => {
    const IE = navigator.userAgent.match(/MSIE|rv:|IEMobile/i);
    const Chrome = navigator.userAgent.match(/Chrome/i);
    setIsIE(Boolean(IE));
    SetIsChrome(Boolean(Chrome));
  }, []);

  console.log('isIE', isIE); // output: false
  console.log('isChrome', isChrome); // output: true

  return (
    
      
      
    
  );
}
```

하지만 `currentBrowser` 값은 boolean으로 뜨기 때문에 필자가 원하던 모달창은 띄울 수 있었다.

## 정리

특정 페이지에서의 사용 기기를 알고 싶다면, 해당 페이지 내에서 `getServerSideProps`를 사용하면 된다.

전체 페이지에서 사용 기기를 알고 싶다면, `pages/_app.tsx`의 `useEffect`로 특정 브라우저인지 아닌지를 Boolean 값으로 반환하면 된다.



### 궁금점


  getInitialProps와 getStaticProps의 차이, 그리고 넘긴 props가 왜 undefined인지 궁금하다.

=> 댓글로 달아주신 sixmen님 다시 한 번 감사드립니다:)



**참고**



- https://nextjs.org/docs/api-reference/data-fetching/getInitialProps


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/bookmark/web-resource</guid>
      <title>웹 개발 리소스 모음</title>
      <link>https://www.howdy-mj.me/bookmark/web-resource</link>
      undefined
      <pubDate>Sun, 17 Jan 2021 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>bookmark</category>
      <content:encoded>

마지막 업데이트: 2021.07.18



*Free For Commercial: 상업용으로 사용 가능


 -->



웹 개발 시 필요한 리소스(ex. 이미지, 동영상, API, 디자인 등) 모음

- free-for.dev

- Accessing hardware devices on the web (2021.02.12)

- Tiny Helpers

## API

- Public APIs
- Daum 우편번호 API
- 도로명주소 API
- Facebook for Developers
- 서울 열린데이터 광장
- JSON Formatter & Validator

#### Free For Commercial

- JSON Placeholder
- Mocky - mock your APIs

## Video

#### Free For Commercial

- Coverr - Free Videos
- Pexels
- 놀라운 무료 동영상 - Pixabay
- Distill
- Videvo

## Image

- Flickr
- Snapwire Snaps

#### Free For Commercial

- Gratisography - Free High-Resolution Photos
- Pixabay - 무료 이미지
- Morguefile - Free photos for commercial use
- Imagebase - Absolutely free images
- Unsplash: Beautiful Free Images & Pictures
- Realistic Shots
- Free high resolution photography - Life of pix
- Free Nature Stock
- Public domain archive
- Foodiesfeed

## Icon, SVG, Logo

- seeklogo: Vector Logos, Logo Templates Free Download
- Flaticon - Free vector icons

#### Free For Commercial

- Public Domain Vectors
- CSS Icons
- Phosphor

## Font

- DaFont - Download fonts
- 1001 Free Fonts
- abstract fonts
- Fontfabric
- Free Typography
- Typedepot
- Lost Type
- Font Space

#### Free For Commercial

- Google Fonts
- Font Squirrel
- 눈누 상업용 무료한글폰트 사이트
- 1001 Free Fonts - Free Fonts for Commercial Use
- BeFonts
- Creative Fabrica

## Text

- Lorem Ipsum
- 한글입숨 - 무의미한 한글 텍스트 생성기

## Etc

- 이미지 배경 제거 - remove bg
- NoDesign.dev
- Carbon - 코드 이미지로 변환
- Codeimg (beta)
- Online Text Edit Tools
- Code Execution

 -->
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/html/html-number</guid>
      <title>HTML 특수문자 코드</title>
      <link>https://www.howdy-mj.me/html/html-number</link>
      undefined
      <pubDate>Sun, 17 Jan 2021 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>html</category>
      <content:encoded>
가끔 JSX나 TSX에서 특수문자가 제대로 안 보여질 때가 있다.

그럴 때 HTML Number 혹은 HTML Name을 사용하면 해결할 수 있다.

자주 쓰이는 것만 작성했으며, HTML Codes Table와 w3를 참고하였다.



|        Symbol        | HTML Number or HTML Name |
| :------------------: | :----------------------: |
|  (하나의 스페이스)   |         `&#32;`          |
|          !           |   `&#33;` or `&excl;`    |
|          "           |   `&#34;` or `&quot;`    |
|          #           |    `&#35;` or `&num;`    |
|          \$          |  `&#36;` or `&dollar;`   |
|          %           |  `&#37;` or `&percnt;`   |
|          &           |    `&#38;` or `&amp;`    |
|          '           |   `&#39;` or `&apos;`    |
|          (           |   `&#40;` or `&lpar;`    |
|          )           |   `&#41;` or `&rpar;`    |
|          \*          |    `&#42;` or `&ast;`    |
|          +           |   `&#43;` or `&plus;`    |
|          ,           |   `&#44;` or `&comma;`   |
|          -           |         `&#45;`          |
|          .           |  `&#46;` or `&period;`   |
|          /           |    `&#47;` or `&sol;`    |
|          :           |   `&#58;` or `&colon;`   |
|          ;           |   `&#59;` or `&semi;`    |
|                     |    `&#62;` or `&gt;`     |
|          ?           |   `&#63;` or `&quest;`   |
|          @           |  `&#64;` or `&commat;`   |
|          [           |   `&#91;` or `&lsqb;`    |
|          \           |   `&#92;` or `&bsol;`    |
|          ]           |   `&#93;` or `&rsqb;`    |
|          ^           |    `&#94;` or `&Hat;`    |
|          \_          |  `&#95;` or `&lowbar;`   |
|        (백틱)        |   `&#96;` or `&grave;`   |
|          {           |   `&#123;` or `&lcub;`   |
|     (파이프라인)     |  `&#124;` or `&verbar;`  |
|          }           |   `&#125;` or `&rcub;`   |
|          ~           |         `&#126;`         |
| (다수 개의 스페이스) |   `&#160;` or `&nbsp;`   |
|          ·           |  `&#183;` or `&middot;`  |
|          ×           |  `&#215;` or `&times;`   |
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/dom/what-is-dom</guid>
      <title>DOM과 Virtual Dom이란?</title>
      <link>https://www.howdy-mj.me/dom/what-is-dom</link>
      undefined
      <pubDate>Thu, 14 Jan 2021 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>dom</category>
      <content:encoded>
"직접 DOM에 접근하는 것은 지양해야 한다."

프론트 특히 SPA를 다루다 보면, DOM(Document Object Model)이란 단어를 많이 마주친다. 하지만 영문으로 봐도 정확히 무슨 뜻인지 와 닿지 않는다.

## DOM이란?

MDN에서는 "DOM은 HTML, XML document와 상호작용하고 표현하는 API이다. DOM은 browser에서 로드되며, Node(이하 노드) 트리(각 노드는 document의 부분을 나타낸다)로 표현하는 document 모델이다. (ex. element, 문자열, 혹은 코멘트)"라고 나와 있다.

위의 설명으로, Document는 HTML, XML을, Object는 노드 트리라 유추해볼 수 있다. 그렇다면 노드 트리는 무엇일까? 아래의 그림을 보면 조금 더 쉽게 이해가 갈 것이다.



https://en.wikipedia.org/wiki/Document_Object_Model


위의 그림에서 볼 수 있듯이 노드란 웹을 만들어본 사람이라면 다 알고 있는 HTML 태그들이다.

### 노드(Node)

가장 일반적인 노드 유형(nodeType)은 아래와 같다.

- DOCUMENT_NODE (ex. `window.document`)
- ELEMENT_NODE (ex. `, , , , , , `)
- ATTRIBUTE_NODE (ex. `class="hi"`)
- TEXT_NODE (ex. 줄바꿈과 공백을 포함한 HTML 문서 내의 텍스트)
- DOCUMENT_FRAGMENT_NODE (ex. `document.createDocumentFragment()`)
- DOCUMENT_TYPE_NODE (ex. ``)

지금 사용하고 있는 브라우저에서 console에 Node를 치면 바로 위의 노드 유형들이 나온다.



console에서 Node 입력


그럼 내가 만든 HTML이 곧 DOM인가 보네? 라는 생각이 들 법하지만, 아쉽게도 그렇지 않다.

맨 처음에 MDN에서 설명했듯이, DOM은 브라우저에서 로드되는 것이다. 각자의 IDE에서 작성한 HTML은 DOM이 아니고, 작성 된 HTML 문서가 브라우저에 의해 해석되어 실제 문서를 나타내는 노드 트리가 DOM이다. 그리고 이러한 DOM은 자바스크립트로 해당 문서에 노드 추가, 삭제, 변경, 이벤트 처리, 수정 등을 가능케 하는 API를 제공한다.

내가 아무리 나의 IDE에 HTML을 작성한다 한들, 최종적으로 이 결과물을 보기 위해 브라우저가 필요하다. IDE에 작성된 HTML은 단순한 문자열(string)일 뿐이며, 브라우저가 이해하기 위해서는 노드(객체)로 변환해야 한다.

즉 **DOM은 HTML과 자바스크립트를 이어주는 공간으로, 내가 작성한 HTML을 자바스크립트가 이해할 수 있도록 객체(object)로 변환**하는 것이다.

DOM은 내가 작성한 HTML로 부터 생성되지만, 브라우저가 알아서 필요한 노드들을 붙여준다. 예를 들어, ``나 ``없이 ``안에 어떠한 내용을 작성을 하더라도, 브라우저로 열어보면 자동으로 생성되어 있다. 그리고 자바스크립트로 인해 새로운 노드를 추가할 수도 있다.

```js
const newTextDiv = document.createElement('div')
const helloWorld = document.createTextNode('Hello world!')
newTextDiv.appendChild(helloWorld)
document.body.appendChild(newTextDiv)
```

따라서, 자바스크립트를 DOM API라고 부르기도 한다.

## 브라우저 동작 원리

그렇다면 DOM이 어떻게 브라우저로 동작 되는 걸까? 해당 글에서는 간단하게만 다뤄보며 Webkit을 기준으로 작성되었다.



https://web.dev/howbrowserswork/


브라우저가 HTML을 전달 받으면, 곧 이를 변환(파싱)하고 노드들로 이루어진 DOM 트리를 만든다. 그 후, 외부의 CSS 파일과 각 노드들의 inline 스타일을 파싱하여 스타일을 입힌 Render 트리를 만든다.

Render 트리가 만들이지면, 각 노드들이 화면에서 정확히 어디에 나타나야 하는지에 대한 위치가 주어진다. 그 후, paint() 메서드를 호출하면 내가 구현하고 싶었던 화면이 출력된다.

DOM은 해당 과정을 계속 반복한다. 즉, 오타 수정, 문구 제거 혹은 이미지를 첨부하는 사소한 일을 하더라도, DOM은 처음부터 다시 HTML을 파싱하여 DOM 트리를 만들고 CSS를 파싱하여 Render 트리를 만들고, 레이아웃을 입혀 출력한다.

2000년도 초만 하더라도 하나의 웹 사이트에 몇 페이지 없었을 테지만, 현재 대부분의 웹 사이트는 수 십개 심지어 수 백, 수 천개의 페이지로 이루어졌다. 겨우 오타 하나를 잡고 싶을 뿐인데, 전체 사이트를 다시 처음부터 렌더링(위의 결과물 출력 과정)을 해야 하며, 해당 오타를 찾기 까지 너무나 많은 시간이 들어가 상당히 비효율적이다.

그래서 Virtual Dom이 나왔다.

## Virtual Dom

Virtual Dom(이하 가상 DOM)은 수정사항이 여러 가지 있더라도, 가상 DOM은 한 번만 렌더링을 일으킨다.



https://elmprogramming.com/virtual-dom.html


위의 그림처럼, 가상 DOM은 DOM이 생성되기 전, 이전 상태 값과 수정사항을 비교하여 달라진 부분만 DOM에게 한 번에 전달하여 **딱 한 번만 렌더링**을 진행한다.



https://coding-medic.com/2020/11/10/the-virtual-dom/


빨간 부분에 수정사항이 생겼다면, 가상 DOM이 알아서 달라진 값을 탐지하여 변경하고 최종적인 결과물을 실제 DOM에 전달한다. 만약 가상 DOM이 없었다면, DOM은 렌더링을 처음부터 해야했기 때문에 모든 동그라미가 다 빨간색으로 바뀌었을 것이다.

> "직접 DOM에 접근하는 것은 지양해야 한다."

이는 DOM에 직접 접근해도 문제가 되진 않지만, DOM이 직접 변경된다면 사소한 변경사항에도 전체가 재렌더링 되기 때문에 브라우저에 과부하가 올 수 있다. 따라서 최대한 DOM에 직접 접근하지 말아야 한다, 라고 이해하면 될 것 같다.



**참고**



- DOM을 깨우치다, O'Reilly, 2013
- https://dom.spec.whatwg.org/
- [DOM 소개](https://developer.mozilla.org/ko/docs/Web/API/Document_Object_Model/%EC%86%8C%EA%B0%9C)
- [What, exactly, is the DOM?](https://bitsofco.de/what-exactly-is-the-dom/?utm_source=CSS-Weekly&utm_campaign=Issue-341&utm_medium=email)
- [How Browsers Work: Behind the scenes of modern web browsers](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/)
- [브라우저는 어떻게 동작하는가?](https://d2.naver.com/helloworld/59361)
- [Virtual DOM](https://elmprogramming.com/virtual-dom.html)
- [The one thing that no one properly explains about React — Why Virtual DOM](https://hashnode.com/post/the-one-thing-that-no-one-properly-explains-about-react-why-virtual-dom-cisczhfj41bmssp53mvfwmgrq)


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/css/order-of-css-properties</guid>
      <title>CSS 속성 순서</title>
      <link>https://www.howdy-mj.me/css/order-of-css-properties</link>
      undefined
      <pubDate>Wed, 16 Dec 2020 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>css</category>
      <content:encoded>
CSS를 작성하다보면, 어떤 순서로 작성해야 깔끔하고 눈에 잘 보이는지 고민되는 순간이 온다.

필자는 개인적으로 `position > display > width, height, padding, margin > background, color > font > 그 외 > pseudo`의 순서로 작성했는데 다른 곳에서는 어떻게 작성하는지 궁금하여 한번 찾아봤다.

_(CSS property 순서라 돌아다니는 글은 정확한 출처를 찾을 수 없어 다시 찾아봤다)_

공식적으로 발표 된 순서는 것은 없지만, 다들 비슷한 생각인지 정리 해놓은 글들이 꽤 있었다.

## Grouped by type

이는 기존에 내가 하던 방식과 가장 유사하다.

출처: [Poll Results: How do you order your CSS properties?](https://css-tricks.com/poll-results-how-do-you-order-your-css-properties/)

```css
.selector {
  /* Positioning */
  position: absolute;
  z-index: 10;
  top: 0;
  right: 0;

  /* Display & Box Model */
  display: inline-block;
  overflow: hidden;
  box-sizing: border-box;
  width: 100px;
  height: 100px;
  padding: 10px;
  border: 10px solid #333;
  margin: 10px;

  /* Color */
  background: #000;
  color: #fff

  /* Text */
  font-family: sans-serif;
  font-size: 16px;
  line-height: 1.4;
  text-align: right;

  /* Other */
  cursor: pointer;
}
```

## Concentric-CSS

2011년에 나왔으며, 바깥의 box model부터 시작하여 안으로 작성한다.

출처: [Concentric-CSS](https://github.com/brandon-rhodes/Concentric-CSS)

```css
#Concentric-CSS-Overview {
  display: ; /* Directions about where and how the box is placed */
  position: ;
  float: ;
  clear: ;

  visibility: ; /* Next: can the box be seen? */
  opacity: ;
  z-index: ;

  margin: ; /* Layers of the box model, from outside to inside */
  outline: ;
  border: ;
  background: ; /* (padding and content BOTH get the background color) */
  padding: ;

  width: ; /* Content dimensions and scrollbars */
  height: ;
  overflow: ;

  color: ; /* Textual content */
  text: ;
  font: ;
}
```

## idiomatic CSS

2013년에 나왔으며, [mozilla](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Organizing)에서도 몇 가지 내용을 반영하였다.

클래스 네이밍 부터 포맷, 선언 순서까지 가이드를 작성했으며, 주석이 있어 코드가 좀 길지만 다른 사람이 보더라도 무엇인지 알아 볼 수 있다는게 큰 장점인 것 같다.

출처: [Principles of writing consistent, idiomatic CSS](https://github.com/necolas/idiomatic-css)

```css
/**
 * 실제로 주석이 더 많지만, 해당 글에서는 삭제했다. 위의 출처에서 볼 수 있다.
 */

/* ===================================================
   Grid layout
   =================================================== */

/* Grid container */
.grid {
  height: 100%;
  font-size: 0;
  white-space: nowrap;
}

/* Grid cells */
.cell {
  position: relative;
  display: inline-block;
  overflow: hidden;
  box-sizing: border-box;
  height: 100%;
  padding: 0 10px;
  border: 2px solid #333;
  vertical-align: top;
  white-space: normal;
  font-size: 16px;
}

/* Cell states */
.cell.is-animating {
  background-color: #fffdec;
}

/* Cell dimensions */
.cell-1 {
  width: 10%;
}
.cell-2 {
  width: 20%;
}
.cell-3 {
  width: 30%;
}
.cell-4 {
  width: 40%;
}
.cell-5 {
  width: 50%;
}

/* Cell modifiers */
.cell--detail,
.cell--important {
  border-width: 4px;
}
```
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/bookmark/design-and-design-system</guid>
      <title>디자인, 디자인 시스템 북마크</title>
      <link>https://www.howdy-mj.me/bookmark/design-and-design-system</link>
      undefined
      <pubDate>Tue, 15 Dec 2020 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>bookmark</category>
      <content:encoded>

마지막 업데이트: 2021.07.22


 -->



프론트엔드 개발자가 참고하면 좋을 디자인, 디자인 시스템 관련 글, 사이트 모음

- Cue-ration

## 색상

- Color Picker
- HTML Color Codes
- Color Tool



팔레트 / 조합

- 아티스트를 위한 색상 팔레트, 색상 구성표 - Adobe Color
- Colorable
- Open Color (색 팔레트)
- SchemeColor - Download Color Schemes
- Two Color Combinations
- calcolor

## 트렌드

- Behance
- Mobbin - Latest Mobile Design Pattern
- 서핏 - 디자이너를 위한 모든 디자인 콘텐츠
- Fonts In Use
- A guide of UI design trends for 2021
- 75 Of The Coolest Color Combinations For 2021
- Dribble - Discover the world's top designers & creatives
- 노트폴리오 - 크리에이티브 네트워크

## 디자인 가이드

- WEB DESIGN STYLE GUIDE 웹 디자이너를 위한, 웹 스타일 가이드 지침서
- On Type Patterns and Style Guides (2021.01.19)

## 디자인 시스템

- SOCAR FRAME - SOCAR DESIGN SYSTEM
- RIDI Design System
- Remember UI
- Spectrum, Adobe's design system



스토리북

- Carbon Design System
- Caple Design System
- WFT UI-KIT



글, 사이트

- Design Systems Repo
- Design System Basics in Figma (2018.07.29)
- Text fields & Forms design — UI components series (2020.05.25)
- NAVER FE devtalk: 디자인 시스템에 대한 소개와 효율성 개선 및 구축 경험공유 (영상)
- 와디즈의 디자인 시스템 구축 (2021.03.05)
- ‘디자인 시스템’에 대해 얘기해보다 -Part 1 (2021.02.13)
- 리액트(React)로 디자인 시스템 만들어보기!!(feat. storybook) (2021.02.03)

## 디자인 툴

- Zeplin
- Figma
- Sketch
- XELF
- WireFlow - designer tool

</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/boilerplate/next-ts-mobx-sc-sb</guid>
      <title>Next.js + TypeScript + MobX + Styled-components + Storybook</title>
      <link>https://www.howdy-mj.me/boilerplate/next-ts-mobx-sc-sb</link>
      undefined
      <pubDate>Sun, 13 Dec 2020 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>boilerplate</category><category>next</category>
      <content:encoded>

마지막 업데이트: 2021.01.29


Next에 TypeScript, MobX, Styled-components, Storybook 까지 포함한 프로젝트를 세팅해보자.

Next 소개는 [이전글](/next/next-js-intro/)에서, 완성된 코드는 [Github](https://github.com/howdy-mj/next-ts-mobx-sc-sb-boilerplate)에서 볼 수 있다.

## 설치

```json
// 해당 프로젝트의 package.json
{
  // ...
  "dependencies": {
    "mobx": "^6.0.4",
    "mobx-react": "^7.0.5",
    "next": "^10.0.3",
    "react": "^17.0.1",
    "react-dom": "^17.0.1",
    "styled-components": "^5.2.1"
  },
  "devDependencies": {
    "@babel/core": "^7.12.10",
    "@storybook/addon-actions": "^6.1.11",
    "@storybook/addon-essentials": "^6.1.11",
    "@storybook/addon-links": "^6.1.11",
    "@storybook/react": "^6.1.11",
    "@types/node": "^14.14.12",
    "@types/react": "^17.0.0",
    "@types/styled-components": "^5.1.5",
    "@typescript-eslint/eslint-plugin": "^4.9.1",
    "@typescript-eslint/parser": "^4.9.1",
    "babel-loader": "^8.2.2",
    "babel-plugin-styled-components": "^1.12.0",
    "eslint-config-prettier": "^7.0.0",
    "eslint-plugin-prettier": "^3.2.0",
    "eslint-plugin-react": "^7.21.5",
    "prettier": "^2.2.1",
    "typescript": "^4.1.3"
  }
  // ...
}
```

### Next, TypeScript

```shell
$ yarn create-next-app # 설치 중간에 폴더명 설정
$ cd 폴더명
$ yarn add next react react-dom

# typescript 설정
$ touch tsconfig.json
$ yarn add --dev typescript @types/react @types/node
$ yarn dev
```

타입스크립트를 사용할 때 필요한 `next-env.d.ts`과 `tsconfig.json` config가 자동으로 만들어진다. 해당 파일을 삭제하면 타입에러가 뜨니 삭제하면 안된다.



초기 폴더 구조


### ESLint, Prettier

```shell
$ yarn add -D prettier eslint-config-prettier eslint-plugin-prettier eslint-plugin-react @typescript-eslint/eslint-plugin @typescript-eslint/parser

```

root 폴더에 아래 두 개의 파일을 만든다.

.eslintrc

```json
{
  "parser": "@typescript-eslint/parser",
  "extends": [
    "plugin:react/recommended",
    "plugin:@typescript-eslint/recommended",
    "prettier/@typescript-eslint",
    "plugin:prettier/recommended"
  ],
  "plugins": ["react", "@typescript-eslint", "prettier"],
  "parserOptions": {
    "ecmaVersion": 6,
    "ecmaFeatures": {
      "jsx": true
    }
  },
  "rules": {
    "prettier/prettier": ["error", { "singleQuote": true }],
    "react/jsx-uses-vars": "error"
  },
  "ignorePatterns": ["*.config.js"]
}
```

.prettierrc

```json
{
  "singleQuote": true,
  "semi": true,
  "useTabs": false,
  "tabWidth": 2,
  "trailingComma": "all",
  "printWidth": 80
}
```

### Styled-components

```shell
$ yarn add styled-components
$ yarn add -D @types/styled-components babel-plugin-styled-components
```

Next는 SSR이기 때문에 styled-components의 babel 설정을 따로 해줘야 한다.

root 폴더에 `.babelrc`를 만들어서 아래와 같이 작성하자.

.babelrc

```json
{
  "presets": ["next/babel"],
  "plugins": [
    [
      "styled-components",
      {
        "ssr": true,
        "displayName": true,
        "preprocess": false
      }
    ]
  ]
}
```


  development, production에 따른 babel 세팅

```json
{
  "env": {
    "development": {
      "plugins": [
        [
          "babel-plugin-styled-components",
          { "ssr": true, "displayName": true, "preprocess": false }
        ]
      ],
      "presets": ["next/babel"]
    },
    "production": {
      "plugins": [
        [
          "babel-plugin-styled-components",
          { "ssr": true, "displayName": true, "preprocess": false }
        ]
      ],
      "presets": ["next/babel"]
    }
  },
  "plugins": [
    [
      "babel-plugin-styled-components",
      { "ssr": true, "displayName": true, "preprocess": false }
    ]
  ]
}
```





원래 styled-component를 쓰면 console에서 Elements를 확인할 때 className이 암호화되어 식별하기 힘들다. 하지만 `babel-plugin-styled-components`를 설치하면 컴포넌트 이름을 붙여주어 어떤 것인지 알아볼 수 있으며, 디버깅할 때도 쉽다. 이 외, debugging, minification 등의 자세한 babel 설정은 [공식 홈페이지](https://styled-components.com/docs/tooling)에서 볼 수 있다.

이제 기존 `styles` 폴더 안에 있는 것을 삭제하고, User agent sheet를 초기화 할 reset과 전역에서 사용할 theme 변수 파일을 만들어보자.

styles/reset.ts

```ts
import { createGlobalStyle } from 'styled-components'

const GlobalStyle = createGlobalStyle`
  * {
    margin: 0;
    padding: 0;  
  }
  html {
    font-size: 62.5%; // 1rem = 10px; 10px/16px = 62.5%
    height: 100vh;
  }
  body {
    box-sizing: border-box;
    font-size: 1.6rem;   
  }
  a {
    &:link,
    &:visited,
    &:hover,
    &:active {
      color: inherit;
      text-decoration: inherit;
    }
  }
  input,
  select,
  button {
    -webkit-appearance: none;
    background: none;
    border: none;
    font-size: inherit;
    color: inherit;
    &:focus {
      outline: none;
    }
    &:disabled {
      cursor: not-allowed;
    }
  }
  a, button {
    cursor: pointer;
  }
  pre {
    white-space: pre-line;
  }
`

export default GlobalStyle
```

styles/theme.ts

```ts
export const size = {
  pc: '75em', // 1200px
  tab: '56.25em', // 900px
  mobile: '31.25em', // 500px
  mobileS: '23.125em', // 370px
}

const theme = {
  color: {
    primary: '#344E5C',
    secondary: '#4AB19D',
    point: '#EFC958',
    black: '#000000',
    gray5: '#444444',
    gray4: '#767676',
    gray3: '#C6C6C6',
    gray2: '#E6E6E6',
    gray1: '#E5E5E5',
    gray0: '#FAFAFA',
    white: '#FFFFFF',
    success: '#22bb33',
    danger: '#bb2124',
    warning: '#f0ad4e',
    info: '#5bc0de',
  },
  window: {
    pc: `@media screen and (max-width: ${size.pc}px)`,
    tab: `@media screen and (max-width: ${size.tab}px)`,
    mobile: `@media screen and (max-width: ${size.mobile}px)`,
    mobileS: `@media screen and (max-width: ${size.mobileS}px)`,
  },
}

export default theme
```

theme에 대한 타입을 지정 후, 다시 theme에서 import 한다.

styles/styled.d.ts

> 타입을 지정하는 파일의 이름은 무조건 'styled.d.ts'여야 한다. 아니면 자동완성이 뜨지 않는다.

```ts
import 'styled-components'

declare module 'styled-components' {
  export interface DefaultTheme {
    color: {
      primary: string
      secondary: string
      point: string
      black: string
      gray5: string
      gray4: string
      gray3: string
      gray2: string
      gray1: string
      gray0: string
      white: string
      success: string
      danger: string
      warning: string
      info: string
    }
    window: {
      pc: string
      tab: string
      mobile: string
      mobileS: string
    }
  }
}
```

styles/theme.ts

```ts
import { DefaultTheme } from 'styled-components'
// ...
const theme: DefaultTheme = {
  //...
}
```

pages/\_document.tsx

```tsx
import Document, { DocumentContext } from 'next/document'
import { ServerStyleSheet } from 'styled-components'

export default class MyDocument extends Document {
  static async getInitialProps(ctx: DocumentContext) {
    const sheet = new ServerStyleSheet()
    const originalRenderPage = ctx.renderPage

    try {
      ctx.renderPage = () =>
        originalRenderPage({
          enhanceApp: App => props => sheet.collectStyles(),
        })

      const initialProps = await Document.getInitialProps(ctx)
      return {
        ...initialProps,
        styles: (
          <>
            {initialProps.styles}
            {sheet.getStyleElement()}
          
        ),
      }
    } finally {
      sheet.seal()
    }
  }
}
```

SSR은 사용자들이 요청하면 그때 미리 만들어 놓은 HTML을 먼저 보여주어 매우 빠르다. 하지만 styled-components는 자바스크립트이기 때문에 나중에 렌더가 된다. 즉, styled-component가 완전히 로딩되기 전에 페이지가 켜지기 때문에 스타일이 적용되기 전의 화면이 먼저 보이고, 화면 깜빡인 다음에 스타일을 불러온다. 따라서 위 처럼 ServerStyleSheet를 먼저 가져와야 한다.

pages/\_app.tsx

```tsx
import type { AppProps } from 'next/app';
import { ThemeProvider } from 'styled-components';

import GlobalStyle from '../styles/reset';
import theme from '../styles/theme';

function MyApp({ Component, pageProps }: AppProps) {
  return (
    
      
      
    
  );
}

export default MyApp;
```

본래 global에 있는 stylesheets과의 충돌을 피하기 위해, 개인이 설정한 CSS 파일은 오직 `pages_app.tsx`에서만 import 해야 한다.

pages/index.tsx

```tsx
import Head from 'next/head'

export default function Home() {
  return (
    
      
        howdy-mj
        
      

      Hello World!
    
  )
}
```

이제 `yarn dev`를 해보면 성공적으로 reset이 적용된 걸 볼 수 있다.



Styles에서 reset에 설정한 내용 확인 가능




### MobX

```shell
$ yarn add mobx mobx-react
```

MobX 소개와 예제는 [이전글](https://howdy-mj.me/mobx/mobx6-intro/)로 대체한다.

함수형을 쓰기 때문에 별도의 Class config는 주지 않는다.

store/count.ts

```ts
import { makeAutoObservable } from 'mobx'

class Count {
  number: number = 0
  constructor() {
    makeAutoObservable(this)
  }
  increase = () => {
    this.number++
  }
  decrease = () => {
    this.number--
  }
}

const countStore = new Count()
export default countStore
```

pages/count.tsx

```tsx
import { observer } from 'mobx-react'
import styled from 'styled-components'

import countStore from '../store/count'

const CountPage: React.FC = observer(() => {
  return (
    
      
        Count
        number: {countStore.number}
         countStore.increase()}>plus
         countStore.decrease()}>minus
      
    
  )
})

export default CountPage

const Button = styled.button`
  border: 1px solid gray;
  padding: 5px;
  margin-right: 10px;
`
```

`yarn dev` 후, `/count`로 이동하면 정상적으로 작동하는 것을 확인할 수 있다.



Next MobX 적용




### Storybook

```shell
$ npx sb init
```



Storybook 설치 후, 폴더 구조




storybook을 설치하면 알아서 타입스크립트인 것을 감지하고 설정해준다. `package.json`을 가면 스토리북 관련 script가 추가된 것도 확인할 수 있다.

설치하고자 하는 라이브러리를 다 설치했으니, 폴더 구조를 다시 잡아보자.

components라는 폴더 안에 재사용될 컴포넌트와 stories 파일을 넣을 것이며, containers 폴더안 페이지 관련 코드들이 들어갈 것이다.따라서 root에 `components`, `containers` 폴더를 생성하고, `stories` 안에 있는 건 `components` 안으로 집어 넣자.

components는 storybook에 내제된 컴포넌트 들을 사용할 것이며, 이를 styled-components로 변경하는 것은 [이전 글](https://howdy-mj.me/storybook/writing-stories/)을 참고하겠다.

`components`안에 만들 Button, Header 컴포넌트 코드는 [여기](https://github.com/howdy-mj/writing-stories/tree/master/src/components)에서 볼 수 있다.

### 완성될 폴더 구조

```
.storybook
components
  ├─ Button
  │   ├─ index.stories.tsx
  │   └─ index.tsx
  └─ Header
      ├─ index.stories.tsx
      └─ index.tsx
api
containers
  └─ Count
      └─ index.tsx
pages
  ├─ _app.tsx
  ├─ _document.tsx
  ├─ count.tsx
  └─ index.tsx
public
store
styles
```

## 폴더 절대경로 설정

위에서 바꾼 폴더 구조대로, 절대 경로를 설정해보겠다.

Next는 static한 구조를 지니고 있어 React처럼 eject를 하거나 별도의 라이브러리(ex. CRACO) 없이 절대 경로 설정이 가능하다.

tsconfig.json

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@api/*": ["api/*"],
      "@components/*": ["components/*"],
      "@container/*": ["container/*"],
      "@pages/*": ["pages/*"],
      "@styles/*": ["styles/*"],
      "@store/*": ["store/*"]
    }
    // ...
  }
}
```

절대 경로를 다 설정했다면, 아래의 파일들을 수정해보자.

개인의 취향이지만, 필자는 모든 로직은 `pages`가 아닌 `containers` 폴더에서 처리하기 때문에 모두 옮겼다.

pages/counts.tsx

```tsx
import CountContainer from '@containers/Count'

const CountPage: React.FC = () => {
  return 
}

export default CountPage
```

containers/Count/index.tsx

```tsx
import { observer } from 'mobx-react'

import countStore from '@store/count'
import { Button } from '@components/Button'
import styled from 'styled-components'

const CountContainer: React.FC = observer(() => {
  return (
    
      
        Count
        number: {countStore.number}
         countStore.increase()} />
         countStore.decrease()} />
      
    
  )
})

export default CountContainer

const Title = styled.h1`
  color: ${props => props.theme.color.secondary};
`
```

설정을 마친 후, 다시 서버를 켜면 아래와 같은 화면이 나온다.







완성된 코드: [Github](https://github.com/howdy-mj/next-ts-mobx-sc-sb-boilerplate)



**참고**



- [Next.js](https://nextjs.org/)
- [Styled component](https://styled-components.com/)


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/mobx/mobx6-intro</guid>
      <title>MobX 6 사용하기</title>
      <link>https://www.howdy-mj.me/mobx/mobx6-intro</link>
      undefined
      <pubDate>Wed, 09 Dec 2020 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>mobx</category>
      <content:encoded>
해당 글에서는 MobX로 간단하게 count를 변경하는 코드를 만들어 볼 것이며, 여러가지 방식을 보여주는 것이 목적이다. (완성된 코드는 [mobx-playground](https://github.com/howdy-mj/mobx-playground)에서 볼 수 있다)

MobX는 자유도가 무척 높기 때문에, 필자가 작성한 방식이 정답이 아니며 '이렇게도 사용할 수 있구나' 정도로 보면 될 것 같다.



### MobX란?

리액트 상태 관리 라이브러리하면 가장 먼저 떠오르는 것이 Redux, 그 다음 얼핏 들어본 이름중에 MobX가 있을 것이라 생각한다.

MobX는 React 뿐만 아니라, Angular, Vue, Flutter, Dart에서도 사용이 가능하다.

MobX의 러닝커브는 낮은편으로 초기에 작성해야하는 보일러플레이트 코드가 거의 없으며, state의 불변성도 걱정하지 않아도 된다. Redux를 사용해본 사람이라면 MobX가 꽤나 간단하다고 느껴질 것이다. 하지만 자유도가 매우 높아서 그 만큼 잘 활용하기가 어려운 것 같다.

## MobX 핵심 개념

MobX를 사용하기 전에 핵심 개념부터 알아보자.

MobX는 `observable`을 사용하면 properties, entire objects, arrays, Maps, Sets 등을 모두 자동으로 observable(관찰 가능한)하게 만들 수 있다. 여기에 가장 중요한 어노테이션(annotation)으로는 아래 세 가지가 있다.

- `observable`: 추적 가능한 state 정의
- `action`: state를 변경하는 메소드
- `computed`: state와 캐시로부터 새로운 결과를 반환

### observable

observable은 `makeObservable`, `makeAutoObservable` 그리고 `observable` 이 세 가지가 있으며, 모두 추적 가능한 상태의 state로 만들어준다.

`makeObservable`은 주로 class의 this와 많이 사용된다.

`makeAutoObservable`은 `makeObservable`와 거의 비슷하지만, class에서 super나 subclassed가 있을 경우 사용할 수 없다.

`make(Auto)Observable`와 `observable`의 가장 큰 차이점은 전자는 들어온 인자로 들어온 object를 바로 변경하지만, 후자는 클론을 하고 observable하게 만든다는 점이다. 또한 `observable`는 Proxy object를 생성한다. (추후 보완..ㅠㅠ) 따라서 공식 문서에서도 `make(Auto)Observable` 사용을 권장하고 있다.

### action

action은 state를 변경하는 것을 뜻한다. `makeObservable`을 사용하면 action을 따로 작성해줘야 하지만, `makeAutoObservable`은 이를 대신해준다. 밑에 코드에서 두 가지 방식 모두 사용해 볼 것이다.

### computed

computed values(계산된 값)는 다른 observable들에서 어떠한 정보를 도출하는데 사용할 수 있다. 이렇게만 봐서는 뭔지 모를 수 있는데 밑의 예시를 통해 같이 살펴보자.



## MobX 사용하기

### 프로젝트 세팅

```shell
$ yarn create react-app mobx-playground --template typescript
$ cd mobx-playground
```

```json
// package.json
{
  "dependencies": {
    "mobx": "^6.0.4",
    "mobx-react": "^7.0.5",
    "react": "^17.0.1",
    "react-dom": "^17.0.1",
    "react-scripts": "4.0.1",
    "typescript": "^4.0.3"
  }
}
```

`src` 폴더 안에 있는 index, App을 제외하고 모두 지운다.

src/index.tsx

```tsx
import React from 'react'
import ReactDOM from 'react-dom'
import App from './App'

ReactDOM.render(, document.getElementById('root'))
```

src/App.tsx

```tsx
import React from 'react'

const App: React.FC = () => {
  return App
}

export default App
```

```shell
$ yarn add mobx mobx-react
```

React에서 MobX를 쉽게 사용하게 해주는 써드파티 라이브러리로, `mobx-react`와 `mobx-react-lite`가 있는데, `mobx-react`는 클래스형 컴포넌트와 hooks를 모두 지원하고, `mobx-react-lite`는 훅스만 지원한다. MobX를 사용하려는 프로젝트에서 이미 hooks를 사용중이라면, 조금 더 가벼운 `mobx-react-lite` 사용을 권장한다.

또한, MobX 6에서 decorators(ex. @action, @observable 등)들이 deprecated 되었다.



### Store 구축

Stores는 Flux 아키텍쳐에서 볼 수 있으며, MVC의 Controller와 비교할 수 있다. 스토어의 주요 역할은 비즈니스 로직과 state를 컴포넌트에서 빼서 단독으로 프론트, 백에서 모두 사용할 수 있도록 만드는 것이다.

MobX에서 규정하는 Store에는 Domain Stores(그 안에 Domain objects)와 UI Stores가 있다. 여기서는 Domain Store만 논하겠다.

Domain Store는 하나 혹은 여러개가 있을 수 있으며, 하나의 Domain Store는 해당 애플리케이션에서 하나의 역할을 책임지고 수행해야 한다. 그리고 하나의 스토어 안에는 여러개의 domain objects가 있을 수 있다. 그리고 domain objects안에서 간단하게 state를 모델링할 수 있다.

해당 글에서 만드는 것은 MobX의 state 모델링 하는 것에 속하지만, 이해하기 편하도록 Store라고 하겠다. _(추후 보완)_



해당 글에서는 class, object 두 가지 형태로 구축해보겠다.

우선 `src/store` 폴더를 만들고, 그 안에 `count.ts`를 만든다.

src/store/count.ts

1. class - `makeObservable`

```ts
import { action, makeObservable, observable } from 'mobx'

class Count {
  number: number = 0

  constructor() {
    makeObservable(this, {
      number: observable,
      increase: action,
      decrease: action,
    })
  }

  increase = () => {
    this.number++
  }
  decrease = () => {
    this.number--
  }
}

const countStore = new Count()
export default countStore
```

2. class - `makeAutoObservable`

```ts
import { makeAutoObservable } from 'mobx'

class Count {
  number: number = 0

  constructor() {
    makeAutoObservable(this)
  }

  increase = () => {
    this.number++
  }
  decrease = () => {
    this.number--
  }
}

const countStore = new Count()
export default countStore
```

개인 적으로 깔끔한 두 번째 방식을 선호한다. 하지만 super나 subclassed에서는 사용이 불가하기 때문에 첫 번째 방식도 알아두어야 하긴 한다.

3. object

```ts
import { observable } from 'mobx'

const countObject = observable({
  // 헷갈릴 수 있으니 num으로 작명
  num: 0,
  increase() {
    this.num++
  },
  decrease() {
    this.num--
  },
})

export default countObject
```

object로 만들면 코드가 더 줄어든다. observable로 감싸주기만 하면 된다.

이렇게 만든 Store(정확히는 state model)는 사용할 컴포넌트에서 따로 import 해도 되지만, 필자는 개인적으로 하나의 store에 넣는 것이 선호하기 때문에 `src/store/index.ts`를 만든다.

```tsx
import countClass from './countClass'
import countObject from './countObject'

const store = { countClass, countObject }
export default store
```

잘 동작하는지 확인하기 위해 `src/App.tsx`를 아래처럼 작성한다.

```tsx
import React from 'react'
import { observer } from 'mobx-react'
import store from './store'

// 컴포넌트를 observer로 감싸주어 state가 실시간으로 변경되는 것을 감지한다
const App: React.FC = observer(() => {
  const { countClass, countObject } = store

  return (
    
      
        Count (Class)
        number: {countClass.number}
         countClass.increase()}>plus
         countClass.decrease()}>minus
      

      
        Count (Object)
        num: {countObject.num}
         countObject.increase()}>increment
      
    
  )
})

export default App
// export default observer(App) // 이렇게 감싸줄수도 있다
```



이제 computed가 무엇인지 알아보기 위해 액션(클릭)이 일어날 때마다, 계산된 값이 배가 되는 `double`을 만들어 보자. 마찬가지로 class, object 두 가지 형식으로 만들어 보겠다.

src/store/double.ts

1. class - `makeObservable`

```ts
import { makeObservable, observable, computed, action } from 'mobx'

class Doubler {
  value

  constructor(value: number) {
    makeObservable(this, {
      value: observable,
      double: computed,
      increment: action,
    })
    this.value = value
  }

  get double() {
    return this.value * 2
  }

  increment() {
    this.value++
  }
}

const doubleClass = new Doubler(1)
export default doubleClass
```

2. class - `makeAutoObservable`

```ts
import { makeAutoObservable } from 'mobx'

class Doubler {
  value

  constructor(value: number) {
    makeAutoObservable(this)
    // makeAutoObservable이 다른 action, computed를 자동으로 선언
    this.value = value
  }

  get double() {
    return this.value * 2
  }

  increment() {
    this.value++
  }
}

const doubleClassAuto = new Doubler(1)
export default doubleClassAuto
```

3. object

```ts
import { observable } from 'mobx'

const doubleObject = observable({
  value: 1,
  get double() {
    return this.value * 2
  },
  increment() {
    this.value++
  },
})

export default doubleObject
```

만든 Store를 `src/store/index`에 넣어주자. 이번에는 `doubleClassAuto`를 사용해보겠다.

```ts
import countClass from './countClass'
import countObject from './countObject'
import doubleClassAuto from './doubleClassAuto'

const store = { countClass, countObject, doubleClassAuto }
export default store
```

src/App.tsx

```tsx
import React from 'react'
import { autorun } from 'mobx'
import { observer } from 'mobx-react'

import store from './store'

const App: React.FC = observer(() => {
  const { countClass, countObject, doubleClassAuto } = store
  autorun(() => {
    if (doubleClassAuto.double) {
      console.log('Double' + doubleClassAuto.double)
    }
    if (doubleClassAuto.double === 8) {
      console.log('만약 value가 8이라면 0으로 초기화')
      doubleClassAuto.value = 0
    }
  })

  return (
    
      
        Count (Class)
        number: {countClass.number}
         countClass.increase()}>plus
         countClass.decrease()}>minus
      

      
        Count (Object)
        num: {countObject.num}
         countObject.increase()}>increment
      

      
        Computed
        double number: {doubleClassAuto.value}
         doubleClassAuto.increment()}>
          double increment
        
      
    
  )
})

export default App
```

이때 `autorun`을 통해 해당 computed 값이 어떻게 바뀌는지 감지할 수 있다. 이번 예제에서는 increment를 누를 때마다 `double()`이라는 getter가 value에 곱하기 2를 한다. 그리고 계산된 값(computed value)가 8에 도달하면 value를 0으로 초기화시킨다.

이런 기능을 통해 다른 action을 막거나 유저에게 알림을 줄수 있을 것 같다. 예를 들면, 어떤 물건을 장바구니에 담았을 때 자동으로 물건의 가격을 계산하면서 예산을 초과했을 경우 팝업창을 띄우거나, 싫어요를 특정 개수 이상 누를 경우 패널티를 부과 한다던지의 트리거 역할을 할 수 있을 것 같다.



전체 코드: [mobx-playground](https://github.com/howdy-mj/mobx-playground)



MobX를 올바르고 더 잘 사용하기 위해서는 Flux 패턴 그리고 정확히 Domain Store, Domain Object, Model State가 무엇이고 어떻게 다른지 알아야 할 것 같다.



해당 글은 MobX 공식홈페이지를 보고 작성하여 오역이 있을 수 있습니다. 피드백은 언제나 환영합니다!
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/storybook/writing-stories</guid>
      <title>스토리북으로 Stories 작성하기</title>
      <link>https://www.howdy-mj.me/storybook/writing-stories</link>
      undefined
      <pubDate>Mon, 30 Nov 2020 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>storybook</category>
      <content:encoded>
스토리북에서 stories를 어떻게 작성하는지 알아보자.

해당 글은 react `^17.0.1`, react-scripts `4.0.1`, @storybook/react `^6.1.8`, styled-components `^5.2.1`, typescript `^4.0.3` 버전으로 작성되었다.

완성된 코드: [Github - writing-stories](https://github.com/howdy-mj/writing-stories)

## 프로젝트 세팅

```shell
$ yarn create react-app writing-stories --template typescript
$ cd writing-stories
$ npx sb init
$ yarn add styled-components
$ yarn add -D @types/styled-components
$ yarn storybook # 스토리북 서버
```



기존 폴더 구조


기본 구조는 위와 같아지는데, 개인적으로 stories와 컴포넌트가 같이 있는 것을 선호하기 때문에 약간의 폴더 구조 변경을 하며, 해당 글은 오로지 Storybook에만 치중하기 때문에, `src/index.tsx`와 `src/App.tsx`는 건드리지 않으며, 예제는 기본으로 내제된 컴포넌트를 활용하겠다.

## 폴더 구조 변경



변경한 폴더 구조


기존의 `Button.tsx`와 `Header.tsx`는 components/Button, components/Header 안으로, `Pages.tsx`는 pages/Main으로 변경했으며, 기존의 css는 모두 styled-components로 변경했다. [Github: Folder Structure](https://github.com/howdy-mj/writing-stories/commit/8b9403948f9102f6adc23f166667ed1ccd5a0ed9)

```shell
$ yarn storybook
```

이 후 다시 스토리북을 실행하면 이전과 같은 화면을 볼 수 있다.

해당 글에서는 Button 컴포넌트를 다루어 보겠다.



Button Docs 화면


개인적으로 (현재의 나로서는) 스토리북의 최대 장점은 Docs라 생각한다. Storybook 6로 오면서 TypeScript 지원이 훨씬 간단해졌으며, interface를 지정해주고, 주석으로 달아주면 위 이미지처럼 스토리북 Docs에서 그대로 볼 수 있다.

문서화를 함으로써, 만들어 둔 컴포넌트에 어떤 props가 있는지, 어떻게 사용해야 하는지 굳이 알려줄 필요 없이 스토리북 서버에서 바로 확인 가능하다.

components/Button/index.tsx

```tsx
export interface ButtonProps {
  /**
   * Is this the principal call to action on the page?
   */
  primary?: boolean
  /**
   * What background color to use
   */
  bgColor?: string
  /**
   * How large should the button be?
   */
  size?: 'small' | 'medium' | 'large'
  /**
   * Button contents
   */
  label: string
  /**
   * Optional click handler
   */
  onClick?: () => void
}

/**
 * Primary UI component for user interaction
 */
// => 스토리북 Docs 소제목으로 들어감
export const Button: React.FC = ({
  primary = false,
  size = 'medium',
  bgColor,
  label,
  ...props
}) => {
  return (
    
      {label}
    
  )
}
```



Button Stories 화면


그리고 해당 props일 때 어떤 UI를 가지는지도 스토리북에서 바로 확인이 가능하다.

components/Button/Button.stories.tsx

```tsx
import React from 'react'
// also exported from '@storybook/react' if you can deal with breaking changes in 6.1
import { Story, Meta } from '@storybook/react/types-6-0'

import { Button, ButtonProps } from './index'

export default {
  title: 'Components/Button',
  component: Button,
  argTypes: {
    backgroundColor: { control: 'color' },
  },
} as Meta

const Template: Story = args => 

export const Primary = Template.bind({})
Primary.args = {
  primary: true,
  label: 'Button',
}

export const Secondary = Template.bind({})
Secondary.args = {
  label: 'Button',
}

export const Large = Template.bind({})
Large.args = {
  size: 'large',
  label: 'Button',
}

export const Small = Template.bind({})
Small.args = {
  size: 'small',
  label: 'Button',
}
```

_추후 내용 추가 예정_



**참고**



- https://storybook.js.org/


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/redux/right-way-to-update-state</guid>
      <title>Redux에서 state를 업데이트하는 올바른 방법 (불변을 지켜야하는 이유)</title>
      <link>https://www.howdy-mj.me/redux/right-way-to-update-state</link>
      undefined
      <pubDate>Sun, 15 Nov 2020 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>redux</category><category>react</category>
      <content:encoded>
## React가 렌더되는 경우

React가 렌더 되는 경우는 다음과 같다.

1. state나 props가 변경되었을 때
2. `forceUpdate()`를 실행했을 때
3. 부모 컴포넌트가 렌더링 되었을 때

이번 글에서 주목해야할 것은 1번이다. React는 state나 props가 변경되었을 경우에만 리렌더가 된다.

React는 어떻게 state나 props의 변경을 감지할 수 있을까? 먼저 자바스크립트 각 데이터 타입이 어떻게 변경 되는지 알아보자.

## 자바스크립트 데이터 타입

자바스크립트는 크게 원시 타입과 참조 타입으로 나뉜다.

### 원시 타입(Primitive Type)

원시 타입에는 문자열, 숫자, Boolean, null, undefined가 있으며 이는 변경 불가능한(immutable) 값이다.

```js
const str = 'hello';

console.log(str[0]); // output: 'h'
str[0] = 'w'; // 에러가 뜨지 않음

console.log(str); // output: 'hello', 바뀌지 않음
```

비록 `str[0] = 'w'`로 했을 때 아무런 에러가 뜨지 않았지만, 다시 str를 콘솔로 찍어보니 바뀌지 않은 것을 확인할 수 있다. 이처럼 원시 타입은 변경 불가능하다.



### 참조 타입(Reference/Object Type)

참조 타입에는 함수, 객체, 배열이 있으며 변경 가능한(mutable) 값이다.

`배열의 변경`

```js
const fruits = ['apple', 'banana'];

fruits.push('mango');
console.log(fruits); // output: ['apple', 'banana', 'mango']
```

`객체의 변경`

```js
const profile = { name: 'kmj' };

profile.name = 'howdy-mj';
profile.gender = 'female';
console.log(profile); // output: { name: 'howdy-mj', gender: 'female' }
```

이처럼 참조 타입은 바로 값이 바뀌는 것을 확인할 수 있다. 하지만 React, Redux는 해당 값이 변경 되지 않았다고 판단할 것이다. 밑의 예시를 보자.

```js
const num = [1, 2, 3];

num === num; // output: true
num === [1, 2, 3]; // output: false
```

분명 `num`과 `[1, 2, 3]`은 같지만, 자바스크립트는 두 개의 값이 다르다고 알려주고 있다. 이는 참조 타입이 메모리 주소를 '참조'하기 때문이다. (해당 내용은 나중에 새로운 글에서 자세히 작성해보겠다. 우선 밑의 핵심 요약을 보면 감을 잡을 수 있을거라 생각한다)



### 핵심 요약

원시 타입은 **워드 파일의 복사본을 만든것 처럼, 해당 값을 복사하면 서로가 독립된 값**을 가진다.

```js
var title = '마지막';
var final = title;

title = '진짜 마지막';

console.log(title); // output: '진짜 마지막'
console.log(final); // output: '마지막'
```

이처럼 final은 처음에 복사한 title 값을 그대로 가져온 반면, title은 나중에 변경된 값으로 찍힌다.

참조 타입은 **만약 내가 구글 드라이브에 동기화된 파일을 수정하면, 다른 사람 것에서도 자동으로 변경**된다. 단, url 주소는 동일하다.

```js
const profile = { name: 'kmj' };
const copy = profile;

profile.name = 'howdy-mj';

console.log(profile); // output: { name: 'howdy-mj' }
console.log(copy); // output: { name: 'howdy-mj' }
```

profile.name을 바꾸자, 기존의 profile과 copy 모두 바뀐 것을 확인할 수 있다.

이렇듯 참조 타입은 값이 바뀌어도 메모리(쉽게 말하면 url) 주소가 똑같기 때문에 React는 데이터가 변경된 것을 알아차리지 못한다. 따라서, 메모리 주소를 바꾸어 React에게 데이터가 변경되었다고 알려주어야 한다. 이는 Redux에서도 똑같이 작용한다.

## Redux의 state 변경 감지 코드

보통 redux를 사용하면,

```js
import { combineReducers } from 'redux';

const songsReducer = () => {
  return [
    { title: '소주 한잔', duration: '4:51' },
    { title: 'Memories', duration: '3:10' },
    { title: '널 좋아하나봐', duration: '3:44' },
    { title: '거짓말이라도 해서 널 보고싶어', duration: '3:48' },
  ];
};

const selectedSongReducer = (selectedSong = null, action) => {
  if (action.type === 'SONG_SELECTED') {
    return action.payload;
  }
  return selectedSong;
};

export default combineReducers({
  songs: songsReducer,
  selectedSong: selectedSongReducer,
});
```

위와 같은 형태로 모든 reducers를 `combineReducers로` 모아 store에 알려준다.

이때, [combineReducers](https://github.com/reduxjs/redux/blob/master/src/combineReducers.ts) 코드를 보면 Redux가 어떻게 state의 변화를 감지하는지 알 수 있다.

```ts {15, 18}
// ...
let hasChanged = false;
const nextState: StateFromReducersMapObject = {};
for (let i = 0; i  fruit !== 'mango')
fruits.map(fruit => fruit === 'apple' ? 'peach' : fruit)
```

`객체의 변경`

```js
const profile = { name: 'kmj' }

// 틀린 방법
profile.name = 'howdy-mj'
profile.gender = 'female'
delete profile.gender

// 올바른 방법
{ ...state, name: 'howdy-mj' }
{ ...state, gender: 'female' }
_.omit(state, 'gender') // lodash로 제거
```

이러한 번거로움을 없애고자 [immer](https://immerjs.github.io/immer/docs/introduction) 혹은 [immutable-js](https://immutable-js.github.io/immutable-js/) 라이브러리를 사용한다.

아니면 바로 immutable update logic이 있어 바로 state를 변경할 수 있도록 만들어진 [Redux Toolkit](https://redux-toolkit.js.org/)을 사용할 수도 있다.
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/boilerplate/cra-typescript-eslint-prettier</guid>
      <title>CRA + Typescript + ESlint + Prettier</title>
      <link>https://www.howdy-mj.me/boilerplate/cra-typescript-eslint-prettier</link>
      undefined
      <pubDate>Sun, 08 Nov 2020 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>boilerplate</category>
      <content:encoded>

업데이트: 2021.05.17 
- 주요 내용: config에서 @typescript-eslint 삭제




CRA로 만든 TypeScript 기반에 ESlint, Prettier 설정하는 법을 알아보자.

원래 타입스크립트에서는 TSLint가 있었지만, 2019년 2월에 ESLint로 마이그레이션을 [발표](https://github.com/palantir/tslint/issues/4534)하며, 2020년 1월에 완전히 적용되었다.

해당 글은 VSCode를 사용하며, ESLint, Prettier extensions이 이미 설치된 상태이며, react `^17.0.2`, typescript `^4.1.2` 버전으로 작성되었다.

## 폴더 생성 및 설치

```shell
# 폴더 생성 및 이동
$ yarn create react-app cra-settings --template typescript
$ cd cra-settings

# 패키지 설치
$ yarn add eslint-plugin-prettier eslint-plugin-react prettier -D
```

_CRA에 ESLint가 포함되어 있기 때문에 따로 설치를 안해줘도 된다_

현 시점 패키지 버전:

```json
// ...
"devDependencies": {
  "eslint-plugin-prettier": "^3.4.0",
  "eslint-config-prettier": "^8.3.0",
  "eslint-plugin-react": "^7.23.2",
  "prettier": "^2.3.0"
}
// ...
```

이후, root 폴더에 `.eslintrc`와 `.prettierrc` 파일 생성 후 밑의 내용을 작성한다.

.eslintrc

```json
{
  "extends": ["plugin:prettier/recommended"],
  "plugins": ["react", "prettier"],
  "parserOptions": {
    "ecmaVersion": 6,
    "ecmaFeatures": {
      "jsx": true
    }
  },
  "rules": {
    "prettier/prettier": ["error", { "singleQuote": true }],
    "react/jsx-uses-vars": "error"
  },
  "ignorePatterns": ["*.config.js"]
}
```



eslint-config-prettier Version 8.0.0에서 prettier config가 하나로 합쳐졌다. 따라서 기존에 있던 @typescript-eslint은 삭제해도 된다.



.prettierrc

```json
{
  "singleQuote": true,
  "semi": true,
  "useTabs": false,
  "tabWidth": 2,
  "trailingComma": "all",
  "printWidth": 80
}
```

## 패키지 및 config 항목 알아보기

단순히 복붙하여 사용해도 되지만, 각각 어떤 것을 뜻하는지 한 번 알아보자.



### 패키지 역할

- [eslint-config-prettier](https://github.com/prettier/eslint-config-prettier): ESLint와 Prettier의 충돌을 막아줌
- [eslint-plugin-react](https://github.com/yannickcr/eslint-plugin-react): React에서 ESLint 명세 규정
- [eslint-plugin-prettier](https://github.com/prettier/eslint-plugin-prettier): Prettier를 ESLint 규칙으로 실행하고 문제점을 ESLint로 보고

ESLint와 Prettier는 [이전글](https://howdy-mj.me/node/eslint-and-prettier/)에서 확인 가능하다.



### eslint config 설명

.eslintrc

```json
{
  "extends": ["plugin:prettier/recommended"],
  "plugins": ["react", "prettier"],
  "parserOptions": {
    // ESLint는 es6 이후의 문법을 알지 못하기 때문에 설정
    // https://eslint.org/docs/user-guide/configuring#specifying-parser-options
    "ecmaVersion": 6,
    "ecmaFeatures": {
      "jsx": true // eslint-plugin-react
    }
  },
  "rules": {
    // 설정하고 싶은 규칙 작성
    // 밑은 예시일 뿐, 아무거나 추가 가능
    "prettier/prettier": ["error", { "singleQuote": true }], // eslint-plugin-prettier
    "react/jsx-uses-vars": "error" // eslint-plugin-react
  },
  "ignorePatterns": ["*.config.js"] // 제외하려는 파일
}
```



**참고**



- [ESLint](https://eslint.org/)
- [Prettier](https://prettier.io/)


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/general/how-to-read-symbols</guid>
      <title>특수문자 읽는 법 (영문, 한글, 중문)</title>
      <link>https://www.howdy-mj.me/general/how-to-read-symbols</link>
      undefined
      <pubDate>Wed, 04 Nov 2020 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>general</category>
      <content:encoded>
## 특수 문자 읽는 법

|       | Special Characters                               | 특수 문자      | 特殊符号                     |
| :---: | :----------------------------------------------- | :------------- | :--------------------------- |
|  `!`  | Exclamation Mark                                 | 느낌표         | 感叹号                       |
|  `?`  | Quotation Mark                                   | 물음표         | 问号                         |
|  `#`  | Hash, Crosshatch, Sharp                          | 우물정자       | 井号                         |
|  `$`  | Dollar Sign                                      | 달라           | 美元符号                     |
|  `%`  | Percent Sign                                     | 프로, 퍼센트   | 百分号                       |
|  `@`  | At Sign, Commercial At                           | 골뱅이         | ài tè                        |
|  `&`  | Ampersand, And sign                              | 앤퍼센트       | 连接符号                     |
|  `'`  | Apostrophe, Single Quote                         | 작은따음표     | 单引号, 撇号                 |
|  `"`  | Quotation mark, Double Quote                     | 큰따음표       | 双引号                       |
|  `*`  | Asterisk, Star sign                              | 별, 곱하기     | 星号                         |
|  `+`  | Plus                                             | 더하기         | 加号；正号                   |
|  `-`  | Hyphen, Dash, Minus Sign                         | 다시, 빼기     | 减号；负号, 连字符           |
|  `_`  | Underscore, Underline                            | 언더바         | 下划线                       |
|  `.`  | Period, Decimal, Dot                             | 점             | 句号                         |
|  `,`  | Comma                                            | 콤마           | 逗号                         |
| `...` | Ellipsis                                         | 생략           | 省略号                       |
|  `/`  | Slash, Virgule, Divide                           | 슬래시, 나누기 | 斜线、斜杠、除号             |
|  `:`  | Colon                                            | 콜론           | 冒号                         |
|  `;`  | Semicolon                                        | 세미콜론       | 分号                         |
|  `^`  | Caret, Circumflex                                | 윗꺽쇠         | 插入符号、插入符、脱字符号等 |
| `{}`  | Curly bracket, Brace                             | 중괄호         | 大括号                       |
| `[]`  | Square Bracket                                   | 대괄호         | 方括号                       |
| `()`  | Parenthesis, Round bracket                       | 소괄호         | 圆括号                       |
|  `|`  | Vertical Bar                                     | 파이프라인??   | 竖线                         |
|  `~`  | Tilde                                            | 물결           | 波浪号                       |
|  `=`  | Equal Sign                                       | 는, 같다       | 等于号                       |
| `` | Less/Greater Than Sign, Left/Right Angle Bracket | 꺽쇠           | 小/大于号                    |
|  `∞`  | Infinity                                         | 무한           | 无限大号                     |
| `\` | Backslash | 역슬래시 | 反斜杠 |
|    ` | Backtick | 백틱 | 重音符     |
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/fe-setting/editorconfig-eslint-prettier</guid>
      <title>EditorConfig란? (vs. ESlint, Prettier)</title>
      <link>https://www.howdy-mj.me/fe-setting/editorconfig-eslint-prettier</link>
      undefined
      <pubDate>Mon, 19 Oct 2020 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>fe-setting</category>
      <content:encoded>
개발자가 혼자 일하는 일은 드물다. 따라서 누가 언제 참여해도 동일한 코딩 환경을 만들어주기 위한 툴이 존재한다.

[ESLint](https://eslint.org/)는 코딩 컨벤션과 에러 혹은 오류를 체크해주는 유명한 자바스크립트 프로그램이다. (이러한 프로그램을 lint 혹은 linter라고 부른다)

[Prettier](https://prettier.io/)는 ESLint와 달리 코드 퀄리티(ex. no-unused-vars, prefer-promise-reject-errors, ...)를 체크해주지 않는 단순 코드 포매터(code formatter)이다. ESLint도 코드 포매터의 역할을 할 수 있지만, Prettier에서 더 많은 설정이 가능하다. Prettier는 자바스크립트뿐만 아니라, JSX, Flow, 타입스크립트, HTML, JSON, CSS 등 언어에서 모두 사용 가능하다.

대부분 Eslint나 Prettier로 원하는 환경을 만들 수 있지만, EditorConfig를 사용하면 더 범용적인 설정도 가능하다. 특히 한 팀안에 서로 다른 에디터를 사용할 때 유용하다.

## EditorConfig

[EditorConfig](https://editorconfig.org/)는 다수의 개발자들이 각자 다른 에디터나 IDE를 사용해도 동일한 코딩 스타일을 유지하도록 도와준다. 보통 들여쓰기 스타일, 탭 너비, 줄의 끝 문자(CR/LF), 인코딩 등의 설정이 가능하다.

VS Code, Atom, Bracket, WebStorm, eclipse, Notepad++, Sublime Text, Vim 등 여러 에디터에서 사용가능하며 자세한 건 [여기](https://editorconfig.org/#download)에서 확인 가능하다.

EditorConfig는 XML을 제외한 Visual Studio가 지원하는 모든 언어에서 지원된다. 프로젝트에 EditorConfig는 파일을 추가하면, 새로 작성하는 코드에는 해당 파일에 따라 서식이 지정되지만, 기존 스타일은 변환되지 않는다.

`.editorconfig` 파일은 보통 프로젝트의 root 폴더에 생성되며, 그 아래에 있는 모든 파일에 적용된다. 만약 특정 폴더에서만 지정하고 싶은 스타일이 있다면, 해당 폴더에서 `.editorconfig` 파일을 생성하면 된다. (`.editorconfig`은 편집 중인 파일에 '가장 가까운' `.editorconfig`의 설정이 우선시 된다) 대신 root 폴더에 있는 설정 파일에 `root = true`를 작성해야 한다.

### Global Patterns

|                |                                                                        |
| :------------- | :--------------------------------------------------------------------- |
| `*`            | 경로(`/`)를 제외한 파일 혹은 폴더에 적용                               |
| `**`           | 일치하는 string이 있는 파일 혹은 폴더에 적용                           |
| `?`            | 일치하는 string이 있는 파일 혹은 폴더에 적용                           |
| `[name]`       | name과 일치하는 파일 혹은 폴더에 적용                                  |
| `[!name]`      | name과 일치하지 않는 파일 혹은 폴더에 적용                             |
| `{s1, s2}`     | 일치하는 파일 혹은 폴더에 적용 (EditorConfig Core 0.11.0 이후 버전만 ) |
| `{num1..num2}` | 양수 혹은 음수인 num1과 num2 사이의 정수에 적용                        |



**예시**:

- `/hello/**/*`: 'hello' 폴더 안의 폴더 혹은 파일에 적용
- `**/*.js`: 어떤 폴더 안의 '.js'로 끝나는 파일에 적용
- `!*.xml`: '.xml'을 제외한 파일에 적용

.editorconfig

```shell
# 최상위에 있는 파일로 명시
root = true

# 모든 파일에 적용
[*]
end_of_line = lf
insert_final_newline = true

# '.js'과 '.py'로 끝나는 파일에 적용
[*.{js,py}]
charset = utf-8

# '.scss' 혹은 '.sass'로 끝나는 파일에 적용
[*.{scss,sass}]
indent_style = space
indent_size = 2

# 'Makefile'과 일치하는 파일 혹은 폴더에 적용
[Makefile]
indent_style = tab

# lib 폴더 안에 있는 .js 파일에 적용
[lib/**.js]
indent_style = space
indent_size = 2

# package.json 혹은 .travis.yml 파일에 적용
[{package.json,.travis.yml}]
indent_style = space
indent_size = 2
```

### EditorConfig Properties

- `indent_style`: 들여 쓰기를 'tab', 'space'중 어떤 걸로 할 것인지 설정
- `indent_size`: `indent_style = space`일 경우, 몇 칸 할 것인지 설정
- `tab_width`: `indent_style = tab`일 경우 width 설정 (기본적으로 `indent_size` 값을 따라가 거의 설정하지 않음)
- `end_of_line`: 'lf', 'cr', 'crlf'중 하나로 줄바꿈 설정

  
    용어: LF, CR, CRLF
    
        LF(Line Feed, \n): 커서를 다음 줄로 이동
        CR(Carriage Return, \r): 현재 커서를 줄 바꿈 없이 가장 좌측으로 이동
        윈도우에서는 주로 CRLF를 사용하며, 리눅스/맥(10버전 이후)에서는 LF를 사용한다
    
  

- `charset`: 'latin1', 'utf-8', 'utf-8-bom', 'utf-16be' or 'utf-16le' 중 하나로 문자 인코딩 방식 설정 (주로 'utf-8'로 설정)
- `trim_trailing_whitespace`: 'true'일 경우, 문자 앞의 공백을 제거
- `insert_final_newline`: 'true'일 경우, 파일을 저장할 때 새 줄로 끝남
- `root`: root 폴더의 파일에 설정하며, 'true'일 경우 `.editorconfig` 파일 검색을 중지

## 결론

따라서 만약 한 팀 내에서 서로 다른 에디터, IDE를 사용한다면 EditorConfig를 먼저 설정하고, ESLint, Prettier를 설정한다.

그게 아니라면 ESLint로 코드 퀄리티를 잡고, Prettier로 세세한 코드 포맷팅을 잡으면 된다.



**참고**



- https://editorconfig.org/
- https://blog.theodo.com/2019/08/why-you-should-use-eslint-prettier-and-editorconfig-together/


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/redux/react-redux-intro</guid>
      <title>React-redux 이해하기</title>
      <link>https://www.howdy-mj.me/redux/react-redux-intro</link>
      undefined
      <pubDate>Tue, 13 Oct 2020 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>redux</category><category>react</category>
      <content:encoded>
## Redux란?

React 프로젝트의 규모가 커질때마다 자식으로 넘겨주어야 하는 props의 깊이도 점점 깊어진다. 따라서, 어디에서든 내가 원하는 state를 사용할 수 있는 라이브러리 [Redux](https://redux.js.org/)가 나타났다.

_Redux는 React 뿐만 아니라, Angular, Vue, 바닐라 JS 등에서도 모두 사용가능하지만, 해당 글은 React만 다룬다_

Redux만 사용하여 React에서 사용할 수 있지만, 더 편하게 사용하기 위해 [React-Redux](https://react-redux.js.org/)가 나왔다.

## React-redux 알아보기


  
  완성 화면


왼쪽의 노래 목록에서 클릭(select)한 것을 오른쪽에 띄워보는 프로젝트를 만들어보며, react-redux에 대해 알아보자. 해당 프로젝트는 [Modern React with Redux (Udemy)](https://www.udemy.com/course/react-redux/)의 내용을 토대로 만들었다.



### 세팅

```shell
$ create-react-app songs
$ cd songs
$ npm install redux react-redux
```

`src`안의 내용을 전부 삭제 후, 밑의 구조처럼 폴더와 파일을 생성한다.

```
src
├─ actions
├─ components
├─ reducers
└─ index.js
```

src/index.js

```js
import React from 'react'
import ReactDOM from 'react-dom'
import App from './components/App'

ReactDOM.render(, document.querySelector('#root'))
```

src/components/App.js

```js
import React from 'react'

const App = () => {
  return App
}

export default App
```

그리고 스타일링에 신경쓰지 않기 위해 `public/index.html`에 [Semantic-ui](https://cdnjs.com/libraries/semantic-ui)를 추가한다.

```html


  


```



### action creator, reducer 생성

본격적으로 리덕스로 상태관리를 하기 위해 먼저 action creators를 만든다.

src/actions/index.js

```js
// action creator
export const selectSong = song => {
  // return an action
  return {
    type: 'SONG_SELECTED',
    payload: song,
  }
}
```

src/reducers/index.js

```js
// 노래 목록을 알려주는 reducer
const songsReducer = () => {
  // 아무것도 바꾸지 않기 때문에 어떠한 argument도 없음
  return [
    { title: '소주 한잔', duration: '4:51' },
    { title: 'Memories', duration: '3:10' },
    { title: '널 좋아하나봐', duration: '3:44' },
    { title: '거짓말이라도 해서 널 보고싶어', duration: '3:48' },
  ]
}

// 선택된 노래를 알려주는 reducer
const selectedSongReducer = (selectedSong = null, action) => {
  // 선택된 노래의 초기값을 null로 두고, action을 가져오기 위해 인자로 받아 옴
  if (action.type === 'SONG_SELECTED') {
    return action.payload
  }
  return selectedSong
}
```

그 후, 만든 action creator와 reducers를 `src/index.js`에게 알려주어 전역에 뿌려야 한다.

그러기 위해서 우선 reducer를 하나로 묶어 준다.

src/reducers/index.js

```js
import { combineReducers } from 'redux'

// 노래 목록을 알려주는 reducer
const songsReducer = () => {
  // 아무것도 바꾸지 않기 때문에 어떠한 argument도 없음
  return [
    { title: '소주 한잔', duration: '4:51' },
    { title: 'Memories', duration: '3:10' },
    { title: '널 좋아하나봐', duration: '3:44' },
    { title: '거짓말이라도 해서 널 보고싶어', duration: '3:48' },
  ]
}

// 선택된 노래를 알려주는 reducer
const selectedSongReducer = (selectedSong = null, action) => {
  // 에러 방지를 위해 selectedSong의 초기값을 null로,
  // action을 가져오기 위해 인자로 받아 옴
  if (action.type === 'SONG_SELECTED') {
    return action.payload
  }

  return selectedSong
}

export default combineReducers({
  songs: songsReducer,
  selectedSong: selectedSongReducer,
})
```



### 전역에서 state 가져오기

src/index.js

```js
import React from 'react'
import ReactDOM from 'react-dom'
import { Provider } from 'react-redux'
import { createStore } from 'redux'
import App from './components/App'
import reducers from './reducers'

const store = createStore(reducers)
// 생성한 store안에 모든 전역 state를 넣어 관리

ReactDOM.render(
  
    // 전역에서 사용가능하도록 App.js를 감싸준다
    
  ,
  document.querySelector('#root')
)
```

노래 목록을 볼 수 있는 components를 만들고, `App.js`에서 불러온다.

src/components/SongList.js

```js
import React from 'react'

const SongList = () => {
  return SongList
}

export default SongList
```

src/components/App.js

```js
import React from 'react'
import SongList from './SongList'

const App = () => {
  return (
    
      
    
  )
}

export default App
```



### connect()() 이해하기

이제 store로 뿌려준 state가 전역에서 잘 나타나는지 확인해 보면 된다. 이때 store와 해당 state를 사용하고 싶은 컴포넌트에서 `connect`를 사용하여 확인할 수 있다. connect는 그 안의 return 값을 반환한다.

```js
function connect() {
  return function() {
    return '하우디엠제이'
  }
}
```

만약 위와 같은 connect함수가 있을 때, 호출하면 아래와 같은 결과가 나온다.

```js
connect() // output: f()
connect()() // output: '하우디엠제이'
```

위와 같은 원리로, 내가 가져오고 싶은 components에서도 아래처럼 connect로 감싸주어야 한다.

src/components/SongList.js

```js{11}
import React from 'react'
import { connect } from 'react-redux'

const SongList = () => {
  return SongList
}

const mapStateToProps = state => {
  // getState와 같은 이름으로 지어도 되지만,
  // 관행상 mapStateToProps를 사용한다
  console.log(state)
  return state
}

export default connect(mapStateToProps)(SongList)
```

위처럼 작성했다면, 아래와 같은 console 화면이 뜬다.


  
  SongList - console.log(state)


정상적으로 state를 가져오는 것을 확인할 수 있다.
위의 이미지에서 확인할 수 있듯이, state가 객체에 한번 감싸져 온다.
비구조화 할당을 통해 바로 꺼낼 수 있도록 가져오자.

```js{4}
// src/components/SongList.js
// ...
const mapStateToProps = state => {
  console.log({ songs: state.songs })
  return { songs: state.songs }
}
```


  
  SongList - console.log({ songs: state.songs })


그리고 이제 컴포넌트 안에서도 props로 제대로 가져오고 있는지 확인해보자.

```js{4}
// src/components/SongList.js
// ...
const SongList = props => {
  console.log(props)
  return SongList
}

const mapStateToProps = state => {
  return { songs: state.songs }
}
```


  
  SongList - console.log(props)


보면 `dispatch()`도 같이 가져오는 것을 확인할 수 있다.

이제 가져온 props로 화면을 구성해보자.

src/components/SongList.js

```js
// ...
const SongList = props => {
  const renderList = () => {
    return props.songs.map(song => {
      return (
        
          
            Select
          
          {song.title}
        
      )
    })
  }
  return {renderList()}
}
```

src/components/App.js

```js
// ...
const App = () => {
  return (
    
      
        
          
        
      
    
  )
}
```


  
  SongList 화면




### action creator 동작

이제 오른쪽 Select 버튼을 눌렀을 때, 실제로 리덕스에 반영하기 위해 행동을 취해주는 action creator를 가져오자. 이때 가져온 action creator는 `connect()`의 두 번째 인자에 작성한다.

src/components/SongList.js

```js{26,27,28}
import React from 'react'
import { connect } from 'react-redux'
import { selectSong } from '../actions'

const SongList = props => {
  console.log(props) // 잘 들어왔는지 확인
  const renderList = () => {
    return props.songs.map(song => {
      return (
        
          
            Select
          
          {song.title}
        
      )
    })
  }
  return {renderList()}
}

const mapStateToProps = state => {
  return { songs: state.songs }
}

export default connect(mapStateToProps, {
  selectSong, // selectSong: selectSong과 같은 것
})(SongList)
```

찍어본 console을 보면,


  
  SongList - console.log(props)


아무것도 없었던 `dispatch()`가 `selectSong()`으로 바뀐 것을 확인할 수 있다. 이제 button에 onClick 함수를 추가하여 제대로 동작하는지 확인해보자.

src/components/SongList.js

```js{10}
// ...
const SongList = props => {
  const renderList = () => {
    return props.songs.map(song => {
      return (
        
          
             props.selectSong(song)}
            >
              Select
            
          
          {song.title}
        
      )
    })
  }
  return {renderList()}
}

const mapStateToProps = state => {
  console.log(state) // selectSong이 잘 동작하는지 확인
  return { songs: state.songs }
}

export default connect(mapStateToProps, { selectSong })(SongList)
```

위의 코드 추가 후, 아무 Select 버튼을 클릭하면 선택된 것을 console 창에서 확인할 수 있다.


  
  SongList - selectSong 동작




#### 왜 action creator는 import하고 바로 사용하지 못할까?

분명 위에 `import { selectSong } from '../actions'`를 했는데도 왜 다시 `export default connect(mapStateToProps, { selectSong })(SongList)`에 작성해야 하는가라는 의문이 있었다.

그 이유는, 만약 위에서 import한 action creator를 해당 컴포넌트 내부에서 바로 사용하게 되면, 만든 action creator의 object가 실행될 뿐, 리액트는 이것을 dispatch로 실행해야하는지 감지하지 못한다.

```js{12}
// src/components/SongList.js
// 리액트가 selectedSong을 일반 함수로 착각하여
// dispatch로 실행하지 못함
const SongList = props => {
  const renderList = () => {
    return props.songs.map(song => {
      return (
        
          
             selectSong(song)}
            >
              Select
            
          
          {song.title}
        
      )
    })
  }
  return {renderList()}
}
// ... 생략
export default connect(mapStateToProps)(SongList)
```

위 처럼 일반 함수로 사용한다면, 리액트는 이를 감지하지 못하여 store에도 아무런 변화가 없다.



### SongDetail 구현

src/components/SongDetail.js

```js{8}
import React from 'react'
import { connect } from 'react-redux'

const SongDetail = ({ selectedSong }) => {
  // 비구조화 할당으로 {selectedSong}만 가져오기
  // 원래는 props로 가져온다면,
  // props.selectedSong.title, props.selectedSong.duration으로 작성
  console.log(selectedSong)
  return Please select a song!
}

const mapStateToProps = state => {
  // selectedSong이란 이름으로 선택된 노래 가져오기
  return { selectedSong: state.selectedSong }
}

export default connect(mapStateToProps)(SongDetail)
```

src/components/App.js

```js
import React from 'react'
import SongList from './SongList'
import SongDetail from './SongDetail'

const App = () => {
  return (
    
      
        
          
        
        
          
        
      
    
  )
}

export default App
```

console을 확인해보면, 처음에는 `null`이었다가, select 누른 노래가 console 창에 뜨는 걸 확인할 수 있다.

이제 `selectedSong`이 있을 때, 화면에 나타나게 해보자.

src/components/SongDetail.js

```js
// ...
const SongDetail = ({ selectedSong }) => {
  return (
    <>
      {!selectedSong ? (
        // 선택한 곡이 없을 때 화면
        Please select a song!
      ) : (
        // 선택한 곡이 있을 때 화면
        
          노래 상세
          제목: {selectedSong.title}
          시간: {selectedSong.duration}
        
      )}
    
  )
}
// ...
```


  
  SongDetail 동작


정상적으로 화면에 구현되는 것을 확인할 수 있다.

완성 코드: [songs-react-redux](https://github.com/howdy-mj/songs-react-redux)
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/boilerplate/craco-absolute-paths-setting</guid>
      <title>CRA + Typescript 절대경로 설정 (w/craco)</title>
      <link>https://www.howdy-mj.me/boilerplate/craco-absolute-paths-setting</link>
      undefined
      <pubDate>Sun, 11 Oct 2020 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>boilerplate</category>
      <content:encoded>
## CRA + TypeScript에서 절대경로 설정

폴더 구조가 겹겹인 경우, import 경로를 상대경로하면 코드가 너무 길어지고 보기 어렵다.

절대 경로를 사용하기 위해서는 `tsconfig.json`과 webpack 설정을 바꾸면 되지만, `tsconfig.json`에서 paths를 수정하고 `yarn start`를 하면 강제적으로 작성한 paths가 없어진다.

이는 CRA로 만든 프로젝트는 eject를 해서 숨겨진 webpack 설정을 바꾸어야 하는데, 그러기엔 CRA로 만든 장점이 없어지기 때문에 [craco](https://www.npmjs.com/package/@craco/craco)를 사용하는 것이 편하다.

## Craco란?

**Craco**(Create React App Configuration Override)는 create-react-app(CRA)을 쉽게 설정하기 위해 만들어졌다.

CRA에서 eject를 하지 않아도, root 폴더에 `craco.config.js`를 추가함으로 eslint, babel, postcss 등을 쉽게 설정할 수 있다.

CRA 4.\*, Yarn, NPM, Lerna, custom react-scripts에서 사용가능하다.



```shell
$ yarn add @craco/craco
$ yarn add craco-alias -D
```

패키지 설치 후, root 폴더에서 아래의 파일을 생성하자.

craco.config.js

```js
const CracoAlias = require('craco-alias')

module.exports = {
  plugins: [
    {
      plugin: CracoAlias,
      options: {
        source: 'tsconfig',
        baseUrl: './src',
        tsConfigPath: './tsconfig.extend.json',
      },
    },
  ],
}
```

### Options 설정

- `source`: default 값은 `options`로, `jsconfig`, `tsconfig` 선택 가능

- `baseUrl`: default 값은 `./`로 root 폴더를 가리킴

- `aliases`: alias 이름과 경로, default 값은 `{}`

- `tsConfigPath`: 만약 `source`가 `tsconfig`이라면 해당 파일 이름 작성

- `debug`: default 값은 false이며, 만약 버그가 생긴다면 해당 값을 true로 바꾸어 console로 내용 확인 가능



tsconfig.extend.json

```json
{
  "compilerOptions": {
    "baseUrl": "./src",
    "paths": {
      // 파일
      "@app": ["./App.tsx"],

      // 폴더
      "@pages/*": ["./pages/*"],
      "@components/*": ["./components/*"],
      "@styles/*": ["./styles/*"]
    }
  }
}
```

"Can't parse tsconfig.extend.json."이라는 에러가 뜬다면, `tsconfig.extend.json` 마지막 줄에 콤마(`,`)가 있는지 확인하고 없애야 한다.

ex. `"@styles/*": ["./styles/*"],`이라면 마지막 `,`를 삭제



그리고 `tsconfig.json`, `package.json` 파일에서 아래의 항목을 추가/수정 한다.

tsconfig.json

```json
{
  "extends": "./tsconfig.extend.json",
  "compilerOptions": {
    //...
  }
}
```

package.json

```json
"scripts": {
    "start": "craco start",
    "build": "craco build",
    "test": "craco test",
    "eject": "react-scripts eject"
  },
```

다 마쳤다면, 다른 곳에서 아래와 같이 import가 가능하다.

```js
import Example from '@pages/Example'
```



**참고**



- [@craco/craco](https://www.npmjs.com/package/@craco/craco)
- [craco-alias](https://github.com/risenforces/craco-alias#readme)


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/storybook/svg-undefined</guid>
      <title>스토리북 SVG undefined 에러</title>
      <link>https://www.howdy-mj.me/storybook/svg-undefined</link>
      undefined
      <pubDate>Wed, 23 Sep 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>storybook</category>
      <content:encoded>
Storybook에서 SVG 파일을 컴포넌트로 렌더하면 undefined가 뜬다.

`에러가 나는 코드`

```js
import React from 'react'
import { ReactComponent as SVGFile } from './example.svg'

console.log(SVGFile) // undefined
```

`에러 화면`

> Storybook: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: undefined.



화면 렌더 자체가 불가하다


이는 스토리북의 기본 webpack 설정에 이미 file-loader로 svg를 변환하고 있기 때문에 나는 에러이다.

storybook/preview/base-webpack.config.js

```js
// ...
{
  test: /\.(svg|ico|jpg|jpeg|png|gif|eot|otf|webp|ttf|woff|woff2|cur|ani)(\?.*)?$/,
  loader: require.resolve('file-loader'),
  query: {
    name: 'static/media/[name].[hash:8].[ext]',
  },
},
// ...
```

전문: [storybook base-webpack.js](https://github.com/storybookjs/storybook/blob/4da246bbe9413510b48d1ab8b9faf4fae4656d92/lib/core/src/server/preview/base-webpack.config.js#L36-L40)

따라서, 스토리북에서 svg import가 기본 file-loader 설정보다 먼저 실행해야 하기 때문에 `unshift`로 넣어주면 된다.

## 해결법

```shell
$ npm install @svgr/webpack --save-dev
```

./storybook/main.js

```js
// ...
module.exports = {
 // ...
  webpackFinal: async config => {
    // ...
    config.module.rules.unshift({
      test: /\.svg$/,
      use: [‘@svgr/webpack’],
    });
    // ...
    return config;
  }
}
```

어떤 사람은 기존의 file-loader 설정에서 `svg`를 없애는 작업을 먼저 해줘야 한다고 했지만, 이렇게 해도 작동은 된다.



**참고**



- https://duncanleung.com/import-svg-storybook-webpack-loader/
- https://github.com/storybookjs/storybook/issues/6188


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/storybook/storybook-6-guide</guid>
      <title>Storybook 6 가이드</title>
      <link>https://www.howdy-mj.me/storybook/storybook-6-guide</link>
      undefined
      <pubDate>Wed, 23 Sep 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>storybook</category>
      <content:encoded>
해당 글은 Storybook 6 Migration Guide과 공식 홈페이지를 참고하였고, React 기준으로 작성되었습니다.



지난 스토리북 글을 작성했을 때에도 Storybook 5.3 참고 글이 별로 없어 쓰는데 오래 걸린다는 핑계로 계속 안 쓰고 있었다.(반성...) 그런데 지난 8월 Storybook 6(SB6)이 릴리즈 되면서 다시 새로운 모습으로 돌아와 글을 써보고자 한다.

## Storybook 6 마이그레이션 가이드

작년(2019) 봄, [Storybook 5.0](https://medium.com/storybookjs/storybook-5-0-db1d0f9c83b8)은 주로 인터페이스를 신경썼다면, Storybook 6.0은 개발자 경험을 향상 시켰다.

**패키지 업데이트**

```shell
$ npx sb upgrade
# or
$ yarn storybook
```

`@storybook/*` 패키지 모두 업그레이드 된다.



### 달라진 점

**TypeScript 빌트인 지원 (zero-config)**

- 예전처럼 복잡하게 `.storybook` config를 설정하지 않아도 된다. 또한, `@storybook/addon-docs`에서도 바로 prop 테이블을 확인할 수 있다.
- 기존 버전에서 6.0으로 마이그레이션 하는 프로젝트는 설정해 둔 타입스크립트 webpack/babel config와 `@storybook/preset-typescript`를 삭제하고 재 설정할 것을 권장한다.
- Storybook 5.3에서 소개한 `main.js` 파일에 `stories` property를 넣으면 되고, 기존에 glob이 인식되지 않은 문제도 해결했다.

./storybook/main.js

```js
{
  ...
  stories: ['./**/*.stories.@(ts|js)']
}
```

[TypeScript Configure](https://storybook.js.org/docs/react/configure/typescript)에서 자세한 타입스크립트 설정을 확인할 수 있다.



**Hierarchy separators 제거**

- hierarchy separators는 그룹화 할 때 사용되며, 사이드바에서 그룹 별로 확인 가능하다. 예전 버전은 `|`와 `.`도 사용이 가능했지만, 지금은 `/`로 통일되었다.

```shell
$npx sb@next migrate upgrade-hierarchy-separators --glob="*/**/*.stories.@(tsx|jsx|ts|js)"
```

- 이로 모두 `/`로 바꿀 수 있지만, `.mdx` 컴포넌트 안에 있는건 수동으로 바꿔 줘야 한다.

- 현재는 'roots'를 기본으로 보여주지만, disable도 가능하다.

./storybook/manager.js

```js
import addons from '@storybook/addons'
addons.setConfig({
  showRoots: false,
})
```



**`addon-info`, `addon-notes`, `addon-contexts`, `addon-centered`등 사용 중지**

- `addon-info`, `addon-notes`는 `addon-docs`로 대체되었다. ([마이그레이션 문서](https://github.com/storybookjs/storybook/blob/next/addons/docs/docs/recipes.md#migrating-from-notesinfo-addons) 참고)

- `addon-contexts`는 `addon-toolbars`로 대체되었다. 더 간단하고 모든 Storybook 프레임워크와 호환된다.

- `addon-centered`는 각 Storybook 컴포넌트에서 손 쉽게 중앙 정렬이 가능하여 삭제되었다.

```js
export const MyStory = () => my story
MyStory.story = {
  parameters: { layout: 'centered' },
  // padded, fullscreen 값도 존재
}
```

- `.storybook/preview.js`에서 `addParameters`, `addDecorator` 대신 `export const parameter = {}` 혹은 `export const decorators = []` 사용을 권장한다. ([Preview entries](https://github.com/storybookjs/storybook/blob/next/docs/api/writing-presets.md#preview-entries))

- Hot Module Reloading(HMR)) 이슈로 다수의 파일로 컴포넌트를 복제하는 기능도 중지되었다. `export default { title: 'foo/bar' }`가 stories에 있다면 `Duplicate title '${kindName}' used in multiple files` 경고가 뜬다. 이는 7.0에서 완전히 삭제될 예정이다.



**`addon-docs` 전면 개편**

- SB 5.2에서 사용하는 `@storybook/addon-docs/react/preset`을 SB 5.3에서 `@storybook/addon-docs/preset`로 합쳤다. 그리고 6.0에서 사용 중단된 preset이 제거되었다.

- `Preview`는 `Canvas`로, `Props`는 `ArgsTable`로 이름이 바뀌었다.

- docs의 테마는 `./storybook/preview.js`에서 설정가능하다.

```js
import { themes } from '@storybook/theming'
// or global addParameters
export const parameters = {
  docs: {
    theme: themes.dark,
  },
}
```

- zero-config TypeScript로 따로 설정을 하지 않아도 바로 React의 prop 테이블이 보인다.

- 이 외의 내용은 [Docs breaking changes](https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#60-docs-breaking-changes)에서 확인 가능하다.



Storybook 6.0 Migration 전문은 [여기서](https://github.com/storybookjs/storybook/blob/next/MIGRATION.md) 볼 수 있다.

## Storybook Configure

Storybook의 configure는 SB 5.3에서 개편되었다. `presets.js`는`main.js`, `config.js`는 `preview.js`, `addons.js`는 `manager.js`로 이름을 바꾸었다. 모두 `.storybook` 폴더 안에 생성한다.

### main.js

메인 config 파일로 스토리북의 생성(generation)을 담당한다. 예를 들어, story 파일들의 위치, presets 관리(webpack, babel이 다른 파일을 허용할 수 있도록), webpack config 정규화 업무 그리고 기본적인 addon 설정도 `main.js`에 작성한다.



https://medium.com/storybookjs/declarative-storybook-configuration-49912f77b78




### preview.js

`config.js`를 대체하며, stories의 렌더링을 설정한다. `config.js`와 달리 `preview.js`는 어느 stories의 로딩도 책임지지 않는다. 주 목적은 global parameters와 decorators를 추가하는 것이다.



https://medium.com/storybookjs/declarative-storybook-configuration-49912f77b78




### manager.js

`addons.js`를 대체하며, Storybook의 UI 렌터를 커스텀할 수 있다. Canvas를 제외한 모든 화면을 뜻한다.



https://medium.com/storybookjs/declarative-storybook-configuration-49912f77b78




## Stories 포맷

SB 6에서 개발 경험을 향상했다고 했는데, 필자가 느끼는 가장 큰 차이는 Stories 포맷이다. 기존 `storiesOf`를 대체할 [Component Story Format(CSF)](https://storybook.js.org/docs/react/writing-stories/introduction#component-story-format)이 나왔다.

더 간단하고, 직관적이며 ES6도 자유롭게 사용할 수 있어 Jest, Cypress와 같은 테스트도 가능하다.

```js
// Button.js 컴포넌트를 import 한 후,

// storeisOf
storiesOf('atoms/Button', module)
  .add('text', () => Hello)
  .add('emoji', () => 😀😎👍💯)

// CSF
export default { title: 'atoms/Button' }
export const text = () => Hello
export const emoji = () => 😀😎👍💯
```

컴포넌트의 arguments도 쉽게 넘겨줄 수 있다.

```js
// Button.stories.js
const Template = (args) => ;

// Each story then reuses that template
export const Primary = Template.bind({});
Primary.args = { background="#ff0",  label: 'Button' };

export const Secondary = Template.bind({});
Secondary.args = {  ...Primary.args,  label: '😄👍😍💯',};

export const Tertiary = Template.bind({});
Tertiary.args = {  ...Primary.args,  label: '📚📕📈🤓',};
```

`Template.bind({})`는 코드 중복을 줄이며 복사본을 만들 수 있다. `...Primary.args`는 Primary의 args를 복사한다.

그리고 `addon-knobs` 보다 더 좋은 `controls`가 나타났다.



  
  

storybook 홈페이지


다음 몇 개의 글에서 더 자세한 stories 작성법, addons에 대해 다뤄보겠다.



**참고**



- https://github.com/storybookjs/storybook/blob/next/MIGRATION.md
- https://medium.com/storybookjs/declarative-storybook-configuration-49912f77b78





피드백은 언제나 환영합니다
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/css/about-bem</guid>
      <title>BEM(Block Element Modifier)이란?</title>
      <link>https://www.howdy-mj.me/css/about-bem</link>
      undefined
      <pubDate>Tue, 22 Sep 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>css</category>
      <content:encoded>
개발자가 가장 힘들어 하는 일은 변수, 함수, 클래스 등의 '이름 짓기'다.



https://abibablog.wordpress.com/2016/01/13/programmers-hardest-tasks/


어떤 이름이 깔끔하고, 겹치지 않으며 재사용할 수 있고, 다른 사람이 한번에 팍하고 알아볼 수 있을까?

## BEM(Block Element Modifier)

BEM은 Block, Element, Modifier의 줄임말로 CSS 방법론 중 하나로, 스타일링 구조를 정의한다.

기본 구조는 `block__element--modifier`이다.

조금 더 쉽게 설명하기 위해 아래 구조를 예로 들겠다.





```html

  
    
      &nbsp;
      
        
          The Sea Explorer
      
      
        
          3 day tours
          Up to 30 people
          2 tour guides
          Sleep in cozy hotels
          Difficulty: easy
        
      
    
  
  ...

```

전체 코드는 Github Repo에서 볼 수 있다.



### Block

Block은 `card`와 같이 하나의 독립된 영역을 말한다. 이 외, header, footer, menu 등 누가 봐도 하나로 묶을 수 있는 것을 block으로 볼 수 있다.

Block은 중첩(Nesting)이 가능하여, 안에 다른 Block이 올 수 있다.

```html

  
    ...
  

```

`section-tours`라는 블록 아래에 `card` 블록이 있다.



### Element

Element는 `card__heading`, `card__details`처럼 어떤 목적인지 나타낸다. 이 외, input, text 등에도 사용 가능하다.

Element도 중첩이 가능하지만, Block과 마찬가지로 한 번만 사용이 가능하다.

```html


  
    ...
  

```

만약 ul태그에 Element를 붙이자면, `card__ul`로 할 수 있다.

```html

  
    
    
    
  

```

이것처럼 하나의 Block에서 하나의 Element만 받는다. 하지만 Block에 속해 있는 상태에서 밖에서 사용할 수 없다.

```html


  ...


  Details

```



### Modifier

Modifier는 `card__side--front`와 같이 해당 요소의 형태(상태)를 나타낸다. (해당 글에서는 코드를 다 가져오지 못했지만, `card__side--back`도 존재한다)

Modifier를 `__`로 작성하는 곳도 있지만, 필자는 Element와 구분짓기 쉽고, 직관적인 [Get BEM](http://getbem.com/)을 따른다.

Modifier는 Block 다음에 바로 올 수도 있다. 예를 들면 `card--large`, `card--hidden`이 있다.



물론 프로젝트, 기업 마다 준수하는 스타일 가이드는 다 다르며 각자의 상황에 맞게 협의하여 사용하면 된다.



**참고**



- http://getbem.com/
- https://en.bem.info/


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/css/styled-components-with-global-style</guid>
      <title>Styled Components를 Global에서 사용하기(w/반응형)</title>
      <link>https://www.howdy-mj.me/css/styled-components-with-global-style</link>
      undefined
      <pubDate>Tue, 15 Sep 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>css</category><category>css-in-js</category>
      <content:encoded>
_해당 글은 React를 기준으로 작성되었습니다._

## Styled Components란?

Styled Components는 CSS-in-JS의 하나로, CSS를 하나의 컴포넌트로 만들어 주는 것이다.

**Styled Components 설치**

```shell
$ npm install --save styled-components
```



Button 자체가 하나의 Component가 되어 props도 바로 넘겨줄 수 있다.

더 자세한 내용은 공식 [홈페이지](https://styled-components.com/)를 참고하길 바란다.



프로젝트를 진행하다보면 공통적으로 사용해야 하는 스타일이 있다.

대표적인 예로는 색상, 폰트, padding/margin 그리고 반응형 breakpoint 등이 존재한다.

물론 컴포넌트 수가 몇 개 없고, 추가 할 스타일도 별로 없다면 각 컴포넌트에서 코딩해도 전혀 문제 없다. 하지만 프로젝트 규모가 커지면 여러 곳에서 해당 스타일을 반복적으로 작성해야 하며, 하는 도중에 숫자를 잘못 적는다던지, 오타가 있어 스타일이 제대로 적용되지 않을 수도 있다.

이러한 실수를 방지하고 더 편하게 코딩하고자 전역에서 사용할 수 있는 스타일을 만드는 것이 좋다.

## Global에서 사용될 style 생성 및 적용

아래 예제에서는 메인컬러와 반응형을 다뤄보겠다.

src/style/theme.js

```js
const size = {
  mobile: '600px',
  tablet: '900px',
  laptop: '1200px',
  desktop: '1800px',
}

const theme = {
  mainColor: '#0a4297',
  mobile: `(max-width: ${size.mobile})`,
  tablet: `(max-width: ${size.tablet})`,
  laptop: `(max-width: ${size.laptop})`,
  desktop: `(min-width: ${size.desktop})`,
}

export default theme
```

Breakpoint는 기기의 크기보다는 비슷한 종류를 묶어 정하는 것이 좋다. 예를 들면 핸드폰, 태블릿, 노트북 등 비슷한 그룹을 생각하면 된다.

웹 화면을 중심으로 모바일 화면을 조절한다면 `max-width`를 쓰고, 모바일 중점인 웹 화면을 조절하면 `min-width`를 사용한다. 본 글에서는 1200 ~ 1800px을 중점으로 작은 기기의 화면을 맞추는 것이기에 `max-width`를 썼다.

그리고 브라우저에 존재하는 기본 CSS 스타일(user agent stylesheet)을 제거해주기 위해 `global.js`도 만들어 보자.

src/style/global.js

```js
import { createGlobalStyle } from 'styled-components'

const GlobalStyle = createGlobalStyle`
  * {
    margin: 0;
    padding: 0;  
  }

  body {
    box-sizing: border-box;
  }
`

export default GlobalStyle
```

이제 만든 두개의 `.js` 파일을 전역에 적용시켜 보자.

```jsx
import React from 'react'
import ReactDOM from 'react-dom'
import App from './App'
import { ThemeProvider } from 'styled-components'
import theme from './style/theme'
import GlobalStyle from './style/global'

ReactDOM.render(
  
    
      
      
    
  ,
  document.getElementById('root')
)
```

그리고 이제 어느 컴포넌트에서든 스타일을 적용할 수 있다.

```js
// 반응형

const MainWrap = styled.main`
  width: 1200px;

  @media ${props => props.theme.tablet} {
    width: 100%;
    margin: 0 auto;
  }
`

// 색상
const MainText = styled.div`
  color: ${props => props.theme.mainColor};
`
```
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/network/what-is-http</guid>
      <title>HTTP란? HTTP 메세지, 웹의 구성요소</title>
      <link>https://www.howdy-mj.me/network/what-is-http</link>
      undefined
      <pubDate>Wed, 26 Aug 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>network</category>
      <content:encoded>
해당 글은 HTTP/1.1 - RFC7230 문서를 기준으로 작성되었습니다.

> HTTP는 브라우저와 서버가 대화를 할 때 사용하는 것이다. HTTP를 이해하면 웹의 동작 원리를 이해한 다는 것이며, 웹 서버와 네트워크를 관리할 때 정확한 근거로 올바른 판단을 내릴 때 도움이 될 수 있다.

## HTTP란?

**HTTP**(HyperText Transfer Protocol)는 브라우저와 서버가 서로 소통을 할 수 있도록 만들어진 규약이다.



### 우리가 보는 웹은 모두 HTTP 요청/응답으로 보여지는 화면이다

사용자는 주소창에 URL을 입력하면 원했던 화면이 뜬다.

이때 주소창에 URL을 입력하고 엔터를 누르는 행위가 HTTP 요청을 보내는 것이고, 웹 페이지가 뜨는 것이 응답을 받은 것이다.

URI란? (feat. URL, URN)



구글에서 Network 탭을 보면 요청(Request)과 응답(Response) 내용을 확인할 수 있다.



### HTTP는 어떻게 정해질까?

HTTP는 IETF(인터넷국제표준화기구)에서 **RFC 문서** 채택을 통해 이루어진다.

IETF는 인터넷과 TCP/IP의 기술 표준을 정하는 국제적 기구이다. 어떤 사람이 기술 표준에 대한 초안을 작성해 배포하면, 서로 의견을 제시하며 토론하고 최종적으로 받아들여 지는 것을 인터넷 표준으로 채택한다. 이런 초안을 RFC(Request for Comments)라고 하며 '비평을 기다리는 문서'의 의미를 갖는다.

RFC 편집자는 매 문서에 일련번호와 함께 배포하며, 절대 폐지되거나 수정되지 않는다. 만약 어떤 RFC 문서의 수정이 필요하다면, 수정된 문서를 다시 출판해야 한다. 이런 덮어쓰는 방식을 통해 RFC는 인터넷 표준의 역사를 나타내기도 한다.



### HTTP 특징

- 메세지 교환 형태의 프로토콜: 클라이언트가 보고 싶은 걸 서버에 요청하면 응답이 옴
- 비연결성(Connectionless): 클라이언트와 서버가 한 번 연결을 맺은 후, 클라이언트의 요청을 서버가 응답하면 맺었던 연결을 끊음. 불특정 다수의 통신을 줄여 더 많은 연결이 가능하지만, 동일한 요청을 새로 요청해야 함
- 무상태(Stateless): 이전 상태를 유지 하지 않음. 상태를 기억하기 위해서 쿠키, 세션, 토큰이 도입 됨

## HTTP 메세지

그렇다면 HTTP의 요청과 응답은 어떻게 생겼을까? 아래 그림과 같이 메세지 형태를 취하고 있다.


  
  https://www.oreilly.com/library/view/http-the-definitive/1565925092/ch01s05.html


HTTP 메세지는 요청과 응답으로 나뉘고 모두 `시작줄, 헤더, 본문`으로 이루어져 있다.

### 요청(Request)

```
Request Line:   
Headers: 

Body: 
```

### 응답(Response)

```
Status Line:   
Headers: 

Body: 
```

* 시작줄을 공통으로 Start Line이라 하는데, 요청은 Request Line으로, 응답은 Status Line이라 부를 수 있다.

- 마지막은 CRLF로 줄바꿈 한다.



### 1. 시작줄

요청은 무엇을 해야 하는지, 응답은 무슨 일이 일어났는지 알려 준다.

**[ 요청 ]**

```http
GET /doc/test.html HTTP/1.1
```

- 메서드(Method): 서버에 무엇을 해야 하는지 알려주는 것
- 요청 URL(Request target): 요청이 어디로 전송 되는지 알려주는 URL
- 버전(Version): HTTP 버전 (메세지의 구조를 결정하기 때문에 HTTP 버전을 알려줘야 함)

**[ 응답 ]**

```http
HTTP/1.1 200 OK
```

- 버전(Version): HTTP 버전 명시
- 상태 코드(Status Code): (숫자) 컴퓨터가 알아듣는 언어
- 사유 구절(Reason-phrase): (문자) 사람이 알아듣는 언어



### 2. 헤더

헤더는 크게 **일반(General) 헤더**, **요청(Request)/응답(Response) 헤더**, **엔터티(Entity) 헤더**로 나뉘며 모두 `key: value` 형식으로 작성한다.

**a. 일반 헤더:** 메세지에 대한 기본적인 정보 제공

```http
Via: 1.1 proxy-62.irenes-sip.net
Connection: kepp-alive
```

- Via: 어떤 중개자(프록시, 게이트웨이)를 거쳐 왔는지 보여 줌
- Connection: 클라이언트와 서버가 요청/응답 연결에 대한 옵션을 정할 수 있음

**b. 요청 헤더**: 서버에게 요청의 세부 정보 제공

```http
Accept: */*
User-Agent: Mozilla/5.0
Cookie: 쿠키 값
```

- Accept: 해당 요청이 받을 수 있는 미디어 타입
- User-Agent: 요청을 보내는 클라이언트(주체)의 정보 (ex. 브라우저 정보, ip주소 등)
- Cookie: 클라이언트가 서버에게 토큰을 전달할 때 사용

**c. 응답 헤더**: 브라우저에게 응답의 세부 정보 제공

```http
Server: gws
Age:
Set-Cookie:
```

- Server: 서버 애플리케이션의 이름과 버전
- Age: 응답이 얼마나 오래 되었는지
- Set-Cookie: 서버가 클라이언트를 인증할 수 있도록 토큰 설정할 때 사용

**d. 엔터티 헤더**: 바디의 컨텐츠를 나타냄

```http
Content-Type: text/html, application/json; charset=UTF-8
Content-Length: 345
```

- Content-Type: 본문의 MIME 타입을 서술 (보통 확장자 기반 타입 연계)
- Content-Length: 본문의 길이나 크기


    용어: MIME
      MIME(Multipurpose Internet Mail Extensions): 자료 파일 변환을 위한 포맷
    
      웹 서버는 받은 요청이 어떤 것인지 빠르게 알아내기 모든 HTTP 객체 데이터에 MIME 타입을 붙임
      MIME에는 메세지 종류를 나타내는 content-type, 메세지 인코딩 방식을 나타내는 content-transfer-encoding 등 같은 정보 정의
      MIME 타입은 type/subtype 형식으로 타입텍스트, 이미지, 오디오 등이, 서브타입에는 어떤 타입인지 구체적으로 서술
    
  



### 3. 본문

선택 사항으로 이미지, 비디오, 텍스트 등 여러 종류의 데이터를 담을 수 있다.

`GET, HEAD, DELETE, OPTIONS`처럼 리소스를 가져오는 요청은 보통 본문이 비어 있다.

## 웹의 구성요소

브라우저와 서버 간의 통신을 더 안전하고 효율적으로 하기 위해 중개자 역할을 하는 구성 요소가 나왔다. 대표적인 것으로 캐시, 프록시, 게이트웨이 등이 있다.

### 캐시(Cache)

처음에 여는데 오래 걸렸던 사이트를 다시 들어가면 처음보다 빠르게 켜질 때가 있다. 이는 브라우저가 문서의 사본을 HTTP 헤더 지시에 따라 보관한 덕분이다. 캐시는 불필요한 데이터 전송을 줄여 시간과 비용을 줄여 준다.

_(HTTP 캐시와 브라우저 캐시의 차이는 추후 작성)_



### 프록시(Proxy)

프록시는 클라이언트와 서버의 중개자로 같은 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결한다.

프록시는 실용적이고 유용한 일을 처리한다. 예를 들면 어린이에게 부적절한 사이트 필터, 문서 접근 제어, 보안 방화벽, 웹 캐시, 익명화 프록시 등이 있다.

**프록시와 게이트웨이 차이점**:
프록시와 밑에 설명하는 게이트웨이는 모두 중개자 역할을 한다. 하지만 프록시는 같은 프로토콜을 사용하는 애플리케이션을 연결한다면, 게이트웨이는 서로 다른 프로토콜을 사용하는 애플리케이션을 연결한다.


http://tlog.tammolo.com/blog/6-a52d91c3-232f-4b33-b9f3-4ef47fbbf973/



### 게이트웨이(Gateway) (a.k.a 리버스 프록시)

게이트웨이는 서로 다른 프로토콜과 애플리케이션을 연결해준다. 우리가 WiFi를 사용하여 인터넷을 하려 할때, PC가 공유기, 인터넷 회사 라우터를 거쳐 인터넷에 연결이 되는 것 역시 게이트웨이다.


http://tlog.tammolo.com/blog/8-c3068a1a-9ace-450d-a87e-e3cc6213955e/

HTTP/FTP와 HTTP/POP 등은 다른 프로토콜이란 걸 바로 알 수 있지만, HTTP/CGI는 이해가 잘 안돼서 찾아봤다.

_('클라이언트 측 프로토콜/서버 측 프로토콜'로 작성한다.)_


    용어: FTP, POP
    
      FTP(File Transfer Protocol): 파일을 교환하기 위해 사용
      POP(Post Office Protocol): 이메일을 가져오는데 사용
    




**참고**



- HTTP 완벽 가이드, 2014, 인사이트
- The IETF HTTP Working Group
- MDN - HTTP 메시지
- TCP의 헤더에는 어떤 정보들이 담겨있는걸까?
- O'Reilly - TCP Connections
  
- HTTP 요청과 응답
- 정보통신기술용어해설 - Proxy 프록시, 프락시
- CGI 소개
- The Common Gateway Interface (CGI) Version 1.1
- O'Reilly - The Common Gateway Interface (CGI)
- Combining JavaScript, CGI, and SSI
- CGI Programming Is Simple!
- [OS] 프로세스와 스레드의 차이


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/typescript/basic-typescript</guid>
      <title>타입스크립트(TypeScript) 소개 및 맛보기</title>
      <link>https://www.howdy-mj.me/typescript/basic-typescript</link>
      undefined
      <pubDate>Fri, 21 Aug 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>typescript</category>
      <content:encoded>
## 타입스크립트(TypeScript)

자바스크립트는 암묵적 타입 변환(Implicit coercion)으로, 개발자 혹은 엔진에 의해 암묵적으로 타입이 자동 변화 되기도 한다.

또한, 자바스크립트는 런타임 환경에서 에러를 보여주기 때문에 코드를 작성할 때에는 어떤 에러가 있는지 알지 못한다. 이는 곧 프로그램을 실행하기 전까지는 에러를 발견하지 못한다는 뜻이다.

타입스크립트는 이러한 맹점을 보완해준다. 타입스크립트는 개발자에 의해 의도적으로 타입을 변환하는 명시적 타입 변환(Explicit corecion)을 한다. 또한, 코드를 작성하는 그 환경에서 어떤 것이 에러가 나는지 보여주기 때문에 시간 절약을 할 수 있다. _(물론 타입스크립트를 쓰는 이유는 더 많이 있다.)_

## 타입스크립트 설치 및 맛보기

타입스크립트 설치를 위해서 먼저 Node가 설치 되어 있어야 한다.

```shell
$ npm install -g typescript ts-node
```

타입스크립트를 설치하는 것은 알겠지만, `ts-node`가 무엇일까?

타입스크립트는 브라우저가 바로 이해할 수 없는 언어이다. 따라서 자바스크립트로 변환해주어야 한다.


https://dzone.com/articles/what-is-typescript-and-why-use-it

index.ts

```ts
import axios from 'axios'

const url = 'https://jsonplaceholder.typicode.com/todos/1'

axios.get(url).then(response => {
  console.log(response.data)
})
```

위와 같은 `.ts` 파일이 있다고 하면, 이를 브라우저가 이해하기 위해서는 `.js` 파일로 변환 후, 실행해 줘야 한다.

```shell
$ tsc index.ts # index.js 파일 생성
$ node index.js # index.js 파일 실행
```

이 두 가지를 한번에 해줄 수 있는 것이 바로 `ts-node`이다.

```shell
$ ts-node index.ts # index.js 파일 생성 및 실행
# 결과
# { userId: 1, id: 1, title: 'delectus aut autem', completed: false }
```



그럼 어떻게 타입스크립트가 우리가 쓴 코드의 에러를 알려주는지 알아보자. 위의 코드에서 조금 더 보기 편하게 각 변수에 할당하고 console을 찍어보자.

```ts
const id = todo.ID
const title = todo.Title
const finished = todo.finished

console.log(`
    The Todo with ID: ${id}
    Has a title of: ${title}
    Is it finished? ${finished}
  `)
```

이렇게 작성 후, console을 찍으면 모두 `undefined`가 뜬다. 이는 fetch 해온 것에 각각 `id, title, completed`로 불러와야 했기 때문이다. 하지만 이는 프로그램을 실행해야만 이를 발견할 수 있었다.

그렇다면 다시 타입을 정의해보자.

```ts
interface Todo {
  id: number
  title: string
  completed: boolean
}
```

`interface`는 타입을 정의하는 것이며, `Todo`안에 어떤 프로퍼티가 어떤 타입을 갖는지 미리 정한다.

그리고 `const todo = response.data as Todo;`를 추가하면, 위에 작성했던 코드에 바로 빨간 줄이 쳐지는 걸 확인할 수 있다.

아래에서 보기 쉽게 변수명을 변경하고 console을 따로 빼보자.

```ts
import axios from 'axios'

const url = 'https://jsonplaceholder.typicode.com/todos/1'

interface Todo {
  id: number
  title: string
  completed: boolean
}

axios.get(url).then(response => {
  const todo = response.data as Todo
  const id = todo.id
  const title = todo.title
  const completed = todo.completed

  logTodo(id, completed, title) // 일부로 completed를 두 번째에 썼다
})

const logTodo = (id, title, completed) => {
  console.log(`
    The Todo with ID: ${id}
    Has a title of: ${title}
    Is it completed? ${completed}
  `)
}
```

자바스크립트 처럼 아래 `logTodo`에 타입을 선언하지 않은 채 실행한다면, 내용이 반대로 나오는 것을 실행하고 나서야 알아챌 수 있다. 그럼 타입을 한번 선언해보자.

```ts
const logTodo = (id: number, title: string, completed: boolean) => {
  console.log(`
    The Todo with ID: ${id}
    Has a title of: ${title}
    Is if completed? ${completed}
  `)
}
```

위처럼 함수에 타입을 선언하면 `logTodo(id, completed, title)` 여기에 빨간줄이 쳐진다.

이렇게 타입스크립트는 실행하기 전에, 코드를 작성하는 곳에서 에러를 알려주기 때문에 시간을 단축할 수 있다.



**참고**



- Typescript: The Complete Developer's Guide [2020], 유데미
- 


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/network/what-is-uri</guid>
      <title>URI란? (feat. URL, URN)</title>
      <link>https://www.howdy-mj.me/network/what-is-uri</link>
      undefined
      <pubDate>Thu, 20 Aug 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>network</category>
      <content:encoded>
해당 문서는 RFC 3986을 기준으로 작성되었습니다.

URI(Uniform Resource Identifier, 통합 자원 식별자)는 언제 어디서든 늘 같은 리소스(텍스트, 이미지, 비디오 등)를 보여줄 수 있도록 해주는 식별자이다.

## 1. URI 구조

```shell
scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]
```

- scheme과 host를 제외하고는 모두 선택 사항이다.
- `[user[:password]@]host[:port]` 는 authority로 묶을 수 있다.



**다른 예시:**

```
ftp://file.fileserver.com/entries/01
http://www.ietf.org/rfc/rfc2396.txt
mailto:John.Doe@example.com
news:comp.infosystems.www.servers.unix
tel:+1-816-555-1212
telnet://192.0.2.16:80/
urn:oasis:names:specification:docbook:dtd:xml:4.1.2
http://www.ietf.org/rfc/rfc2396.txt
```

- 콜론(`:`)은 2개로 묶인 쌍에서 좌우 구분을 위한 인자이다.
- 더블 슬래쉬(`//`)는 어떤 시작을 알린다.



### 스킴(Scheme)

어떤 프로토콜을 사용할지 알린다.

```shell
scheme = 영문 * (영문 / 숫자 / "+" / "-" / "." )
```

첫 문자부터 콜론(`:`) 직전이 스킴이며, 영문, 숫자, 더하기(`+`), 점(`.`), 하이픈(`-`)으로 구성될 수 있으며, 영문은 소문자로 쓴다.

자주 쓰는 스킴으로 http, https, ftp, mailto, file, data 등이 있다.

- URI 스킴 목록: [IANA 공식 URI Schemes](http://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml)



### Authority

authority는 사용자 정보, 호스트, 포트번호의 조합이다.

```
authority = [ userinfo "@" ] host [ ":" port ]
```

- 더블 슬래쉬(`//`)로 시작하여 그 다음 슬래쉬(`/`), 물음표(`?`), 혹은 크로스해치(`#`)으로 구분되거나, URI의 마지막 부분이 될 수도 있다.
- 콜론(`:`)으로 호스트와 포트번호를 나뉜다.

**사용자 정보(User Information)**

```
userinfo = username ":" password
```

- username만 있을 수도 있고 password까지 다 있을 수도 있다.
- 만약 사용자 정보가 있다면 `@`로 끝난다.

**호스트(Host)**

인터넷 상에서 유익할 식별

```
host = IP-literal / IPv4address / reg-name
```

- 우리가 '홈페이지 주소'라 떠올리면 생각나는 naver, google과 같은 것이며, IP 주소가 올 수도 있다.
- `127.0.0.1`은 localhost를 가리킨다.

**포트(Port)**

보통 스킴이 기본 포트를 정의해준다. (ex. HTTP는 80, HTTPS는 43) 만약 따로 포트를 지정했다면 써줘야 한다.

```
port = 숫자
```



### 경로(Path)

리소스에 대한 경로이다.

```
path = /                 ; "/"로 시작하거나 비어있음
     = / path-absolute   ; "/"로 시작
     = / path-nonscheme  ; non-colon segment로 시작
     = / path-rootless   ; segment로 시작
     = / path-empty      ; 비어있음
```

- 물음표(`?`)나 크로스해치(`#`) 앞에서 종료되거나, URI의 끝일 수 있다.



### 쿼리(Query)

요청받을 리소스의 범위를 좁히기 위해 질문이나 질의로 식별할 수 있다.

```shell
query = * (문자 / "/" / "?" )
```

- 물음표(`?`)로 시작되고 크로스해치(`#`)으로 끝나거나 URI의 끝일 수 있다.
- `key=value` 형식을 가진다.

`https://www.google.co.kr/search?q=코로나`에서, 경로는 `/search`이고 쿼리가 `q=코로나`이다.



### 부분 식별자(fragment identifier)

북마크 역할을 한다.

```shell
fragment = * (문자 / "/" / "?" )
```

- 크로스해치(`#`)로 시작되고 URI의 마지막이다.
- 부분 식별자의 요청은 서버에 보내지지 않는다.



### URI 예시

`https://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top`

```
scheme: https
authority:
	- userinfo: john.doe
	- host: www.example.com
	- port: 123
	- path: forum/questions
query: tag=networking&order=newest
fragment: top
```

## 2. 절대, 상대, 기준 URI

URI에는 절대 URI, 상대 URI, 기준 URI가 존재한다.

- 절대(Absolute) URI: 모든 전체 경로를 다 기술한 URI

  ```
  https://www.google.co.kr/search?q=코로나
  https://www.coupang.com/np/campaigns/82/components/194176
  ```

- 상대(Relative) URI: 전체 경로 중, 기준 URI로부터 상대적 경로 표현

  ```
  /search?q=코로나
  /np/campaigns/82/components/194176
  ```

- 기준(Base) URI: 상대 URI만 보면 URI의 기준이 어디인지 알 수없어 기준 URI를 지정하며, 보통 HTML의 Head 요소 안에 `` 요소에 표시

## 3. URI 하위 종류

URI는 URL과 URN로 분류될 수 있다.


https://www.cbtnuggets.com/blog/technology/networking/networking-basics-whats-the-difference-between-uri-url-and-urn

> A URI can be further classified as a locator, a name, or both.


Wikipedia

- 위가 URL, 밑이 URN이다.

### URL(Uniform Resource Locator)

URL은 현재 우리가 홈페이지 주소를 불렀을 때 사용하는 형식으로, 위에서 설명한 구조 모두 URL이다.

정확히 어디에 있는지 경로까지 다 구체적으로 서술해야 접근이 가능하다.

_HTTP 명세에서는 URI를 더 일반화된 개념으로 사용하지만, 실제 HTTP 애플리케이션에서는 URL을 사용한다._

### URN(Uniform Resource Name)

URN은 현재 그 리소스가 어디에 있든 상관없이 이름만으로 리소스를 식별한다.

URL의 문제점은, 만약 `howdy-mj.me/web/web-server-and-was/` 에서 web이라는 카테고리를 network로 변경했을 때, 그 이전에 URL을 가져갔던 사람은 변경된 주소로 들어가지 못한다.

하지만 URN은 위치가 바뀌었더라도 리소스의 위치를 찾을 수 있다.



**참고**



- [RFC3986 - Uniform Resource Identifier](https://tools.ietf.org/pdf/rfc3986.pdf)
- [http://www.ktword.co.kr/abbr_view.php?m_temp1=2340](http://www.ktword.co.kr/abbr_view.php?m_temp1=2340)
- [https://mygumi.tistory.com/139](https://mygumi.tistory.com/139)


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/network/web-server-and-was</guid>
      <title>Web Server & WAS</title>
      <link>https://www.howdy-mj.me/network/web-server-and-was</link>
      undefined
      <pubDate>Tue, 11 Aug 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>network</category>
      <content:encoded>

마지막 업데이트: 2020.08.27




> 최초의 인터넷은 단순한 정보 전달만 가능했지만 점차 서로 정보를 교환할 수 있게 되었고, 최근은 개인 맞춤형 콘텐츠 및 서비스 제공 시대까지 이르렀다. 이러한 인터넷의 발전에 따라 웹의 동작 원리도 바뀌었다.

## Web이란?

**웹**([World Wide Web, WWW](https://en.wikipedia.org/wiki/World_Wide_Web))은 인터넷에 연결된 사용자들이 정보를 공개 및 공유할 수 있는 공간이다. 웹은 크게 세 가지 특징이 있다.

1. 텍스트, 그림, 영상 등의 정보를 보여주는 하이퍼텍스트 ex. HTML
2. 해당 공간의 위치(주소) ex. URL
3. 해당 문서나 자원에 접근하는 프로토콜 ex. HTTP


  
    *프로토콜
    : 프로토콜은 5개의 계층으로 나뉘는데, 위로 갈수록 사용자(클라이언트)와 가까운 작업을, 아래로 갈수록 기계와 가까운 작업을 담당한다.
  

  
    
  

  
    애플리케이계층: 서버와 클라이언트의 통신. ex. HTTP, SMTP, POP3, FTP 등
    통신 계층: 데이터를 확실히 송/수신하기 위해 작동. 데이터`패킷`이라는 단위로 나누어 보내고, 이를 다시 조립하여 원데이터로 만듬. ex. TCP, UDP
    네트워계층: 수신측 컴퓨터까지 데이터를 전달하기 위작동. 전달된 데이터의 손상 여부나 수신측이 잘 받았는지대해서는 관여하지 않음 ex. IP
    데이터 링계층: 네트워크에 직접 연결된 기기 간을 전송할 있도록 만듬. ex. Ethernet, PPP 등
    물리 계층: 데이터를 신호로, 신호를 데이터로 변환.
  

이 다섯 가지의 프로토콜을 조합하면 다양한 애플리케이션이나 기기를 처리할 수 있다.




  용어: 하이퍼텍스트, HTML, URL, HTTP
  
      하이퍼텍스트(HyperText): 한 문서에서 다른 문서의 위치 정보를 심어서 양쪽을 연결해주는 텍스트
      HTML(HyperText Language): 웹을 위한 마크업*(태그 등을 이용해 문서나 데이터 구조를 명기하는 언어 중 하나)* 언어
      URL(Uniform Resource Locator): https://www.rootenergy.co.kr/home 와 같은 웹의 주소
      HTTP(HyperText Transfer Protocol): 웹 상에서 정보(하이퍼텍스트 문서)를 주고 받을 때 사용 되는 통신 규약
  




### 웹의 역사와 발전

**WEB 1.0**

- 1989년 팀 버너스리가 연구원 간에 아이디어를 주고받을 때 항상 전자 우편이나 파일을 통해 주고 받는 것이 비효율적이라 생각하여 제안한 것으로, 공통된 공간에 각자의 정보를 올리고 관리할 수 있는 일종의 정보 관리 시스템에서 시작되었다.
- 정리된 자료를 전달받는 형태로, 주로 텍스트와 링크로 이루어졌다. (정적인 형태)

**WEB 2.0**

- 2000년대 초, 사용자들이 웹에 글을 쓰거나 동영상을 올리는 등 직접 생산하고 참여하는 공간으로 바뀌었다.
- 회원등록 및 조회, 메일링, 게시판, 방명록 등의 [CGI 프로그램](#cgi)의 등장이 컸다고 본다.

**WEB 3.0**

- 2010년 이후, PC 뿐만이 아니라, 모바일, 태블릿 등 1인 1단말기가 보편화 되면서 개인화, 맞춤화 등의 인식이 생겼다. 컴퓨터 역시 시맨틱 웹(Semantic Web) 기술을 이용해 웹 페이지에 담긴 내용을 이해하고 사용자에게 맞춤형 콘텐츠 및 서비스를 제공할 수 있게 되었다.

  
      용어: 시맨틱 웹
      
          시맨틱: 페이지의 태그를 통해 의미 부여를 할 수 있는 기능
          시맨틱 웹은 '의미론적인 웹'이라는 뜻으로, 인터넷 상의 리소스(웹 문서, 파일, 서비스 등)에 대한 정보와 자원 사이의 정보를 기계가 처리할 수 있는 온톨로지 형태로 표현하고, 이를 자동화된 기계(컴퓨터)가 처리하도록 하는 프레임워크이자 기술이다.
          HTML5에서 시맨틱 웹을 쉽게 구성할 수 있도록 시맨틱 태그 요소들이 추가되었다.
      
  




  브라우저 동작 원리

  
  브라우저는 웹을 보기 위해 사용하는 프로그램으로 대표적인 브라우저에는 크롬, 사파리, IE, 파이어폭스 등이 있다.

브라우저 구조


https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/

  
      사용자 인터페이스: 주소 표시줄, 이전/다음 버튼, 북마크, 메뉴 등 요청한 페이지를 보여주는 창을 제외한 사용자가 컨트롤 가능한 부분
      브라우저 엔진: Use Interface와 Rending Engine 사이의 동작 제어 (ex. Webkit, Blink, Gecko)
      렌더링 엔진: 요청받은 내용(HTML, CSS, JavaScript 등 파일)을 브라우저 화면에 보여주는 것
      통신: HTTP 요청과 같은 네트워크 호출에 사용
      자바스크립트 해석기: 자바스크립트를 해석하고 실행 (ex. V8 엔진)
      UI 백엔드: 기본적인 위젯(ex. 콤보박스)을 화면에 그릴 때 필요
      자료 저장소: 로컬 스토리지, 쿠키 등 클라이언트 사이드에서 데이터를 저장하는 영역
  

  

렌더링 엔진(Webkit 기준)


https://d2.naver.com/helloworld/59361

  
      파싱(Parsing): 파싱은 서버로부터 받은 문서를 브라우저가 이해할 수 있는 구조로 변환하는 과정을 뜻한다. 파싱 결과는 문서 구조를 나타내는 노드 트리라 하는데, HTML 문서를 파싱하여 DOM 트리를 만들고, CSS 문서를 파싱하여 CCSOM 트리를 만든다. 
      구축(Attachment): DOM과 CCSOM 트리를 결합하여 렌더 트리를 만든다. 
      배치(Layout): 렌더 트리가 만들어지면, 레이아웃(리플로우)을 배치하여 각 노드를 정확한 위치에 표시하기 위해 크기를 계산한다. (ex. CSS에서 %로 할당된 값을 px 단위로 변환)
      그리기(Paint): 계산된 위치와 크기 등을 실제 픽셀로 표현한다. 
  
  





## Web Server

**웹 서버**는 HTTP의 요청/응답을 처리하여 사용자들이 보고 싶어하는 정적인 페이지(ex. HTML, 파일, 이미지, 비디오 등)를 제공하거나 로그인, 회원가입 같은 사용자 인증을 처리할 수 있는 컴퓨터 프로그램 또는 장치이다.



대표적인 Web Server에는 Nginx(ex. Dropbox, Netflix, Wordpress.com 등), Apache HTTP Server가 있다.


https://www.educative.io/edpresso/web-server-vs-application-server

## WAS(Web Application Server)

**Web Application**

**웹 애플리케이션**은 웹상에서 단순히 동적으로 페이지를 출력하는 것 보다, 웹에서 특정 업무를 처리하는 것을 뜻한다. 예를 들면, 어떠한 소스 파일을 특정 파일로 변환, 회사 실무 관리나 DB 관리, 혹은 HTML5 Canvas를 이용한 게임 등이 있다.

여기서 알 수 있듯이, Web Server와 WAS의 가장 큰 차이는 동적 데이터(비즈니스 로직) 처리 가능 여부이다.


    용어: 비즈니스 로직(Business Logic)
    
        동적 데이터 생성 및 작업
        클라이언트가 원하는 데이터를 보여주기 위해, 데이터베이스에 연결, 생성, 변경, 저장하는 작업
        ex. 회원 가입을 위해 아이디 작성 후 제출하면, 데이터베이스에 중복된 아이디가 있는지 연결하여 확인 및 결과를 클라이언트에 전달
    





https://www.educative.io/edpresso/web-server-vs-application-server

WAS는 Web server에 Application servers가 추가된 것이다. 애플리케이션 서버는 웹 서버와 데이터베이스 사이에서 웹 서버 대신 데이터베이스와 통신하여 동적인 데이터를 처리해주는 미들웨어이다.

대표적인 WAS에는 Apache Tomcat, Glassfish 등이 있다.



### CGI

_RFC3875 - The Common Gateway Interface(CGI) Version 1.1 기준으로 작성했습니다._

CGI(Common Gateway Interface, 공용 게이트웨이 인터페이스)는 웹 서버와 클라이언트 간에 필요한 정보 교환을 가능하게 해주는 인터페이스다.


https://networkencyclopedia.com/common-gateway-interface-cgi/

웹 서버는 동적으로 처리해야 하는 요청을 CGI 프로그램에 넘긴다. CGI 프로그램은 데이터베이스를 기반으로 동적으로 페이지를 처리한 후, 해당 결과를 다시 브라우저에 전송한다.

가장 대표적인 CGI로는 게시판, 설문조사, 회원가입 같은 폼(form)이 있다. 폼은 사용자들이 HTML로 서버에 정보를 제공할 수 있도록 해주고, 제출하면 작성한 내용이 서버로 전송 되면서 데이터베이스에 저장된다. (GET, POST 메서드 사용 가능)

다시 말해 웹 서버는 정적 페이지에서 바뀌지 않으며, 데이터를 수정(생성)해서 응답하고 싶은 것을 CGI 프로그램이 해준다. 폼 작성하는 것 외에도, 파일 목록을 보여 준다거나 데이터베이스를 조회해서 돌려주는 것도 가능하다.



**Web Server + CGI vs. WAS**

Web Server에서 CGI 프로그램을 통해 동적 처리가 가능하다고 했다. 그렇다면 WAS와 어떤 차이가 있을까?

CGI는 하나의 요청을 하나의 프로세스를 생성해서 처리한다. 따라서 동일 페이지에 대한 요청이 늘어날 때마다, 계속 프로세스가 생성되기 때문에 CPU나 메모리 같은 자원이 금방 한계에 도달한다.

반면 WAS는 동일 페이지에 대한 요청이 여러 개인 경우 1개의 프로세스에 요청된 개수만큼 스레드가 생성되어 처리하기 때문에 메모리 절약이 가능하다.

  
    용어: 프로세스, 스레드
    
        프로세스(Process): 컴퓨터에서 연속적으로 실행되고 있는 프로그램
        스레드(Thread):: 프로세스 내에서 실행되는 여러 흐름의 단위
    
  





**Docker로 cra+nginx, express 서버 띄워보기 (Github repo)**

- [react-nginx-docker](https://github.com/howdy-mj/react-nginx-docker)
- [express-with-docker](https://github.com/howdy-mj/express-with-docker)

## Node.js는 웹 서버인가?

공식 홈페이지에 `Node.js는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임` 이라고 나와 있다.


    용어: V8, JavaScript 엔진, 런타임
    
        V8: C++로 작성된 구글의 오픈소스 고성능 자바스크립트와 웹어셈블리(C/C++을 웹에서 동작할 수 있도록 컴파일) 엔진
        JavaScript 엔진: 자바스크립트를 해석하고 실행하는 프로그램 또는 언어
        런타임: 프로그램이 실행되는 환경
    




Node.js는 웹 서버가 아니지만 직접 HTTP 서버를 작성하면 웹 서버를 띄울 수 있는 환경을 만들어준다. 그러나 일일이 Node.js로 웹 서버에 필요한 기능을 짜면 해야할 것이 너무 많기 때문에, Node.js의 프레임워크 Express, Koa, Hapi 등을 사용하면 보다 더 간단하게 웹 서버를 구축할 수 있다.

하지만 Node.js는 한 번에 한 가지 일밖에 처리하지 못하므로 간단한 작업은 괜찮지만, CPU 부하가 큰 프로젝트(ex. 암호화폐 채굴)를 진행할 경우 과부하가 올 수 있기 때문에 NginX 등 다른 웹 서버를 연결해야 한다.

```js
// http 모듈 import
const http = require('http')

// http 서버 객체 생성, request 이벤트가 발생하면 response를 반환
const server = http.createServer(function(req, res) {
  // 정상적으로 값을 리턴하면, 컨텐츠 타입은 text, html 형태로 화면에 출력
  res.writeHead(200, { 'Content-Type': 'text/html' })
  // res.write의 첫 번째 인자는 클라이언트로 보낼 데이터, HTML을 보낼 수도, 버퍼를 보낼 수도 있음
  res.write('Homepage')
  // res.end는 응답을 종료하는 메서드. 만약 인자가 있다면, 그 데이터를 클라이언트로 보내고 종료
  res.end()
})

// http 서버 객체를 5000 포트로 전달하여 서버 실행
server.listen(5000)

console.log('Node.js web server at port 5000 is running')
```

**Node.js로 서버 띄워보기 (Github repo)**

- [practice-node-server](https://github.com/howdy-mj/practice-node-server)



**참고**



- https://hack-cracker.tistory.com/146
- https://www.ibm.com/cloud/learn/web-server-vs-application-server
- https://www.educative.io/edpresso/web-server-vs-application-server
- https://www.edwith.org/boostcourse-web/lecture/16666/
- https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html
- https://passionha.tistory.com/341
- https://jeong-pro.tistory.com/84


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/bookmark/develop</guid>
      <title>개발자가 읽어보면 좋은 글 및 블로그 모음</title>
      <link>https://www.howdy-mj.me/bookmark/develop</link>
      undefined
      <pubDate>Thu, 06 Aug 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>bookmark</category>
      <content:encoded>

마지막 업데이트: 2021.07.22


 -->



개발자가 읽으면 좋을 글 혹은 사이트 모음

- StackShare - Stacks used by top companies
- npmview
- StatCounter
- DevDocs API
- Dash for macOS (유료)
- Devhints - TL;DR for developer documentation
- Hacker News

## CS(개발 지식)

국내

- 코드 악취를 맡는 후각 훈련의 시간 (2020.06.09)
- 컴퓨터과학과 프로그래밍 입문(MIT 강의) (2009)
- 개발자를 위한 인프라 기초 총정리 (2018.11.09)
- 부트캠퍼를 위한 컴퓨터 과학
- CONNECT DEV - 웹/앱 개발을 위한 전반적인 지식을 정리하기 위한 위키
- [IT 개발자와 일할 때 필요한 모든 개발지식] A to Z 자료 모음집 By 그랩
- 신입 개발자 전공 지식 & 기술 면접 백과사전

해외

- Association for Computing Machinery

## 공통

### Git

- 좋은 git 커밋 메시지를 작성하기 위한 7가지 약속
- Upptime
- Shields: Quality metadata badges for open source projects
- 익숙해지면 좋을 깃(git) 명령어 모음집

### Vim

- Interactive Vim tutorial

### HTTP

- httpbin
- HTTP 2.0

### 문서 작성

- 기술 문서 작성 5단계

## 커뮤니티

국내

- 자바스크립트 개발자 포럼
- OKKY

해외

- DEV Community
- web.dev Blog
- Social Network for Programmers and Developers
- 掘金

## 회고록 & 동기부여

- 30년간 개발자로 살면서 배운 것
- 5년차 개발자
- 업계에서 6년 있은 뒤, 마음이 바뀐 소프트웨어 개발 토픽들 (2021.01)
- 구글의 소프트웨어 엔지니어링 (2017.05.10)
- 10 Years of Open-Source Visualization (2021.02.24, d3 개발자의 지난 10년 간의 후기)

## 기술 블로그

### 개인

국내

- JBEE.io
- 김정환 블로그
- Enginerring Blog by Dale Seo
- 프로그래머 이규원의 웹사이트
- rinae's devlog
- 재그지그의 개발 블로그 wormwlrm's programming & tech blog
- JIHahnSol
- ahn.heejong
- Velopert - 1
- Velopert - 2
- ZeroCho Blog
- Captain Pangyo
- Tlog
- Steady Study
- blog.rhostem
- dohoons(도훈) \_(≥∇≤)ノミ ☆
- 윤자이 기술블로그

해외

- Addy Osmani
- Lydia Hallie
- Overreacted
- Every Post Ever - Dave Ceddia

### 기업

국내

- 카카오
- 당근마켓
- NHN
- Naver D2
- 라인 LINE
- 우아한 형제들
- 야놀자
- 쿠팡
- 레진코믹스
- 리멤버
- 리디북스
- 뱅크샐러드
- 크몽
- 쏘카
- 44BITS
- 모두싸인

해외

- Netflix
- Instagram
- Grab
- Uber
- Google AI
- Discord
- Github
- Heroku
- BBC
- Dropbox
- Reddit
- Spotify
- Bloomberg

## 개발환경 세팅

- Oh My ZSH+ iTerm2로 터미널을 더 강력하게 (2019.01.19)
- 본격 macOS에 개발 환경 구축하기 (2020.07.06)
- Dev Fonts

 -->
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/git/git-flow</guid>
      <title>Git flow: 배경, 브랜치</title>
      <link>https://www.howdy-mj.me/git/git-flow</link>
      undefined
      <pubDate>Fri, 24 Jul 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>git</category>
      <content:encoded>

업데이트: 2021.08.22




Gitflow Workflow을 주로 참고했으며 오역이 있을 수 있습니다. 피드백은 언제나 환영합니다!

## Git flow란?

Git flow는 [Vincent Driessen](https://nvie.com/posts/a-successful-git-branching-model/)이 만들 었으며, 규모가 큰 프로젝트 배포를 중점으로 브랜치 관리를 엄격하게 하는 모델이다.

기존의 Git Workflow에서 새로운 개념이나 명령어는 없으며, 각각의 브랜치에 특정한 역할을 부여하여 체계적으로 만든 것이다.



### 설치

Git flow를 사용하기 위해서는 사전에 git이 설치되어야 하며, Git flow는 MacOS, Linus, Windows에서 작동된다.

자신의 운영체제에 따라 설치하는 방법이 다르다. OSX 시스템에서는 `brew install git-flow`를, 윈도우는 [Git 다운](https://git-scm.com/download/win) 후, `git flow init`을 실행할 수 있다.



## Git flow 브랜치

Git flow에는 5가지 종류의 브랜치가 존재한다.


https://medium.com/@olivier.bossel/git-flow-the-right-way-to-go-f2a65c315818

프로젝트의 히스토리를 기록하는 base 브랜치로 `master`와 `develop` 브랜치, 백업이나 협업 용으로 사용하는 `feature` 브랜치, 배포를 위해 존재하는 `release` 브랜치 그리고 서비스를 빠르게 수정하고 업데이트해야 하기 위해 `hotfix` 브랜치가 있다.

### Master, Develop


https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow

`master` 브랜치는 공식적인 배포 히스토리를 저장하며, **절대** `master` 브랜치에서 작업하지 않는다.

`develop` 브랜치는 `master` 브랜치에 커밋으로 버전을 기입하기도 편하며, 브랜치 기능의 통합(integration)을 도와준다.

**develop 브랜치 생성**:

`master` 브랜치는 프로젝트에 git init을 하면 자동으로 나타나지만, `develop` 브랜치는 따로 생성해 줘야 한다.

```shell
$ git branch develop
# develop 브랜치 생성

$ git push -u origin develop
# 서버에 debelop 브랜치 올리기
```

`develop` 브랜치는 모든 프로젝트의 기록을 다 갖고 있으며, `master` 브랜치의 축약판이라 할 수 있다. 따라서 다른 개발자들이 클론을 하면 `develop` 브랜치를 트래킹하는 브랜치를 생성해야 한다.

만약 git-flow 라이브러리를 쓴다면 `git flow init`으로 `develop` 브랜치를 만들 수 있다.

```shell
$ git flow init
Initialized empty Git repository in ~/project/.git/
No branches exist yet. Base branches must be created now.
Branch name for production releases: [master]
Branch name for "next release" development: [develop]

How to name your supporting branch prefixes?
Feature branches? [feature/]
Release branches? [release/]
Hotfix branches? [hotfix/]
Support branches? [support/]
Version tag prefix? []

$ git branch
* develop
 master
```



### Feature

`feature` 브랜치는 새로운 기능(feature) 추가/개발할 때 사용되며, 백업이나 협업을 위해 중앙 repository에 push 될 수 있어야 한다. 하지만 이를 `master`에 바로 업데이트 하는 것이 아니라, `develop` 브랜치를 부모 브랜치로 삼아 merge한다.

`feature`는 **절대** `master` 브랜치와 바로 연결되어서는 안된다.


https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow

`feature` 브랜치는 보통 최신 `develop` 브랜치에서 생성된다.

**feature 브랜치 생성**:

```shell
$ git checkout develop
# develop 브랜치에서 생성하기 위해 이동

$ git checkout -b feature/브랜치명
# 브랜치 생성 및 해당 브랜치로 이동
```

만약 git flow 확장을 쓰고 있다면,

```shell
$ git flow feature start feature/브랜치명
```

**feature 브랜치 merge**:

해당 `feature` 브랜치에서 모든 작업이 완료 되었다면, `develop` 브랜치에 merge해야 한다.

```shell
$ git checkout develop
$ git merge feature/브랜치명
```

만약 git flow 확장을 쓰고 있다면,

```shell
$ git flow feature finish 브랜치명
```

자동으로 `feature/브랜치명`으로 생성되고 해당 브랜치로 이동된다.



### Release


https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow

`release` 브랜치는 다음 출시를 준비할 때 생성하는 브랜치로, 새로운 기능을 해당 기점 다음에 추가한다. 에러 수정, 문서 생성 그리고 다른 출시 관련 작업들 모두 해당 브랜치에서 작업한다. 출시 준비가 완료되었다면, `master` 브랜치로 merge를 시키며 버전 번호도 같이 태깅한다. 또한, 이는 `develop`에도 merge되어야 한다.

**release 브랜치 생성**:

```shell
$ git checkout develop
$ git checkout -b relase/0.1.0
```

만약 git flow 확장을 쓰고 있다면,

```shell
$ git flow release start 0.1.0
```

`master`와 `develop`에 meger가 된 후에는, 해당 `release` 브랜치는 삭제된다. 혹여나 중요한 수정사항이 생길 수 있으니, `develop` 브랜치에 백업 merge를 해두는 것이 항상 중요하다.

**release 브랜치 merge**:

```shell
$ git checkout master
$ git merge release/0.1.0
```

만약 git flow 확장을 쓰고 있다면,

```shell
$ git flow release finish '0.1.0'
```



### Hotfix


https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow

`hotfix` 브랜치는 이미 출시 된 제품의 유지보수나 빠른 패치를 위해 사용한다. `release`와 다르게 `hotfix`는 `master` 브랜치에 기반하여 생성된다. 에러 수정을 마쳤으면 바로 `master`와 `develop` 브랜치로(혹은 현재 `release` 브랜치) merge 되며, `master`에는 업데이트된 버전 번호가 태깅되어야 한다.

**hotfix 브랜치 생성**:

```shell
$ git checkout master
$ git checkout -b hotfix/브랜치명
```

만약 git flow 확장을 쓰고 있다면,

```shell
$ git flow hotfix start 브랜치명
```

`hotfix/브랜치명`으로 생성 후, 해당 브랜치로 이동된다.

**hotfix 브랜치 merge**:

`release` 브랜치와 비슷하게 `master`와 `develop`에 모두 merge 된다.

```shell
$ git checkout master
$ git merge hotfix/브랜치명
$ git checkout develop
$ git merge hotfix/브랜치명
$ git branch -D hotfix/브랜치명 # merge된 브랜치 삭제
```

git flow 명령어,

```shell
$ git flow hotfix finish 브랜치명
```



## 주의점

- Git flow는 merge 기반의 솔루션으로, **feature/브랜치를 rebase 하지 않는다**.
- `master`에 생성되는 건 `develop`, `hotfix` 브랜치 뿐, 나머지는 `develop`에서 생성된다.
- `hotfix`는 작업이 완료되면 `develop`과 `master`에 merge 된다.



**참고**



- https://danielkummer.github.io/git-flow-cheatsheet/index.ko_KR.html
- https://guides.github.com/


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/bookmark/frontend</guid>
      <title>프론트엔드가 읽어보면 좋을 글 모음</title>
      <link>https://www.howdy-mj.me/bookmark/frontend</link>
      undefined
      <pubDate>Fri, 24 Jul 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>bookmark</category>
      <content:encoded>

마지막 업데이트: 2021.07.22


 -->



프론트엔드가 읽어보면 좋을 글 혹은 사이트 모음

- 실용주의 프런트 엔드 개발 (2020.07)



자바스크립트, 타입스크립트 관련 북마크는 여기에서 볼 수 있습니다.

## 뉴스레터

- Frontend Focus
- ES.next News
- JavaScript Weekly

## 웹 표준화 기구

- W3C (World Wide Web Consortium)
- WICG (Web Incubator CG)
- WHATWG community

## HTML

- HTML Entity Reference
- HTML Cheat Sheet
- 시맨틱하게 HTML을 짠다는 것. (2017.04.02)

## CSS

- CSS Snapshot 2018
- Pseudo Class와 Pseudo Element 활용하기 (2016.07.04)
- 10 Best Practices for Improving Your CSS (2020.05.12)
- Ten modern layouts in one line of CSS (2020.07.07)
- Centering in CSS (2020.12.16)
- Debug CSS Grid with Chrome DevTools (2021.01.04)
- The Rules of Margin Collapse (2020.12.16)
- Use CSS Variables instead of React Context
- Sharing data between CSS and JavaScript using custom properties (2021.02.08)

실습

- cubie-bezier (easing 함수 속성)
- Easing 함수 치트 시트
- CSS generator/border
- Bubbly - CSS speech bubbles made easy! (말풍선 CSS)
- Shadows
- CSS Scroll Shadows!
- CSS Stripes Generator

## Web & Browser

- Rendering
- [번역] 웹 아키텍쳐 입문 (2018.07.28)

### 실습

- AST Explorer

## React

- How to become a pro with React setState() in 10 minutes (2018.10.06)
- [번역] useEffect 완벽가이드 (2019.10.09)
- React.js Examples
- Why React Context is Not a "State Management" Tool (and Why It Doesn't Replace Redux) (2021.01.18)
- React Refs: The Complete Story (2020.12.01)
- A (Mostly) Complete Guide to React Rendering Behavior (2020.05.17)
- [react] 페이지 네이션 구현하기 (2020.01.04)
- React TypeScript Cheatsheets

### Clean Code

- 8 Tips to keep your code clean in React (2020.06.30)
- React Clean Code (2021.02.25)



Next.js -->



## MobX

- ANNOUNCING MOBX 6 (2020.12.24)

## Unit Test

- Jest, Enzyme 을 통한 리액트 컴포넌트 유닛 테스팅 (2018.03.04)
- Jest로 기본적인 테스트 작성하기 (2019.01.12)

- How to Test Images in React (2020.09.07)

## Webpack

- Create App - Frontend build config generator
- JavaScript Modules Part2 A Beginner’s Guide (번역) (2016.08.06)
- Webpack 4의 Tree Shaking에 대한 이해 (2018.11.08)
- 웹팩 핸드북 (2019.12)
- 자바스크립트 개발자를 위한 AST(번역) (2018.06.19)
- Create-React-App의 Webpack 기본 설정 살펴보기 (2020.05.26)
- JavaScript performance beyond bundle size (2021.02.23)
- Through the pipeline: An exploration of front-end bundlers (2021.02.13)

## WebGL

- WebGL Fundamentals

## WebRTC

- WebRTC-Experiment
- Getting Started with WebRTC (책)

## 기타

- React-Spring Guide
- React Spring Tutorial: Making Animated React Apps (2020.03.03)
- 모두를 위한 대수적 효과 (2019.07.21)
- Streams—The definitive guide (2021.02.19)

 -->
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/git/git-intro</guid>
      <title>Git 알아보기</title>
      <link>https://www.howdy-mj.me/git/git-intro</link>
      undefined
      <pubDate>Thu, 23 Jul 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>git</category>
      <content:encoded>
https://1boon.kakao.com/ppss/5944f90a6a8e510001e7201b

과제 혹은 업무를 할 때 다들 겪어봤을 법한 일이다.

이렇게 저장하다보면 어떤 것이 진짜 최종이고, 어느 부분이 수정되었는지 기억이 나지 않아 결국 파일 하나하나 열어보면서 확인해야 한다.

개발 할 때도 같다. 혼자 프로젝트 할 때도 있지만, 대부분은 다른 개발자와 같이 프로젝트를 진행한다. 동시에 하나의 프로젝트를 진행하다보면 어떤 것을 최종으로 결정할 것인지, 병합은 어떻게 하는지 생각해 봐야 한다.

그러다 만약 에러라도 난다면, 에러 찾느라 한 세월, 복구하느라 한세월 걸리거나 심지어 다시 처음부터 작업해야 할 수도 있다.

이를 해결 하기 위해 나온 것이 Git이다.

## Git

Git은 VCS(Version Control System: 버전 관리 시스템)로, 여기서 버전은 소스코드(source code) 파일 버전을 말한다.

### Git이 나온 배경 - VCS

그렇다면 과연 VCS가 무엇일까?

우리가 '진짜 진짜 최종'이란 파일명을 만드는 것을 방지해준다. 우리 컴퓨터의 어느 공간에 파일의 수정 사항과 날짜 등의 메타 데이터를 저장한다. 이러한 저장 공간을 version database라 한다.

https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control

그 후, 다른 개발자와 협업을 위해 **Centralized Version Control Systems(CVCSs, 중앙 버전 관리 시스템)**이 개발되었다.

https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control

하지만 치명적인 단점이 있었다. 만약 백업을 하지 않은 상태에서 중앙 서버가 털린다면 모든 작업물이 없어지는 것과 같았다.

그래서 Git, Mercurial 등과 같은 **Distributed Version Control Systems(DVCSs, 분산 버전 관리 시스템)**이 나왔다.

https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control

이로 인해, 서버가 죽더라도 각자의 컴퓨터에서 최신 버전의 코드들을 백업할 수 있다.



### 세 가지 상태(States)

Git으로 버전 관리를 할 때 크게 _modified, stage, committed_ 이 3가지 상태가 있다.

- **Modified**: 파일 수정이 있지만 아직 데이터베이스에 commit(커밋)을 안한 상태
- **Staged**: 현재 버전에서 수정 사항을 체크하고 다음 커밋에 들어갈 상태
- **Committed**: 로컬 데이터베이스에 저장된 상태

https://git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F



### Git 설치

Git을 사용하려면 먼저 설치부터 해야 한다. 자신의 운영 환경에 따라 설치하는 방법이 다르니 자세한 설치는 [공식 홈페이지](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)를 참고하자.



### Git Repository

Git을 사용하다보면 Repository란 단어를 자주 본다.

Repository는 Local과 Remote로 나뉘는데, Local은 자신의 컴퓨터에 저장되는 저장소를, Remote는 원격 저장소(ex. GitHub)를 뜻한다.

이는 구글 드라이브나 Dropbox, 네이버 클라우드 같은 원격 저장소와 비슷하다. 내 컴퓨터에도 같은 것이 있지만, 인터넷에 올림으로써 백업을 해두는 것과 같다.

평소 자신의 컴퓨터에서 작업하고 파일을 공유하고 싶다면 Remote repository에 업로드하면 되고, 반대로 다른 사람의 파일을 Local repository로 가져올 수 있다.

**Local repository 생성**:

```shell
$ mkdir git-test # 폴더 생성
$ cd git-test # 해당 폴더로 이동
$ git init # 폴더에 git repository 생성
```

**GitHub에서 Clone**:

```shell
$ git clone 주소 # 내 컴퓨터에 복제
$ cd 폴더명 # 해당 폴더로 이동
```



### 자주 쓰이는 Git 명령어

파일을 수정하고 수정사항을 Remote repository에 반영하고 싶다면, `add`, `commit`, `push`로 업로드 할 수 있다.

```shell
$ git add .
# 수정된 파일 전부 stage 상태로 변경

$ git add -A
# 수정된 파일 전부 stage 상태로 변경

$ git add 파일명.확장자
# '파일명.확장자'만 stage 상태로 변경

$ git commit -m "커밋내용"
# 어떤 내용이 변경되었는지 잘 적어놓는 것이 좋다

$ git push origin master
# origin [브랜치명], push작업이 끝나면 GitHub에서 확인 가능
```

그 외, 자주 쓰는 명령어:

```shell
$ git remote add origin 주소
# remote repo에 연걸하기

$ git remote -v
# 현재 폴더의 원격 저장소 보기

$ git remote remove origin
# 현재 remote repo 삭제하기

$ git status
# 현재 어떤 상태에 있는지 보기

$ git stash
# 작업 중이다 다른 브랜치로 이동할 때 저장해두는 작업

$ git stash list
# 저장 목록 조회

$ git stash pop
# 저장 내용 복구

$ git stash apply
# 저장된 내용을 다른 브랜치에 적용

$ git stash drop
# 저장된 내용 삭제
```

branch(브랜치) 관련 명령어:

```shell
$ git branch
# 모든 브랜치 및 현재 위치한 브랜치 보기

$ git checkout 브랜치명
# '브랜치명'이란 브랜치 생성하기

$ git branch -D 브랜치명
# '브랜치명'의 브랜치 삭제

$ git push origin :브랜치명
# 삭제한 브랜치의 remote 브랜치도 삭제하기
```

만약 원격 저장소에 올리고 싶지 않은 것이 있다면, `.gitignore` 파일을 만들어 안에 해당하는 파일 혹은 폴더명을 적으면 된다.



**참고**



- https://git-scm.com/


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/fe-setting/eslint-and-prettier</guid>
      <title>ESLint & Prettier 알아보기</title>
      <link>https://www.howdy-mj.me/fe-setting/eslint-and-prettier</link>
      undefined
      <pubDate>Wed, 22 Jul 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>fe-setting</category>
      <content:encoded>
ESLint, Prettier는 코드를 검사해서 깔끔하게 만들어주고 잠재적 에러를 제거해준다.

## ESLint

[ESLint](https://eslint.org/)는 ECMAScript/JavaSciprt 코드에서 자동으로 에러나 오류를 제거하고 더 단단한 코드로 만들어준다.

### ESLint 설치 및 설정

```
$ npm install eslint --save --dev
# or
$ yarn add eslint --dev
```

ESLint는 configuration 파일이 있어야 실행 가능하기 때문에 `.eslintrc.{js, yml, json}` 파일을 만들어야 한다.

일일이 규칙을 설정하기 번거롭다면, `npx eslint --init`으로 `.eslintrc` 파일을 만들 수 있다.

사용하고 싶은 [규칙](https://eslint.org/docs/rules/)을 해당 파일에 넣으면 된다.

.eslintrc.json

```json
{
  "env": {
    "es6": true
  },
  "rules": {
    "semi": ["error", "always"],
    "quotes": ["error", "single"]
  },
  "extends": "eslint:recommended"
}
```

ES6를 준수하기 위해 `"env": { "es6": true}`를 작성했다. 그리고
rules에는 코드에 세미콜론이 항상 있어야 하며, `'single quotes'`를 쓰도록 설정해보겠다.

또한, 해당 파일에는 `"extends": "eslint:recommended"` 문구가 있어야 [규칙](https://eslint.org/docs/rules/)에서 체크(✔)되어 있는 항목이 검사된다.

`app.js`에 `const hello = "double"`이라고 작성 한후,
eslint를 실행해보면 우리가 작성한 것에 위배되는 항목을 띄워준다.

```
$ npx eslint app.js
  1:7   error  'hello' is assigned a value but never used  no-unused-vars
  1:15  error  Strings must use singlequote                quotes
  1:23  error  Missing semicolon                           semi

✖ 3 problems (3 errors, 0 warnings)
  2 errors and 0 warnings potentially fixable with the `--fix` option.
```

`npx eslint app.js --fix`를 치면 에러가 난 코드를 자동으로 고쳐준다. ([Rules](https://eslint.org/docs/rules/)에서 렌치🔧모양이 있는 것만 자동 수정)

ESLint에는 자주 사용하는 규칙 모음이 있는데, 하나는 [airbnb 스타일](https://github.com/airbnb/javascript)이고, 나머지 하나는 [자바스크립트 standard 스타일](https://standardjs.com/)이다.

## Prettier

[Prettier](https://prettier.io/)는 code formatter로 코드를 더 이쁘게 만들어준다.

### Prettier 설치 및 설정

```shell
$ npm install --save --dev prettier
```

app.js

```js
const hello = 'double'
```

이렇게 된 것을 prettier를 실행하면 아래처럼 나온다.

```shell
$ npx prettier app.js

const hello = "double";
```

`npx prettier app.js --write`을 같이 작성하면 `app.js` 파일이 자동으로 수정된다.



이처럼 Prettier는 ESLint와 겹치는 부분도 있지만, 코드 품질 관련 기능은 없다.

그렇기 때문에 ESLint와 Prettier를 같이 쓰며, 충돌하는 부분은 [eslint-config-prettier](https://github.com/prettier/eslint-config-prettier) 패키지를 통해 ESLint 규칙을 끈다.

```shell
$ npm install --save-dev eslint-config-prettier
```

설치 후, `.eslintrc.json`파일에 extends를 추가한다.

```json
{
  "extends": ["eslint:recommended", "eslint-config-prettier"]
}
```

## ESLint, Prettier 간단 설정

코딩할 때마다 확인해야 하는데, 매번 코드 치고 ESLint와 Prettier를 실행해야하는 건 매우 번거롭다.

따라서 Git과 사용하기 편한 [husky](https://github.com/typicode/husky), 혹은 VSCode에의 확장도구인 ESLint를 다운하면 된다.

이번 글에서는 ESLint 익스텐션을 설치한 후,

.vscode/settings.json

```json
{
  "eslint.enable": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  }
}
```

이렇게 설정해주면 저장할 때마다 자동으로 ESLint가 실행된다.



**참고**



- https://eslint.org/
- https://prettier.io/
- http://jeonghwan-kim.github.io/series/2019/12/30/frontend-dev-env-lint.html


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/fe-setting/babel</guid>
      <title>Babel 알아보기</title>
      <link>https://www.howdy-mj.me/fe-setting/babel</link>
      undefined
      <pubDate>Sun, 19 Jul 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>fe-setting</category>
      <content:encoded>
## Babel(바벨)

각 브라우저마다 사용하는 문법이 달라서 크롬에서 정상적으로 동작하는 것일지라도, IE나 사파리에서는 제대로 동작이 안될 수도 있다.

[Can I use](https://caniuse.com/)에서 원하는 기능을 검색하면 어떤 브라우저에서 사용할 수 있는지 확인할 수 있다.

가령, IE에서는 ES6에서 나온 화살표 함수나 템플릿 리터럴 사용이 불가하다.



이런 크로스브라우징의 문제를 해결해 주는 것이 바로 바벨(Babel)이다. 바벨은 ECMAScript2015 이후로 나온 모든 코드를 각 브라우저에서 동작하도록 호환성을 지켜준다. 또한, TypeScript나 JSX처럼 다른 언어로 분류되는 것도 포함한다. 이렇게 바꾸어주는 것을 '트랜스파일(transpile)'이라 표현한다.

### 바벨 설치

[바벨](https://babeljs.io/)은 자바스크립트의 컴파일러(compiler)라고 소개되고 있다.

_컴파일(compile)은 사람이 작성한 코드를 컴퓨터가 이해할 수 있도록 바꿔주는 과정이고, 트랜스파일(transpile)은 다른 실행 환경에서 돌아갈 수 있는 언어로 바꿔주는 과정이다_

```shell
$ npm install -D @babel/core  @babel/cli
```

여기서 바벨을 개발의존성(devDependencies)으로 설치하는 이유는, 바벨은 어플리케이션 실행 때 필요한 것이 아니라 빌드 할 때 필요한 것이기 때문이다.

`@babel/core`는 바벨을 사용할 때 항상 필요한 패키지이고, `@babel/cli`는 터미널에서 커맨드를 입력해 바벨을 사용할 때 필요한 패키지이다.

app.js

```js
const name = 'kmj'
;`Hello, ${name}`
```

바벨 설치가 완료되면, `app.js`에 ES6에 추가된 것을 만들고, `node_modules/.bin`에 추가된 바벨 명령어를 사용할 수 있다.

```shell
$ npx babel app.js
# const name = 'kmj';
# `Hello, ${name}`
```

하지만 출력된 것은 기존 `app.js`와 같다.

왜냐하면 아직 바벨에게 어떻게 코드를 변환할지 알려주지 않았기 때문이다.

변환은 **플러그인(plugin)**이나 **프리셋(preset)**을 통해 할 수 있다. 플러그인은 규칙을 세세하게 적용하고 싶을 때 사용하며, 프리셋은 여러 개의 규칙을 한 번에 적용할 때 사용한다.



### 플러그인

babel-plugin.js

```js
module.exports = function myplugin() {
  return {
    visitor: {
      // https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-block-scoping/src/index.js#L26
      VariableDeclaration(path) {
        console.log('VariableDeclaration() kind:', path.node.kind) // const

        if (path.node.kind === 'const') {
          // const를 var로 바꿔라
          path.node.kind = 'var'
        }
      },
    },
  }
}
```

IE에서 알아볼 수 있도록, `const`를 `var`로 변환하는 플러그인을 만들어보자.

이후 플러그인을 실행하는 커맨드를 치면 변환되는 것을 확인할 수 있다.

```shell
$ npx babel app.js --plugins ./babel-plugin.js
# VariableDeclaration() kind: const
# var name = 'kmj';
# `Hello, ${name}`;
```

정말 다행히도, 이런 규칙들을 하나 씩 설정할 필요 없이, 바벨에서 자주 사용하는 플러그인을 먼저 만들어주었다.

`const`를 `var`로 바꾸어주는 [block-scoping](https://babeljs.io/docs/en/babel-plugin-transform-block-scoping) 플러그인, 화살표 함수를 지원해주는 [arrow-functions](https://babeljs.io/docs/en/babel-plugin-transform-arrow-functions) 플러그인 그리고 ES5부터 지원하는 [strict-mode](https://babeljs.io/docs/en/babel-plugin-transform-strict-mode) 플러그인 등을 설치하고, `babel.config.js` 파일에 설정해두면 된다.

```shell
$ npm install -D @babel/plugin-transform-block-scoping @babel/plugin-transform-arrow-functions @babel/plugin-transform-strict-mode
```

babel.config.js

```js
module.exports = {
  plugins: [
    '@babel/plugin-transform-block-scoping',
    '@babel/plugin-transform-arrow-functions',
    '@babel/plugin-transform-strict-mode',
  ],
}
```

이후 다시 바벨을 실행하면 아래와 같은 결과를 볼 수 있다.

```shell
$ npx babel app.js
"use strict";

# var name = 'kmj';
# `Hello, ${name}`;
```



### 프리셋

플러그인은 각 규칙을 적용하기 위해 각각의 플러그인을 설치하고 설정해야 했다.
프리셋은 이런 목적에 맞게 여러가지 플러그인을 세트로 모아놓은 것을 말한다.

프리셋을 사용하기 위해 이전에 설정해 놓은 것을 약간 수정해보자.

mypreset.js

```js
module.exports = function myPreset() {
  return {
    plugins: [
      '@babel/plugin-transform-arrow-functions',
      '@babel/plugin-transform-block-scoping',
      '@babel/plugin-transform-strict-mode',
    ],
  }
}
```

`babel.config.js`

```js
module.exports = {
  presets: ['./myPreset.js'],
}
```

이처럼 프리셋은 각각의 목적에 맞는 [프리셋](https://babeljs.io/docs/en/presets)을 제공한다.

그 중에서도, IE 지원을 위해 env 프리셋을 먼저 알아보자.

```shell
$ npm install -D @babel/preset-env
```

babel.config.js

```js
module.exports = {
  presets: ['@babel/preset-env'],
}
```

이후 다시 빌드해보면 `const`가 `var`로 바뀌고, 템플릿 리터럴도 ES5에 맞게 바뀐 것을 확인할 수 있다.

```shell
$ npx babel app.js
# "use strict";

# var name = 'kmj';
# "Hello, ".concat(name);
```

`preset-env`를 통해 지원하는 브라우저도 따로 설정할 수 있다.



### 웹팩으로 통합

바벨은 웹팩의 loader 형태로 제공되는 데 이것이 `babel-loader`이다.

```shell
$ npm install -D babel-loader
```

설치 후, 웹팩에 로더를 추가해준다.

webpack.config.js

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: 'babel-loader',
      },
    ],
  },
}
```

.js 확장자로 끝나는 파일을 babel-loader가 처리하도록 설정한다.
사용하는 외부 라이브러리가 많을 수록, 바벨 로더가 느리게 동작하여 node_modules 폴더를 제외하고 처리하도록 한다. ([참고](https://github.com/babel/babel-loader#babel-loader-is-slow))

그 후, `entry`를 방금 만든 `app.js`로 바꾸고 `npm run build`로 빌드한다면 `dis/main.js`가 생성된 것을 볼 수 있다.



**참고**



- https://babeljs.io/
- http://jeonghwan-kim.github.io/series/2019/12/22/frontend-dev-env-babel.html
- https://www.daleseo.com/js-babel/


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/react/flux-pattern</guid>
      <title>Flux(플럭스)</title>
      <link>https://www.howdy-mj.me/react/flux-pattern</link>
      undefined
      <pubDate>Sat, 18 Jul 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>react</category>
      <content:encoded>
## Flux란?

Flux(플럭스)는 데이터 흐름을 한 방향으로 유지하기 위해 페이스북에서 설계한 디자인 패턴(\*객체 지향 프로그래밍 설계를 할 때 자주 발생하는 문제들을 해결하기 위해 사용하는 패턴)이다.

_그렇다면 페이스북은 왜 Flux를 만들었을까?_

Flux 이전에는 다양한 MVC 디자인 패턴이 웹 개발에서 주를 이루고 있었다.



### MVC

https://developer.mozilla.org/ko/docs/Glossary/MVC

MVC란 Model View Controller의 약자로 어플리케이션을 세 가지 역할로 나눈 것이다.

사용자가 Controller를 조작하면 Controller는 Model을 통해서 데이터를 가져오고 그에 기반하여 View가 바뀐 화면을 사용자에게 보여준다.

각자 자기가 맡은 역할에 집중할 수 있지만, 한 Model은 다수의 View들을 가질 수 있고, 반대로 Controller를 통해 한 View에 여러 Model이 연결될 수도 있다.

따라서 프로젝트가 커질 경우, Model과 View의 전후 관계를 따지기가 매우 힘들다.

페이스북의 경우, 알림이 떠서 알림창에 들어가보면 아무것도 없는 현상이 발생했다. 얽혀있는 데이터들이 너무 많았기 때문에 정확히 어떤 이유 때문에 알림이 울렸는지 찾을 수 없어서 단 방향으로 유지할 수 있는 Flux 디자인 패턴이 나오게 되었다.



### Flux 구조

https://facebook.github.io/flux/docs/in-depth-overview

Flux는 단방향 데이터 흐름을 갖고 있다.

- Action: 사용자의 요청을 표현
- Dispatcher: 중앙 제어 컴포넌트로 액션을 가져와 스토어에게 알려줌
- Store: 상태(state)를 저장하는 곳
- View: 변경된 것을 화면에 반영

만약 사용자가 어떤 버튼을 눌러 자신의 정보를 제출했다고 가정해보자.

이 버튼을 누르는 행위를 액션(action)이라 하며, 액션은 변화를 일으키는 명령과 데이터를 디스패처(dispatcher)에게 알려준다. 그러면 디스패처는 스토어(store)에 있는 상태 값을 변경하라고 스토어에게 알려주며, 변경 된 후, 뷰(view)를 갱신한다.

### Flux 구현

여러가지 플럭스 구현이 존재한다.

- [Flux(플럭스)](https://github.com/facebook/flux): 해당 글에서 소개한 디자인 패턴이다.
- [Redux(리덕스)](https://redux.js.org/): 객체가 아닌 함수를 통해 모듈화를 달성하는 플럭스와 비슷한 라이브러리이다.
- [MobX(몹엑스)](https://mobx.js.org/README.html): 옵저버블(observable)을 사용해 상태 변화에 반응하는 반응형(reactive) 상태 관리 라이브러리이다.
- [Reflux(리플럭스)](https://github.com/reflux/refluxjs): 액션, 스토어, 뷰에 초점을 맞춰 단방향 데이터 흐름을 더 단순하게 접근한다.
- [Flummox(플럼목스)](https://github.com/acdlite/flummox): 자바스크립트 클래스를 상속해서 플러긋 모듈을 만들게 해주는 플럭스 구현이다.



**참고**



- https://facebook.github.io/flux/
- https://opentutorials.org/course/697/3828
- https://velog.io/@ljinsk3/Concept-MVC-Pattern
- 러닝 리액트, 한빛미디어, p237


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/fe-setting/webpack-basic-2</guid>
      <title>Webpack 웹팩 알아보기(2) : plugin</title>
      <link>https://www.howdy-mj.me/fe-setting/webpack-basic-2</link>
      undefined
      <pubDate>Wed, 15 Jul 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>fe-setting</category>
      <content:encoded>
## 플러그인(Plugin)

로더가 파일 단위로 처리하는 반면, 플러그인은 번들된 결과물을 처리한다. 번들된 자바스크립트를 난독화 한다거나 특정 텍스트를 추출하는 용도로 사용한다.

공식홈페이지의 [Basic Plugin Architecture](https://webpack.js.org/contribute/writing-a-plugin/)를 따라해보자.

hello-world-plugin.js

```js
class HelloWorldPlugin {
  apply(compiler) {
    // plugin이 종료 되었을 때 실행된다.
    compiler.hooks.done.tap('Hello World Plugin', stats => {
      console.log('Hello World!')
    })
  }
}

module.exports = HelloWorldPlugin
```

loader가 함수형으로 정의된 것과 다르게, plugin은 클래스형으로 정의된다.

webpack.config.js

```js
const HelloWorldPlugin = require('./hello-world-plugin')

module.exports = {
  plugins: [new HelloWorldPlugin()],
}
```

설정을 마치고 `npm run build`를 하면 'Hello World!'가 찍힌 것을 볼 수 있다.

```shell{3}
$ npm run build

Hello World!
Hash: cabe67579d243965d759
Version: webpack 4.43.0
Time: 1349ms
Built at: 2020-07-15 23:46:13
                                  Asset      Size  Chunks             Chunk Names
bg.png?5c6d3b633991b51295c68b34d8b94c8b  1.17 MiB          [emitted]
                                main.js    22 KiB    main  [emitted]  main
Entrypoint main = main.js
[./node_modules/css-loader/dist/cjs.js!./src/app.css] 581 bytes {main} [built]
[./src/app.css] 517 bytes {main} [built]
[./src/app.js] 186 bytes {main} [built]
[./src/bg.png] 64 bytes {main} [built]
[./src/howdy.png] 2.93 KiB {main} [built]
    + 3 hidden modules
```

그럼 이제 웹팩이 번들링한 결과물에는 어떻게 접근할까?

이때 `compiler`와 `compilation`이 필요하다. 이들의 역할을 이해하는 것이 웹팩 엔진을 확장하는 중요한 첫 걸음이다. 이 둘을 외, 중요한 것은 [plugins API](https://webpack.js.org/api/plugins/) 문서를 보면된다.

### compiler

[compiler](https://webpack.js.org/api/compiler-hooks/) 모듈은 모든 옵션이 CLI 혹은 Node API를 통해 전달되는 compilation instance를 생성하는 메인 엔진이다.

`compiler`의 Hooks는 아래와 같다.

```js
compiler.hooks.someHook.tap('MyPlugin', params => {
  /* ... */
})
```

hook 타입에 따라 `tapAsync`와 `tapPromise`가 될 수도 있다.

### compilation

[compilation](https://webpack.js.org/api/compilation-hooks/) 모듈은 `compiler`에 의해 사용되며, 새로운 compilations를 만들거나 build 할 때 사용한다.

```js
compilation.hooks.someHook.tap(/* ... */)
```

`compiler`와 마찬가지로 hook 타입에 따라 `tapAsync`와 `tapPromise`를 사용할 수 있다.

### tap, tapAsync, tapPromise

`tap`은 동기로 동작하는 것에 사용하며, `tapAsync`와 `tapPromise`는 이름에서도 알 수 있듯이 비동기를 처리할 때 사용한다.

`tapAsync`

```js
class HelloAsyncPlugin {
  apply(compiler) {
    compiler.hooks.emit.tapAsync(
      'HelloAsyncPlugin',
      (compilation, callback) => {
        // Do something async...
        setTimeout(function() {
          console.log('Done with async work...')
          callback()
        }, 1000)
      }
    )
  }
}

module.exports = HelloAsyncPlugin
```

`tapPromise`

```js
class HelloAsyncPlugin {
  apply(compiler) {
    compiler.hooks.emit.tapPromise('HelloAsyncPlugin', compilation => {
      // return a Promise that resolves when we are done...
      return new Promise((resolve, reject) => {
        setTimeout(function() {
          console.log('Done with async work...')
          resolve()
        }, 1000)
      })
    })
  }
}

module.exports = HelloAsyncPlugin
```

인자로 받는 것이 약간 다르다.



다시 본론으로 돌아와, 번들링한 결과물을 보기 위해 `compiler`를 사용해보겠다.

```js
class HelloWorldPlugin {
  apply(compiler) {
    compiler.hooks.emit.tapAsync(
      'HelloWorldPlugin',
      (compilation, callback) => {
        const source = compilation.assets['main.js'].source()
        console.log(source)
      }
    )
  }
}
```

제대로 번들링이 되었는지 확인하기 위해 `npm run build`를 하면 해독하기 힘든 형태의 텍스트가 터미널에 찍히는 걸 볼 수 있다.



## 자주 사용하는 플러그인

웹팩 자체에서 제공하는 플러그인 중에, 자주 사용되는 것이 몇 가지 있다.

### BannerPlugin

[배너플러그인](https://webpack.js.org/plugins/banner-plugin/)은 build 된 것의 제일 상단에 작성한 내용을 보여준다.

webpack.config.js

```js
const webpack = require('webpack');

module.exports = {
  ...,
  plugins: [new webpack.BannerPlugin({
    banner: `
      Build Date: ${new Date().toLocaleDateString()}
    `
  })],
}
```

이렇게 설정 한후, `npm run build`를 하면 '배너 플러그인'이 `dist/main.js`의 제일 상단에 있는 것을 볼 수 있다.

배너플러그인은 해당 파일의 작성 시간, 담당자 등 표기할 때 많이 사용한다.

### DefinePlugin

[DefinePlugin](https://webpack.js.org/plugins/define-plugin/)은 컴파일 시간에 전역 변수를 생성하게 해준다.

어플리케이션은 개발(development)환경과 운영(production)환경이 나뉘어서 운영 된다. 이때 사용하는 API 주소가 다를 수 있는데, 이를 DefinePlugin으로 정보를 저장할 수 있다.

현재 환경을 알기 위해서는 `process.env.NODE_ENV`로 접근하면 어떤 환경인지 알 수 있다.

webpack.config.js

```js
module.exports = {
  ...,
  plugins: [new webpack.DefinePlugin({})],
}
```

이를 설정하고, 아무 `.js`에서 `console.log(process.env.NODE_ENV)`를 하고 `npm run build` 후, HTML 파일을 열어 확인해보면 'development'가 나오는 것을 확인할 수 있다.

환경에 따른 API를 변수로 저장하자면 아래와 같이 할 수 있다.

```js
module.exports = {
  ...,
  plugins: new webpack.DefinePlugin({
    DEVELOPMENT_API: JSON.stringify('http://localhost:5000'),
    PRODUCTION_API: JSON.stringify('http://123.456')
  })],
}
```

그 후, 다시 console로 찍어보면 정상적으로 나오는 것을 알 수 있다.



이는 Node 런타임에서 `process.env`에 저장되는 환경 변수를 전역 변수로 등록해주는 [EnvironmentPlugin](https://webpack.js.org/plugins/environment-plugin/)이랑 자주 쓰인다.

### CleanWebpackPlugin

[CleanWebpackPlugin](https://github.com/johnagan/clean-webpack-plugin)은 빌드 이전의 결과물을 제거해주는 플러그인이다.

```shell
$ npm install -D clean-webpack-plugin
```

webpack.config.js

```js
const { CleanWebpackPlugin }= require('clean-webpack-plugin');

module.exports = {
  ...,
  plugin: [
    new CleanwebpackPlugin()
  ]
}
```

설정 후, `npm run build`를 하면 `/dist` 폴더에 있는 것이 없어지고 새로 build 되는 것을 확인할 수 있다.



이 외에도, 번들한 CSS, JS파일을 각각의 HTML 파일에 태그로 추가해주는 [HtmlWebpackPlugin](https://github.com/jantimon/html-webpack-plugin/), , 번들 결과에서 CSS 코드만 뽑아 별도의 파일로 분리해주는 [MiniCssExtractPlugin](https://github.com/webpack-contrib/mini-css-extract-plugin)이 있다.



**참고**



- https://webpack.js.org/
- https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html
- https://joshua1988.github.io/webpack-guide
- https://www.daleseo.com/webpack-plugins-define-environment/


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/next/setting-theme-globalstyle</guid>
      <title>Next.js에서 Globalstyle 적용하기</title>
      <link>https://www.howdy-mj.me/next/setting-theme-globalstyle</link>
      undefined
      <pubDate>Tue, 14 Jul 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>next</category><category>css-in-js</category>
      <content:encoded>
GlobalStyle은 User agent stylesheet(웹 브라우저의 기본 속성값)을 제거하기 위해 많이 설정한다.

## Next.js에서 Globalstyle 적용하기

Next.js는 `_app.js`와 `_document.js`가 제일 처음에 실행된다. (참고: [Next.js 구동방식](https://howdy-mj.me/next/next-js-intro/#nextjs%EC%9D%98-ssr))

```
node_modules/
pages
├─ _app.js
├─ _document.js
└─ index.js
package.json
package-lock.json
```

Next.js의 기본 구조는 위와 같으며, GlobalStyle은 `_app.js`에서 설정하면 된다.

\_app.js

```js
// external modules
import React from 'react'
import App from 'next/app'
import { ThemeProvider } from 'styled-components'

// internal modules
import GlobalStyle from '../components/GlobalStyle'
import theme from '../components/theme'

class WrappedApp extends App {
  render() {
    const { Component, ...other } = this.props
    return (
      <>
        
          
            
          
        
      
    )
  }
}

export default WrappedApp
```

구조는 React와 크게 다르지 않지만, 추가된 게 있다면 `Component, ...other`이다.

여기서 `Component`는 `pages` 폴더에 있는 것을 말하며, 모든 컴포넌트를 `ThemeProvider`와 `GlobalStyle`로 감싸주어 어디에서든 적용되게 하는 것이다.

### GlobalStyle

GlobalStyle의 기본 틀은 아래와 같다.

GlobalStyle.js

```js
const GlobalStyle = props => {
  return (
    
      {props.children}
      
        {`
          * {
            margin: 0;
            padding: 0;
            border: 0;
            font-size: 100%;
            font: inherit;
            vertical-align: baseline;
            box-sizing: border-box;
          }
        `}
      
    
  )
}

export default GlobalStyle
```

### theme.js

필자의 경우 `theme.js`에는 반응형 breakpoint와 색상을 넣어두었다.

```js
const size = {
  mobile: '400px',
  tablet: '768px',
  laptopS: '1023px',
  laptopM: '1239px',
  desktop: '1240px',
}

const theme = {
  mainColor: '#0055b8',
  subColor: '#0a4297',
  mobile: `(max-width): ${size.mobile}`,
  tablet: `(max-width: ${size.tablet})`,
  laptopS: `(max-width: ${size.laptopS})`,
  laptopM: `(max-width: ${size.laptopM})`,
  desktop: `(min-width: ${size.desktop})`,
}

export default theme
```

이렇게 설정하고 바로 `npm run dev`를 하면 가끔 적용이 안 되는 경우가 있다.

이때는 `npm run build`로 먼저 정적 페이지를 생성하고 다시 `npm run dev`를 하면 정상적으로 적용되는 것을 볼 수 있다.



**참고**



- https://nextjs.org/docs/advanced-features/custom-app


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/next/getStaticProps-error</guid>
      <title>Next.js getStaticProps undefined 에러</title>
      <link>https://www.howdy-mj.me/next/getStaticProps-error</link>
      undefined
      <pubDate>Sun, 05 Jul 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>next</category>
      <content:encoded>
## getStaticProps() undefined 에러 해결하기

pre-render에서 데이터를 fetch해오기 위해 Next 9.3에서 권장하는 `getStaticProps()`를 이용하여 불러왔다.

하지만 분명히 [공식 홈페이지](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation)에서 한대로 컴포넌트에 props로 넘겨주었는데, 막상 실행시켰을 때는 `undefined`가 뜬다.

```js
function Blog({ posts }) {
  return (
    
      {posts.map(post => (
        {post.title}
      ))}
    
  )
}

export async function getStaticProps() {
  const res = await fetch('https://.../posts')
  const posts = await res.json()
  return {
    props: { posts },
  }
}

export default Blog
```

아직 이 개념이 나온지 몇 달이 되지 않아 구글링하며 preview나 mdx도 시도해보고 `next.config.js`에서 설정도 하면서 며칠 삽질 했는데 정말 너무 간단하게 해결됐다...

사용할 컴포넌트에 `{ props }` 값이 아닌 `props` 자체를 넘겨주면 된다.

필자는 카테고리 `list`를 `getStaticProps()`로 불러와 사용했기에 해당 예제로 바꾸겠다.

```js
export async function getStaticProps() {
  const res = await fetch(CATEGORY)
  const list = await res.json()
  return {
    props: { list },
  }
}

export default function HomePage(props) {
  console.log(props);

  return (...)
}
```


console.log 결과


따라서 아래와 같이 변수에 할당하여 사용했다.

```js
const categoryfromAPI = props.pageProps.list
const contentList = categoryfromAPI.content_types
const stackList = categoryfromAPI.stacks
const creatorList = categoryfromAPI.channels
```

이제 pre-render 단계에서 데이터를 fetch해오기 때문에 렌더링 될때 깜빡임이 없어졌다.
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/next/next-js-intro</guid>
      <title>Next.js 설치, 라우팅, 구동방식</title>
      <link>https://www.howdy-mj.me/next/next-js-intro</link>
      undefined
      <pubDate>Thu, 02 Jul 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>next</category>
      <content:encoded>
본 글은 [공식 문서](https://nextjs.org/docs/getting-started) 기준으로 작성되었습니다.

## 소개

React는 CSR이기에 SEO가 안된다는 치명적인 단점이 있다. 물론 cra eject로 설정하여 적용할 수 있지만, 번거롭기 때문에 더 편리하게 사용할 수 있는 Next.js(이하 Next)가 나왔다.

Next가 나오면서 SSR가 되며, 더 빠르게 페이지를 불러오기 위해 코드 스프릿도 지원한다.

## 설치

_해당 글은 next 9.4.4 버전으로 작성되었습니다._

```shell
$ npx create-next-app 폴더명
$ npm install next react react-dom
```

정상적으로 설치 되었다면 `package.json`에 아래와 같은 scripts가 있는 걸 확인할 수 있다.

```json
"scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
},
```

`react`와 달리 생성 후 아무것도 존재하지 않는다. 그래서 폴더부터 하나씩 만들어야 한다.
`pages` 폴더에 `index.js`를 만들어보자.

폴더 구조

```
node_modules/
pages
└─ index.js
package.json
packgae-lock.json
```

index.js

```js
function HomePage() {
  return Welcome to Next.js!
}

export default HomePage
```

그 후, `npm run dev`로 서버를 돌리면 http://localhost:3000 에서 서버가 열린다.

```shell
$ npm run dev

ready - started server on http://localhost:3000
event - compiled successfully
event - build page: /next/dist/pages/_error
wait  - compiling...
event - compiled successfully
event - build page: /
wait  - compiling...
event - compiled successfully
```

`npm run dev`을 하면 위의 코드가 CLI창에 뜨면서 `.next`라는 폴더가 생기는 것을 볼 수 있다.




이를 통해 next는 자동으로 컴파일과 빌드(웹팩과 바벨로)를 진행하며 `/`에 페이지를 정적으로 페이지를 만드는 것을 확인할 수 있다.

## Router

React와 달리 Next는 static한 페이지를 만들며, `pages` 폴더 안에 있는 js 파일이 하나의 URL처럼 작동된다.

그렇다면 about 페이지를 만들어보자.

```
node_modules/
pages
├─ index.js
└─ about.js
package.json
packgae-lock.json
```

pages/about.js

```js
function About() {
  return About
}

export default About
```

그리고 `pages/index.js`에 Link를 추가해주자.

```js
import Link from 'next/link'

function HomePage() {
  return (
    
      Welcome to Next.js!
      
      About
    
  )
}

export default HomePage
```



그러면 위와 같은 화면이 렌더되며, About을 누르면 `localhost:3000/about`에 생성한 `about.js` 화면이 표시된다.

## Next의 SSR

여기까지 와서 나는 Next가 어떻게 SSR이 가능한지 궁금해졌다.

그러기 위해서는 Next의 구동 순서에 대해 알아야한다.

Next는 `_app.js`와 `_document.js`가 제일 처음에 실행된다. 두 파일 모두 `pages` 폴더 안에 있어야 한다.

우리가 맨 처음에 프로젝트를 생성할 때 없는 파일이지만, Next 자체에서 제공하는 로직으로 실행된다. 따라서 프로젝트 입맛에 맞게 만들기 위해서는 커스터마이징을 해야 하는데 바로 이 두개의 파일에서 진행된다.

두 파일 모두 Server only file로 클라이언트 단에서 사용하는 함수(ex. addEventlistner, window 등)를 사용하면 안된다.

_app.js

최초로 실행되는 파일로, Client에서 띄워지는 전체 컴포넌트의 레이아웃이라 이해하면 된다. 공통 레이아웃으로 최초에 실행되어 내부에 들어갈 컴포넌트들을 실행한다.

```js
import React from 'react'
import App from 'next/app'

function App {
  render() {
    const { Component, ...other } = this.props
    return 
  }
}

export default App
```

여기서 `Component`란 props로 받은 페이지들을 뜻한다.

_document.js

그 다음에 `_document.js`가 실행되는데, 이는 `_app.js`에서 구성한 HTML이 어떤 형태로 들어갈지 구성해주는 것이다.

```js
import Document, { Html, Head, Main, NextScript } from 'next/document'

class MyDocument extends Document {
  render() {
    return (
      
        
        
          
          
        
      
    )
  }
}

export default MyDocument
```

getInitialProps

React에서 프로젝트를 진행하면 렌더링 후에 `componentDidMount`나 `useEffect()`로 데이터를 불러와야 한다. 하지만 Next에서는 `getInitialProps`를 통해 데이터를 미리 불러와 한 번에 렌더링이 가능하다. 미리 데이터를 불러옴으로 속도가 빨라지며, 코드 상의 처리가 깔끔해진다.

_Next 9.3 이후로는 `getStaticProps`나 `getServerSideProps` 사용을 권장한다. 아래에서 더 자세히 설명._

만약 어디에서나 공통된 데이터가 필요하다면 `_app.js`에 `getInitialProps`를 붙이면 되고, 각기 다른 데이터가 필요하다면 페이지마다 `getInitialProps`를 붙이면 된다.

각 페이지마다 `getInitialProps`를 붙이는 방법은 아래와 같다.

```js
function Page({ stars }) {
  return Next stars: {stars}
}

Page.getInitialProps = async ctx => {
  const res = await fetch('https://api.github.com/repos/vercel/next.js')
  const json = await res.json()
  return { stars: json.stargazers_count }
}

export default Page
```

**주의**:

- `getInitialProps`으로 리턴되는 객체는 Date, Map, Set으로 사용되는 것이 아닌 순수 객체여야 한다.
- `getInitialProps`은 자식 컴포넌트에서 사용할 수 없으며, 오로지 default export 컴포넌트에서만 사용할 수 있다.

**Context Object**

`getInitialProps`는 `context`라는 단일 인자를 받는데, 설정하지 않는다면 기본값으로 설정된다.

- `pathname` - `pages` 폴더 안에 있는 현재 Route
- `query` - 객체로 이루어진 쿼리스트링, ex. /category?id=phone에서 {id: 'phone'}
- `asPath` - query를 포함한 `String`의 실제 경로, ex. /category?id=phone 전체 경로
- `req` - HTTP request object (server only)
- `res` - HTTP response object (server only)
- `err` - Error object if any error is encountered during the rendering

## Data fetching

Next 9.3에서는 `getInitialProps`보다 `getStaticProps`와 `getServerSideProps` 사용을 권장한다.

간단히 먼저 소개하자면,

- `getStaticProps` (Static Generation): 빌드(build)할 때 데이터를 불러옴
- `getStaticPaths` (Static Generation): 데이터에 기반하여 pre-render때 특정한 동적 라우팅 구현
- `getServerSideProps` (Server-side Rendering): 요청(request)아 있을 때 데이터를 불러옴

getStaticProps

어떤 페이지에서 `getStaticProps` 함수를 `async`로 export하면, `getStaticProps`에서 리턴되는 props를 가지고 페이지를 pre-render 한다.

```js
export async function getStaticProps(context) {
  return {
    props: {}, // 컴포넌트로 넘어갈 props
  }
}
```

`context`에 몇 가지 매개변수가 존재한다.

- `params`: 페이지의 동적 라우팅에 사용되는 라우트 매개변수를 지닌다. 페이지 이름이 `[id].js`라면 `params`는 `{id: ...}`로 보인다.
- `preview`: true일 때 preview 모드가 된다.
- `previewData`: `setPreviewData`로 설정한 preview data를 지닌다.

기본적인 틀은 아래와 같다.

```js
// getStaticProps()에 의해 build 시간에 게시물이 채워진다
function Blog({ posts }) {
  return (
    
      {posts.map(post => (
        {post.title}
      ))}
    
  )
}

// 아래 함수는 서버 단에서 build 시간에 호출된다.
// 클라이언트 단에서 호출되지 않으므로, 직접 데이터베이스 쿼리에도 접근 가능하다.
export async function getStaticProps() {
  const res = await fetch('https://.../posts')
  const posts = await res.json()

  // By returning { props: posts }을 리턴하여 Blog 컴포넌트는 build 시간에 'posts'를 props로 받는다.
  return {
    props: {
      posts,
    },
  }
}

export default Blog
```

**`getStaticProps`를 사용해야 될 때:**

- 페이지를 렌더링 하는데 사용자의 요청보다 먼저 build 시간에 필요한 데이터를 가져올 때
- headless CMS에서 데이터가 올 때
- 공개적으로 캐시될 수 있는 데이터(특정 유저가 아닌)
- 페이지가 사전 렌더링(ex. SEO)되어야 하고 엄청 빨라야 할 때(getStatidProps는 HTML과 JSON 파일을 생성하며, 이 두 파일 모두 CDN에서 성능을 위해 캐시할 수 있음)

getStaticPaths

동적 라우팅이 필요하다면 `getStaticPaths`로 경로 리스트를 정의해야하고, HTML에 build 시간에 렌더되어야 한다.

Next는 pre-render에서 정적으로 `getStaticPaths`에서 호출하는 경로들을 가져올 것이다.

```js
export async function getStaticPaths() {
  return {
    paths: [
      { params: { ... } }
    ],
    fallback: true or false
  };
}
```

**[paths](https://nextjs.org/docs/basic-features/data-fetching#the-paths-key-required)**

- `paths`는 동적 라우팅 경로를 pre-render한다. (ex. `pages/posts/[id].js`)

- `params`는 페이지 이름에 사용되는 매개변수와 일치해야 한다.
  만약 페이지 이름이 `pages/posts/[postId]/[commentId]`라면, `params`는 `postId`와 `commentId`를 포함해야 한다.

- 만약 페이지 이름이 `pages/[...slug]`와 같이 모든 경로를 사용한다면, `params`는 slug가 담긴 배열이어야 한다.

**[fallback](https://nextjs.org/docs/basic-features/data-fetching#the-fallback-key-required)**

- `false`라면 `getStaticPaths`로 리턴되지 않은 것은 모두 404 페이지가 뜰 것이다.
- `true`라면 `getStaticPaths`로 리턴되는 것은 build 시간에 HTML이 렌더될 것이다.

```js
return {
  paths: [
    { params: { id: '1' } },
    { params: { id: '2' } }
  ],
  fallback: ...
}
```

getServerSideProps

어떤 페이지에서 `getServerSideProps` 함수를 `async`로 export하면, Next는 각 요청(request)마다 리턴되는 데이터를 `getServerSideProps`로 pre-render한다.

```js
export async function getServerSideProps(context) {
  return {
    props: {}, // 컴포넌트로 넘어갈 props
  }
}
```

**Context Object**

`getServerSideProps`의 `context`는 `getStaticProps`의 것과 비슷한다.

- `params` - 만약 해당 페이지가 동적 라우팅이 사용된다면 `params`는 라우팅 매개변수를 지닌다. 페이지 이름이 `[id].js`라면 `params`는 `{id: ...}`
- `req` - HTTP request object
- `res` - HTTP response object
- `query` - 쿼리스트링
- `preview`: true일 때 preview 모드가 된다.
- `previewData`: `setPreviewData`로 설정한 preview data를 지닌다.

```js
function Page({ data }) {
  // 렌더 데이터...
}

// 매 요청마다 호출된다
export async function getServerSideProps() {
  // 외부 API에서 데이터 호출
  const res = await fetch(`https://.../data`)
  const data = await res.json()

  // 페이지에 props로 데이터 보내기
  return { props: { data } }
}

export default Page
```

**`getServerSideProps`를 사용해야 될 때:**

- 요청(request)할 때 데이터를 가져와야 하는 페이지를 미리 렌더해야 할때 사용한다. 서버가 모든 요청에 대한 결과를 계산하고, 추가 구성 없이 CDN에 의해 결과를 캐시할 수 없기 때문에 첫 번째 바이트까지의 시간(TTFB)은 `getStaticProps`보다 느리다.
- 만약 미리 렌더를 하지 않아도 될 경우, [클라이언트 단](https://nextjs.org/docs/basic-features/data-fetching#fetching-data-on-the-client-side)에서 데이터를 불러오는 것을 고려해야 한다.



**참고**



- https://nextjs.org/
- https://velog.io/@cyranocoding/Next-js-%EA%B5%AC%EB%8F%99%EB%B0%A9%EC%8B%9D-%EA%B3%BC-getInitialProps


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/javascript/async</guid>
      <title>자바스크립트 비동기 함수 알아보기</title>
      <link>https://www.howdy-mj.me/javascript/async</link>
      undefined
      <pubDate>Thu, 25 Jun 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>javascript</category>
      <content:encoded>

해당 글보다 2022.2.1에 새로 작성한 자바스크립트의 비동기 프로그래밍 글을 봐주세요!



## 비동기(Asynchronous) 함수란?

자바스크립트는 싱글스레드이기 때문에 한 번에 하나의 작업만 수행할 수 있다. 이를 해결하기 위해 **비동기**가 생겼다.

비동기란 특정 코드의 처리가 끝나기 전에 다음 코드를 실행할 수 있는 것을 뜻한다.

카페에 비유하자면, 만약 알바생이 한 명이라면 주문과 음료 제조를 동시에 하지 못한다. 하지만 여러 명이 있다면, 한명이 주문을 받으면 그 순서에 맞게 다른 사람이 음료 제조를 하여 주문과 음료 제조를 동시에 할 수 있다.

자바스크립트는 즉시 처리하지 못하는 이벤트들을 이벤트 루프에 모아 놓고, 먼저 처리해야하는 이벤트를 실행한다.

자바스크립트에서 가장 대표적인 비동기 처리 사례에는 `setTimeout()`이 있으며 일정 시간 뒤에 함수를 실행시키는 것이다.

```js
console.log('Start')

setTimeout(function() {
  console.log('5초 후 실행')
}, 5000)

console.log('End')
```

위와 같은 코드가 있다면 console에는 'Start', 'End'가 바로 찍히고 그 다음에 '5초 후 실행'이 찍힌다.

## 비동기 방식

자바스크립트에는 콜백 함수, Promise, async await 이렇게 크게 3가지 비동기 방식이 존재한다.



### 콜백(Callback) 함수

자바스크립트 비동기하면 '콜백 지옥'이라는 단어를 몇 번 봤을 것이다.

콜백 함수는 하나만 썼을 때는 간단하지만, 비동기로 함수의 매개 변수에 다른 콜백 함수가 중첩되어 사용된다면 그 코드를 보기에 굉장히 어렵고 유지보수도 힘들어진다.

```js
step1(function(value1) {
  step2(function(value2) {
    step3(function(value3) {
      step4(function(value4) {
        step5(function(value5) {
          step6(function(value6) {
            // Do something with value6
          })
        })
      })
    })
  })
})
```

이 코드에서 에러를 잡기 위해서는 각 콜백 함수마다 에러 처리를 써야하는데 그럼 코드량도 어마어마해진다.

```js
step1(function(err, value1) {
  if (err) {
    console.log(err)
    return
  }
  step2(function(err, value2) {
    if (err) {
      console.log(err)
      return
    }
    step3(function(err, value3) {
      if (err) {
        console.log(err)
        return
      }
      step4(function(err, value4) {
        // ,...
      })
    })
  })
})
```



### Promise

위의 콜백 문제를 해결하기 위해 ES2015에 Promise가 도입되었다. 콜백 함수의 error, success의 처리를 보다 간단하게 하기 위해 Promise가 생겼다.

Promise는 latency, delay(지연) 때문에 현재 당장 얻을 수 없지만 가까운 미래에 얻을 수 있는 데이터에 접근하기 위한 방법을 제공한다. Promise로 비동기 작업이 완료된 후 결과 값을 받을 수 있다.

### Promise 생성 및 상태

Promise는 `new Promise()`로 생성할 수 있으며, 종료될 때 세 가지 상태를 갖는다.

- Pending(대기): 이행하거나 거부되지 않은 초기 상태
- Fulfilled(이행): 완료되어 프로미스가 결과 값을 반환해준 상태
- Rejected(거부): 실패하거나 오류가 발생항 상태



https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise


Promise는 `resolve`와 `reject` 2개의 인자를 받으며, 비동기 처리가 성공하면 `resolve`가 호출되고, 실패하면 `reject`가 호출된다.

```js
const promise = new Promise((res, rej) => {
  setTimeout(() => {
    res('성공')
  }, 1000)
})
```

### Promise Chaining

Promise의 또 다른 특징은 체이닝(chaining)인데, `.then()`을 이용해서 여러개의 Promise를 이을 수 있다는 것이다.

```js
new Promise(function(resolve, reject) {
  setTimeout(function() {
    resolve(0)
  }, 2000)
})
  .then(function(result) {
    console.log(result) // output: 0
    return result + 10
  })
  .then(function(result) {
    console.log(result) // output: 10
    return result + 20
  })
  .then(function(result) {
    console.log(result) // output: 30
  })
```

`.then()`으로 앞의 return 값을 받아서 최종 console 값이 30이 된 걸 볼 수 있다.

이 외, Promise에서 에러 처리를 할 수도 있는데 보통 `catch()`를 사용한다.

```js
const promise = new Promise((res, rej) => {
  setTimeout(() => {
    rej('에러 발생')
  }, 1000)
})

promise.then(res => console.log(res)).catch(err => console.error(err))
// output: 에러 발생
```

그러나 Promise도 중첩으로 인해 콜백과 동일한 hell이 발생할 수 있다.



#### Quiz: 어떤게 먼저 실행될까?

```js
console.log('hi')

setTimeout(function() {
  console.log('0.1')
}, 100)

Promise.resolve()
  .then(function() {
    console.log('first')
  })
  .then(function() {
    console.log('second')
  })

setTimeout(function() {
  console.log('0')
}, 0)

console.log('end')
```

정답은

```
hi
end
first
second
0
0.1
```

순 이다.

`setTimeout()`과 `Promise`는 모두 비동기 함수이지만, setTimeout은 태스크 큐지만, Promise는 비동기 중에서도 먼저 실행되는 마이크로태스크 큐에 들어있기 때문에 먼저 실행이 된다. 이벤트 루프는 콜 스택이 비면 먼저 마이크로태스크 큐에서 대기하고 있는 함수를 실행 하고, 이후에 태스크 큐에서 대기하고 있는 함수를 가져와 실행한다.



### async await

async await를 ES2017에 등장한 것인데, Promise의 메서드 체이닝을 더 깔끔한 코드를 작성할 수 있게끔 만들어진 것이다. 콜백 hell을 없애줄 수 있게 되었다.

async await의 기본 구조를 아래와 같다.

```js
const getSomthing = async () => {
  await doSomething()
}
```

함수 앞에 `async`를 붙이고, 비동기 처리할 코드 앞에 `await`를 붙인다.

[MDN 예문](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/async_function)을 가져와 보겠다.

```js
const asyncFunc = async () => {
  console.log('calling')
  await setTimeout(() => console.log('resolved'), 2000)
}

asyncFunc()
```

이렇게 실행하면 먼저 `calling`이 찍히고, 2초 뒤에 `resolved`가 찍히는 것을 볼 수 있다.



async await도 `try`와 `catch`로 성공 및 에러 여부를 감지할 수 있다.

Promise와 async await의 코드 차이를 한번에 보자.

`Promise`

```js
const promise = new Promise((res, rej) => {
  console.log('first')
  setTimeout(() => {
    res('2초 후')
  }, 2000)
  console.log('end of function')
})

promise.then(res => console.log(res)).catch(err => console.error(err))
```

`async await`

```js
const asyncFunc = async () => {
  try {
    console.log('first')
    await setTimeout(() => console.log('2초 후'), 2000)
  } catch (err) {
    console.log(err)
  }
  console.log('end of function')
}

asyncFunc()
```

두 함수의 결과 모두 `first`, `end of function`이 바로 찍히고, 2초 후에 `2초 후`가 console에 찍힌다.

같은 비동기 함수임에도 async await을 사용하면 코드를 더 깔끔하게 작성할 수 있다.



**참고**



- https://joshua1988.github.io/web-development/javascript/javascript-asynchronous-operation/
- https://joshua1988.github.io/web-development/javascript/js-async-await/
- https://velog.io/@yejinh/%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0
- https://librewiki.net/wiki/%EC%BD%9C%EB%B0%B1_%EC%A7%80%EC%98%A5
- https://www.daleseo.com/js-async-callback/
- https://ithub.tistory.com/223


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/fe-setting/webpack-basic-1</guid>
      <title>Webpack 웹팩 알아보기(1): entry/output, loader</title>
      <link>https://www.howdy-mj.me/fe-setting/webpack-basic-1</link>
      undefined
      <pubDate>Sat, 13 Jun 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>fe-setting</category>
      <content:encoded>

해당 글에서 자세히 설명되지 않은 용어는 npm:소개, 설치, 명령어, 배포 글에서 볼 수 있다.
해당 글은 webpack4를 기준으로 작성되었다.


## 웹팩 나오게 된 배경

다른 사람이 만들어 둔 함수, 혹은 자신이 만들어둔 것을 나중에 다른 곳에서 import하여 쓰고 싶다면 모듈로 만들어 쓸 수 있다.

하지만 자바스크립트는 모두 같은 전역 스코프에 해당하기 때문에 자칫 잘못하면 스코프 오염이 생기면서 런타임 에러가 발생할 수 있다.

그래서 정의되자마자 즉시 실행되는 함수([IIFE](https://developer.mozilla.org/ko/docs/Glossary/IIFE))로 오염을 방지했다.

```js
(function() {
  function add(a, b) {
    return a + b
  }
})()
```

이러한 방식으로 자바스크립트 모듈을 구현하는 대표적인 명세에 AMD와 CommonJS가 있다.

CommonJS는 자바스크립트를 사용하는 모든 환경에서 모듈을 하는 것이 목표로, `exports` 키워드로 모듈을 만들고 `require()` 함수로 불러 들이는 방식이다. 대표적으로 서버 사이드 플랫폼인 Node.js에서 이를 사용한다.

AMD(Asynchronous Module Definition)는 비동기로 로딩되는 환경에서 모듈을 사용하는 것이 주 목표로, 주로 브라우저 환경이다.

UMD(Universal Module Definition)는 AMD 기반으로 CommonJS 방식까지 지원하는 통합 형태이다.



add.js

```js
export function add(a, b) {
    return a + b;
}
```

app.js

```js
const math = require('./add.js')
math.add(1, 2) // output: 3;
```

이렇게 만든 모듈을 `index.html`에서 불러오면 사용가능하다.

```html

```

하지만 아직 모든 브라우저에서 모듈 시스템을 지원하지 않는다. 그래서 웹팩이 나오게 되었다.

## 웹팩의 원리

![webpack](https://user-images.githubusercontent.com/58619071/193439343-31489a93-9702-43ec-9bd1-b43c356423f1.PNG)

[Webpack](https://webpack.js.org/)의 메인 화면이다. 왼쪽을 보면 여러 모듈들이 얽혀있다. 위에서 `app.js`에서 `add.js`를 불러와 사용하는 것을 예로 들 수 있다.

웹팩 번들링 작업을 위해 [webpack](https://github.com/webpack/webpack)과 [webpack-cli](https://github.com/webpack/webpack-cli)를 설치해야 한다.

웹팩3까지는 `webpack`만 설치해도 됐었는데, 웹팩4부터는 `webpack-cli`를 같이 설치해야 커맨드라인에 webpack 명령어를 사용할 수 있다.

```shell
# webpack 설치
$ npm install --save-dev webpack
# or
$ yarn add webpack --dev

# webpakc-cli 설치
$ npm install --save-dev webpack-cli
# or
$ yarn add webpack-cli --dev
```

`-dev`를 쓰면 `package.json`에서 `devDependencies`로 설치가 되는데, 이는 개발용 패키지라는 뜻이다.

설치가 잘 되었다면, `node_moduels/.bin`에서 webpack과 webpack-cli를 볼 수 있다. 해당 경로에 가서 `webpack -h`를 치면 [명령어](https://webpack.js.org/api/cli/)를 볼 수 있는데, 우리가 필수로 봐야할 세 가지는 `--mode`, `--entry`, `--output, -o`이다.

```shell
Config options:
  --mode      Enable production optimizations or development hints.
              [선택: "development", "production", "none"]

Basic options:
  --entry      The entry point(s) of the compilation.        [문자열]

Output options:
  --output, -o        The output path and file for compilation assets
```

|   옵션   |                              값                              |
| :------: | :----------------------------------------------------------: |
|  --mode  |             "development", "production", "none"              |
|          |   - devleopment: 개발환경에서 사용, 개발 옵션을 추가할 때    |
|          | - production: 운영환경, 운영 배포 시 필요한 최적화 설정할 때 |
| --entry  |                     모듈이 시작하는 부분                     |
| --output |        모듈을 하나로 합쳐서 결과를 저장하는 경로 설정        |

최상의 폴더에 `webpack.config.js`를 만들고 아래와 같이 쓰면 기본적인 설정을 완료한 것이다.

```js
const path = require('path')

module.exports = {
  mode: 'development', // 개발 환경으로 설정
  entry: './src/app.js', // 시작 경로 설정
  output: {
    filename: 'main.js', // 번들링 결과물 경로 설정
    path: path.resolve(__dirname, 'dist'),
  },
}
```

그 후, 아래 명령어를 치면 `dist/main.js`가 생긴 것을 볼 수 있다.

그럼 `index.html`에서 ``로 바꾸어도 전과 똑같은 화면이 나오는 것을 볼 수 있다.이렇게 `type="module"`을 삭제해도 여러개의 모듈을 하나로 합쳐주는 것을 알 수 있다.

```shell
$ npx webpack --config webpack.config.js

Hash: 97818daee5ecbc71e023
Version: webpack 4.43.0
Time: 48ms
Built at: 2020-06-14 16:51:44
  Asset      Size  Chunks             Chunk Names
main.js  4.83 KiB    main  [emitted]  main
Entrypoint main = main.js
[./src/app.js] 105 bytes {main} [built]
[./src/math.js] 313 bytes {main} [built]
```

앞으로 쉽게 웹팩을 실행할 수 있도록 `package.json`에 커스텀 명령어를 추가해보자.

```json
"scripts": {
    "build": "node_modules/.bin/webpack"
  },
```

이제 `npm run build`를 치면 웹팩이 빌드된다.

## 로더(Loader)

웹팩은 모든 파일을 모듈로 바라본다. 그리고 **로더(loader)**는 웹팩이 웹 애플리케이션을 해석할 때 자바스크립트로 만든 모듈뿐만 아니라, 타입스크립트 같은 다른 언어와 HTML, CSS, 이미지, 폰트 등을 자바스크립트 문법으로 변환하여 모듈로 import 할 수 있다.

로더를 만들면 `webpack.config.js`에 `module`에 대한 설정을 추가하면 된다.

```js
module: {
  rules: [
    {
      test: /\.js$/, // .js로 끝나는 모든 파일
      use: [path.resolve('./로더_파일명.js')],
    },
  ]
}
```

만약 CSS를 포함하여 빌드해야 하는데 로더가 없다면 CSS 문법을 이해하지 못하여 에러가 발생한다.

app.js

```js
import './app.css'
```

app.css

```css
body {
  background-color: aqua;
}
```

![](https://user-images.githubusercontent.com/58619071/193439346-643d97b0-b36c-4e35-a4c2-442c8b729036.png)

Module parse failed, 웹팩이 CSS를 이해하지 못하여 생긴 오류

따라서 웹팩이 다른 모듈들을 해석할 수 있도록 상황에 맞는 로더를 설치해줘야 한다.



### css-loader

[css-loader](https://webpack.js.org/loaders/css-loader/)는 웹팩이 CSS를 읽을 수 있도록 도와주는 로더이다.

설치

```shell
$ npm install --save-dev css-loader
```

webpack.config.js

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ['css-loader'],
      },
    ],
  },
}
```

이렇게 설정하고 아까 실패했던 빌드를 하면 정상 처리된 걸 볼 수 있다.

```shell
$ npm run build

Hash: 341fc5e0ff2d91722adf
Version: webpack 4.43.0
Time: 549ms
Built at: 2020-06-14 21:37:17
  Asset      Size  Chunks             Chunk Names
main.js  7.69 KiB    main  [emitted]  main
Entrypoint main = main.js
[./src/app.css] 276 bytes {main} [built]
[./src/app.js] 19 bytes {main} [built]
    + 1 hidden module
```

그리고 `dist/main.js`에서도 `background-color: aqua`라는 텍스트를 찾을 수 있다.

하지만 막상 `index.html`을 열어보면 배경색상이 적용되지 않은 걸 확인할 수 있다.

이는 자바스크립트에는 CSS가 적용되었지만, DOM에 아직 추가가 안돼서 브라우저가 아직 모르는 상태이기 때문이다. 이걸 도와주는 것이 [style-loader](https://webpack.js.org/loaders/style-loader/)이다.



### styled-loader

styled-loader는 자바스크립트 안에 있는 것을 HTML에 알려준다. 따라서 CSS를 모듈로 만들어 빌드하려면 css-loader와 styled-loader를 같이 사용해야 한다.

설치

```shell
$ npm install --save-dev style-loader
```

webpack.config.js

```js
module: {
  rules: [
    {
      test: /\.css$/,
      use: ['style-loader', 'css-loader'], // 뒤에서부터 앞이 실행되어 css-loader가 뒤쪽에 위치
    },
  ]
}
```

이후 다시 `npm run build`를 하면 HTML에서 배경색상이 바뀐 것을 확인할 수 있다.

HTML의 개발자 도구를 열어 Elements를 보면 ``에 ``에 인라인으로 스타일이 들어가 있는 것을 볼 수 있다.



### file-loader

로더는 CSS 뿐만 아니라, 이미지 파일도 처리할 수 있다.
이번에는 `app.css`에서 배경색상이 아닌, 이미지로 불러와서 build를 해보자.

app.css

```css
body {
  background-image: url(bg.png);
}
```

이 상태에서 웹팩을 빌드하면 아까와 같이 `Module parse failed` 에러가 난다.

[file-loader](https://webpack.js.org/loaders/file-loader/) 설치

```shell
$ npm install file-loader --save-dev
```

webpack.config.js

```js{8, 9}
module: {
  rules: [
    {
      test: /\.css$/,
      use: ['style-loader', 'css-loader'],
    },
    {
      test: /\.(png|jpg|gif|svg)$/,
      use: ['file-loader'],
    },
  ]
}
```

설정하고 빌드를 하면 `dist` 폴더에 이미지가 들어간 걸 확인할 수 있다. 웹팩은 빌드를 할 때마다 유니크한 값으로 저장하기 때문에 이미지 이름도 해시처리가 된다.



하지만 막상 `index.html`을 열어보면 이미지는 보이지 않으며 console 창에 `GET file:///... net::ERR_FILE_NOT_FOUND` 에러가 난다.

이는 `index.html`에서 바로 이미지를 불러오고 있기 때문인데, 실제 이미지는 `src/bg.png`에 있기 때문에 경로가 달라서 이미지를 못 찾는 것이다.

따라서 `webpack.config.js`에서 다시 설정을 해줘야 한다.

```js
{
  test: /\.(png|jpg|gif|svg)$/,
  loader: 'file-loader',
  options: {
      publicPath: './dist/',
      name: '[name].[ext]?[hash]' // 이름.확장자?해시값
  }
}
```



설정을 마치고 웹팩을 빌드해주면 `bg.png` 이름 그대로 `dist` 폴더에 들어간 걸 볼 수 있으며, `index.html`도 배경이 이미지로 바뀐 걸 확인할 수 있다.



### url-loader

사용하는 이미지가 많아지면 네트워크에 부담이 될 수 있다. 따라서 [Data URI Scheme](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/Data_URIs)를 사용하는 것이 더 나을 수 있다.

[url-loader](https://webpack.js.org/loaders/url-loader/)는 이미지를 base64로 인코딩하여 문자열 형태로 소스코드에 넣는 걸 처리해준다.

설치

```shell
$ npm install url-loader --save-dev
```

webpack.config.js

```js
{
  test: /\.(png|jpg|gif|svg)$/,
  loader: 'url-loader',
  options: {
      publicPath: './dist/',
      name: '[name].[ext]?[hash]',
      limit: 5000, // 5KB 미만의 파일은 url-loader로 처리
  }
}
```

이번에는 다른 이미지(위에 `limit`보다 작은 용량의 이미지 준비)를 `src` 폴더에 넣고 `app.js`에서 import 해오자.

```js
import './app.css'
import howdy from './howdy.png'

// DOM이 로드가 되면 img 불러오기
document.addEventListener('DOMContentLoaded', () => {
  document.body.innerHTML = `
        
    `
})
```

그리고 웹팩을 빌드하면, 아까 배경으로 넣었던 것은 그대로 `dist/bg.png`로 있지만, `howdy.png`는 5KB보다 작기 때문에 `main.js`에 인코딩되어 들어가 있다.



### 정리

- css-loader: CSS 파일을 자바스크립트 모듈로 처리
- style-loader: 자바스크립트를 HTML에 넣어 DOM에 적용되도록 처리
- file-loader: 이미지 파일을 모듈로 사용할 수 있도록 처리
- url-loader: 파일을 base64로 인코딩하여 자바스크립트에 문자열로 넘겨주는 것



**참고**



- https://webpack.js.org/
- https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html
- https://joshua1988.github.io/webpack-guide


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/general/difference-between-svg-and-font</guid>
      <title>Icon Fonts와 SVG의 차이</title>
      <link>https://www.howdy-mj.me/general/difference-between-svg-and-font</link>
      undefined
      <pubDate>Wed, 10 Jun 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>general</category>
      <content:encoded>
## 아이콘을 가져오는 방법

크게 세 가지 방법이 존재한다.

1. 이미지 파일 (ex. jpg, png 등)
2. Icon Fonts
3. SVG 파일

## 1. 이미지 파일

프론트를 처음 배우고 제일 먼저 아이콘을 불러올 때, 대부분 해당 아이콘 이미지를 다운받은 후 `img` 태그로 불러올 것이다.

```js

```

개인 프로젝트이면서 해당 이미지를 변경하지 않을 거라면 이미지 파일로 불러와도 큰 문제는 없다.

하지만 이미지 파일은 아이콘이 해상도나 색상을 바꿔야 할 때, 아이콘 원본 이미지 파일을 편집하고 저장 후, 다시 import 해와야 하는 번거로움이 있다.

## 2. Icon Fonts

이미지 파일의 불편함을 해소하고자 Icon Fonts가 나왔다. 유명한 Icon Fonts 사이트에는 [Font Awesome](https://fontawesome.com/)과 구글의 [Material Icons](https://google.github.io/material-design-icons/)가 있다.

Font는 벡터(vector)이기 때문에 CSS를 통해 해상도를 변경할 수 있다. 가장 보편적인 방법은 가상요소([pseudo element](https://developer.mozilla.org/ko/docs/Web/CSS/Pseudo-elements), ex. `::before`, `::after` 혹은 특정 요소)를 통해 적용하는 것이다.

```js

```

(자세한 사용방법은 Font Awesome 홈페이지에서 확인할 수 있다)

하지만 Icon Font에도 몇 가지 문제점이 있다.

가장 큰 문제는 깨져서 보인다는 것이다.

Font 자체는 벡터 그래픽 기반이지만, 브라우저에서는 텍스트로 취급되기 때문에 흐릿하게 보일 수도 있다. 그래서 렌더링할 때 [안티 에일리어싱](https://kbench.com/?q=node/1699)(Anti-Alising, AA, 모서리 선을 부드럽게 만드는 것) 문제를 해결하기 위해 정규화를 진행해야 한다.

그리고 이미 웹에 올라온 아이콘을 사용할 때는 문제가 없지만, 직접 제작하려면 폰트 제작 서비스에 의존해야 하며, 추가/삭제 자동화가 어렵고 번거롭다.

## 3. SVG 파일

이러한 불편함을 해소하기 위해 SVG를 사용한다.

SVG(Scalable Vector Graphics)은 2차원 벡터 그래픽을 표현하기 위한 [XML](https://ko.wikipedia.org/wiki/XML) 기반의 파일 형식으로, 1999년 W3C 주도하에 개발된 오픈 그래픽 표준이다. IE7 이전 버전을 제외한 대부분의 브라우저에서 지원된다. 벡터 기반이기 때문에 어떤 사이즈에서든 깨지지 않는다.


https://en.wikipedia.org/wiki/Scalable_Vector_Graphics

### import SVG

이 글은 React 기준으로 SVG import 방식에 대해 소개한다.

SVG는 `img` 태그, CSS background, JavaScript에서 inline으로 불러올 수도 있다.
그래서 SVG의 속성(ex. defs, fill 등)도 그대로 사용 가능하다. 혹은 가장 간단하게 [SVGR](https://react-svgr.com/) 라이브러리로도 바로 import할 수 있다.

이번 글에서는 inline과 SVGR로 불러오는 것을 다룰 것이다.

### (1) inline

W3School에 [SVG Tutorial](https://www.w3schools.com/graphics/svg_intro.asp)이 있어서 한 번씩 읽거나 따라해보면 이해가 빨리 될 것이다.

간단한 예제는 위의 SVG Tutorial에서 볼 수 있으니, 비교적 복잡한 암호화폐 거래소 [지닥](https://www.gdac.com/)의 로고를 살펴보겠다.



img 태그로 import 해온 것


```jsx

  
    
      .clsd-1 {
        fill: #00358d;
      }
      .clsd-2 {
        fill: #064fa2;
      }
      .clsd-3 {
        fill: #0b80ca;
      }
      .clsd-4 {
        fill: #139de0;
      }
      .clsd-5 {
        fill: #0969b6;
      }
      .clsd-6 {
        fill: #0c1430;
      }
    
  
  logo-dark
  
    
      
      
      
      
      
      
      
      
      
    
  

```

저 로고 하나를 inline으로 작성하려면 위의 코드처럼 속성 하나하나 다 지정해줘야 한다.

그럼 여기서 나오는 속성에 대해 간략하게 알아보자.

#### SVG 요소(Element) 및 속성(Attribute)

``: SVG 파일을 생성할 때 사용한다.

``: 다른 SVG element들을 그룹 지을때 사용한다.

``: 나중에 재사용할 element를 안에 정의한다.

``: element의 path를 지정할 때 사용하는데, `d` 속성 안에서 여러 명령어들로 정의된다.

- M = moveto(이동)
- L = lineto(선)
- H = horizontal lineto(수평선)
- V = vertical lineto(수직선)
- C = curveto(곡선)
- S = smooth curveto(완만한 곡선)
- Q = quadratic Bézier curve(베지에 곡선)
- T = smooth quadratic Bézier curveto(완만한 베지에 곡선)
- A = elliptical Arc(호(弧), 원이나 타원의 일부분)
- Z = closepath(path 끝)

위의 명령어들은 대문자, 소문자 모두 사용가능한데, 대문자는 절대적 좌표를 참조하고, 소문자는 상대적 좌표를 참조한다.

`viewBox`: min-x, min-y, width, height 4가지 값을 가진다. 만약 width, height를 0으로 지정하면 SVG가 렌더되지 않는다.

`fill`: 어떤 색상으로 채울 때 사용

[SVG 요소, 속성 더 자세히 알아보기](https://developer.mozilla.org/ko/docs/Web/SVG)

### (2) SVGR

```shell
# Node API
$ npm install @svgr/core
# or
$ yarn add @svgr/core

# Webpack
$ npm install @svgr/webpack --save-dev
# or
$ yarn add @svgr/webpack --dev
```

Node API로 설치한다면, custom script나 SVGR를 기반으로 다른 툴도 생성할 수 있다.

Webpack으로 설치한다면, SVG 파일을 바로 React Component로 import가 가능하다.

여기서는 Webpack으로 설명하겠다.
Webpack으로 사용하려면 아래와 같은 설정이 필요하다.

webpack.config.js

```js
{
  test: /\.svg$/,
  use: ['@svgr/webpack'],
}

// or
webpack(config) {
  config.module.rules.push({
    test: /\.svg$/,
    use: ["@svgr/webpack"]
  });
}
```

그리고 원하는 component에서 바로 import하면 된다.

```jsx
import Star from './star.svg'
const App = () => (
  
    
  
)
```

Webpack에 다른 옵션을 주거나 url-loader, babel 등을 설정하고 싶다면 [SVGR DOCS](https://react-svgr.com/docs/webpack/)를 참고하면 된다.



**참고**



- https://www.creativebloq.com/web-design/icon-fonts-vs-svg-101413211
- https://junojunho.com/front-end/svg-icon
- https://www.keycdn.com/blog/icon-fonts-vs-svgs
- http://jun.hansung.ac.kr/WP_2014/WP/lecture%20notes/SVG%20Introduction.html
- https://developer.mozilla.org/ko/docs/Web/SVG/Tutorial/Paths


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/storybook/04-how-to-use-knobs-addon</guid>
      <title>Storybook: Knobs addon 사용법</title>
      <link>https://www.howdy-mj.me/storybook/04-how-to-use-knobs-addon</link>
      undefined
      <pubDate>Tue, 09 Jun 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>storybook</category>
      <content:encoded>
해당 글의 모든 예시는 기본으로 설치되어 있는 `src/storeis/1-Button.stories.js`으로 진행한다. 보기 쉽게 `Emoji`는 삭제하고, `Text`에서 추가하는 형태로 진행하겠다.

## Knobs

- [Knobs repo](https://github.com/storybookjs/storybook/tree/master/addons/knobs)
- [Knobs 소개 및 설치](https://howdy-mj.me/storybook/02-addon-intro/#knobs)

Knobs는 component에 props가 있을 때, 더 보기 쉽게 도와주는 addon이다.

기존에 `1-Button.stories.js`에서 쓴 것을, `1-Button.js`에 Button 컴포넌트만 쓰고 import해오는 것으로 바꿔보겠다.

```
src
└─ stories
    ├─ 0-Weclome.stories.js
    ├─ 1-Button.css
    ├─ 1-Button.js
    └─ 1-Button.sotries.js
```

src/stories/1-Button.js

```jsx
import React from 'react'
import './1-Button.css'

const Button = ({ disabled, name, clicked }) => {
  return (
    
      Hi {name}
    
  )
}

export default Button
```

src/stories/1-Button.css

```css
.Button {
  padding: 10px;
  width: 100px;
  background-color: aliceblue;
  border-radius: 5px;
  border: none;
}
```

src/stories/1-Button.stories.js

```jsx
import React from 'react'
import { action } from '@storybook/addon-actions'
import { withKnobs, text, boolean } from '@storybook/addon-knobs'
import Button from './1-Button'

export default {
  title: 'Button', // 스토리북의 그룹과 경로
  component: Button, // 어떤 컴포넌트를 문서화 할지
  decorators: [withKnobs], // knobs 적용
}

export const buttonText = () => {
  // knobs 만들기
  const name = text('name', '버튼')
  const disabled = boolean('disabled', false)

  return 
}
```



위와 같이 코드를 쳤을 때 나오는 화면이다.

그럼 코드를 자세히 살펴보자.

`src/stories/1-Button.js`에서 필요한 props를 미리 component에 작성해서 넘겨주는 형태이다.

그리고 `src/stories/1-Button.stories.js`에서 해당 component째로 불러와서 사용하는데, 이 때 knobs가 있으면 위의 이미지처럼 Knobs 탭에서 바로 보고 수정도 할 수 있다.

`src/stories/1-Button.stories.js`는 쪼개서 설명하겠다.

```jsx
export default {
  title: 'Button', // 스토리북의 그룹과 경로
  component: Button, // 어떤 컴포넌트를 문서화 할지
  decorators: [withKnobs], // knobs 적용
}
```



`title`은 여기서 Button과 같은 카테고리 이름을 정할 때 사용한다.
만약 그룹단위로 묶어야 한다면 `title: "components|Button"`으로 작성하면 된다.



```jsx
import { withKnobs, text, boolean } from '@storybook/addon-knobs'

export const buttonText = () => {
  // knobs 만들기
  const name = text('name', '버튼')
  const disabled = boolean('disabled', false)

  return 
}
```

`Button`아래 `Button Text`로 들어오는데, 이는 component 이름을 camelCase로 `buttonText`로 작성해서 (신기하게도) 대문자 있는 곳까지 자르고 띄워쓰기를 해서 보여준다.

이제 knobs 사용법을 봐보자.

우선 맨 위에서 import를 해오고, knobs를 만들 때 사용해야 한다.
TypeScript랑 비슷하게 어떤 type을 갖는지 적어줘야 한다. (그래서 TypeScript와 많이 쓴다)

[Knobs repo](https://github.com/storybookjs/storybook/tree/master/addons/knobs)

어떤 것들을 보여주고 싶은지 선언했다면, return문에서 해당 컴포넌트에 들어갈 것을 props로 써준다.
해당 props는 `1-Button.js`에서 component를 만들 때 넣어줬기 때문에, 원하는 이름으로 넣어주면 된다.

그래서 아래와 같은 화면을 볼 수 있다.



```jsx
const name = text('name', '버튼')
```

이를 예로 들면, 왼쪽에 있는 것이 첫 번째 인자인 `'name'`이고, 오른쪽에 오는 것이 두 번째 인자 `'버튼'`이다.

만약 우리가 Storybook을 쓰지 않았을 때, 저기 버튼에 있는 내용을 바꾸고 싶다면 어떻게 해야 했을까?

React에서 직접 수정하고 웹 화면을 봤어야 한다.

하지만 Storybook은 Knobs로 props를 넘겨주었기 때문에 화면에서 바로 수정할 수 있다.

바로 아래처럼.



그래서 디자이너와 같은 화면에서 직접 고치면서 만족스러운 시안이 나오면 개발자는 그 값을 사용하면 돼서 매우 편하다.

이 외에도, size, color 등 모두 Knobs로 확인할 수 있으니 한 번 직접 해보면 이해가 더 빨리 갈 것이라 생각한다.
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/css/emotionjs-intro</guid>
      <title>emotion.js 소개 및 사용법 (feat. CSS-in-JS)</title>
      <link>https://www.howdy-mj.me/css/emotionjs-intro</link>
      undefined
      <pubDate>Mon, 08 Jun 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>css</category><category>css-in-js</category>
      <content:encoded>

업데이트: 2021.05.12 
- 주요 내용: @emotion/core 10.0.28 => @emotion/react 11.4.0


업데이트: 2021.05.19 
- 주요 내용: Global에서 사용하기, type 설정


## emotion.js란?

emotion.js는 CSS-in-JS의 종류 중 하나로 JavaScript 안에서 스타일을 작성할 수 있게 해준다.

emotion.js는 주로 Framework Agnostic(\*쉽게 말하면 프레임워크를 사용하지 않는 것)과 React 두 가지 방식으로 사용된다.

## emotion.js 설치

```shell
# Framework Agnostic
$ npm install @emotion/css

# React
$ npm install @emotion/react
```

```json
// 해당 글에서 사용된 버전
"dependencies": {
    "@emotion/react": "^11.4.0",
    "@emotion/styled": "^11.3.0",
    "react": "^17.0.2",
    "@emotion/babel-plugin": "^11.3.0"
}
```

## import 하기

emotion.js를 사용해야 할 컴포넌트에 먼저 import를 해야 한다.

```js{1}
/** @jsx jsx */
import { jsx, css } from '@emotion/react'
```

`/** @jsx jsx */`는 babel에게 `React.createElement` 대신 jsx를 jsx라는 함수로 변환하라는 뜻이다. (출처: [jsx-pragma](https://emotion.sh/docs/css-prop#jsx-pragma))

단순히 주석이라 생각하고 쓰지 않는다면 `@emotion/react`가 적용되지 않는다.

### 에러 발생

위의 코드를 따라 치면 `SyntaxError: ... pragma and pragmaFrag cannot be set when runtime is automatic.`와 같은 에러가 뜬다.
이는 리액트가 런타임에서 해당 줄을 인식하지 못하기 때문에 발생하는 에러이다.

가장 쉬운 방법은 공식 문서에 나온 것처럼 import문을 바꾸는 것이다.

```js
/** @jsxImportSource @emotion/react */
import { jsx, css } from '@emotion/react'
```

혹은, the new JSX runtimes을 지원하는 리액트에서는 런타임에 import가 가능하다고 나와있다. 필자는 현재 CRA 4+를 사용함에도 불구하고 자동으로 안돼서 babel을 설정해보았다.

```shell
$ npm install -D @babel/preset-react @emotion/babel-plugin
```

```json
// .babelrc
{
  "presets": [
    [
      "@babel/preset-react",
      { "runtime": "automatic", "importSource": "@emotion/react" }
    ],
    ["@emotion/babel-preset-css-prop"]
  ],
  "plugins": ["@emotion/babel-plugin"]
}
```

하지만 이것도 제대로 작동하지 않아서 우선 공식 문서에 나온 방법대로 진행한다. _(+추후 추가)_

만약 `@emotion/styled`를 사용한다면, 위의 import를 하지 않아도 바로 사용할 수 있다.

```js
import styled from '@emotion/styled'
```

그리고 Global Theme으로 설정한 변수를 바로 사용하기에는 `@emotion/styled`가 훨씬 편하다. 사용법은 `styled-components`와 똑같다.

### 기본 구조

공식 문서에 있는 예문을 같이 살펴보자.



```jsx
/** @jsxImportSource @emotion/react */
import { css, jsx } from '@emotion/react'

const divStyle = css`
  background-color: hotpink;
  font-size: 24px;
  border-radius: 4px;
  padding: 32px;
  text-align: center;
  &:hover {
    color: white;
  }
`

export default function App() {
  return Hover to change color.
}
```

기존에 styled-components를 써본 사람이라면 익숙한 구조일 것이다.

```jsx
import styled from 'styled-components'

const DivStyle = styled.div`
  background-color: hotpink;
  font-size: 24px;
  border-radius: 4px;
  padding: 32px;
  text-align: center;
  &:hover {
    color: white;
  }
`

export default function App() {
  return Hover to change color.
}
```

개인적으로 emotion.js가 더 편하다고 느낀 점은, jsx안에서 이게 어떤 태그인지 바로 알 수 있다는 점이다.

styled-components는 component 이름에 `div`, `p`등을 써놓지 않으면 이게 어떤 태그인지 바로 알 수 없다. 만약 해당 js파일에 내용이 많아 일일히 찾아야 한다면 엄청 번거롭다.

만약 styled-components처럼 사용하고 싶다면, @emotion/styled를 설치하면 된다.

```shell
$ npm install @emotion/styled @emotion/react
```

```js
import styled from '@emotion/styled'

const DivStyle = styled.div`
  background-color: hotpink;
  font-size: 24px;
  border-radius: 4px;
  padding: 32px;
  text-align: center;
  &:hover {
    color: white;
  }
`

export default function App() {
  return Hover to change color.
}
```

### 라벨링

`emotion.js`는 styled-components처럼 브라우저에서 열었을 때 className을 임의로 생성해준다.



이는 @emotion/babel-plugin을 사용하면 커스터마이징이 가능하다.

```shell
$ npm install --save-dev @emotion/babel-plugin
# or
$ yarn add --dev @emotion/babel-plugin
```

```jsx{10}
const divStyle = css`
  background-color: hotpink;
  font-size: 24px;
  border-radius: 4px;
  padding: 32px;
  text-align: center;
  &:hover {
    color: white;
  }
  label: divStyle;
`
```

```html

  ...

```

이렇게 바로 `css`에 label을 넣어 변경하는 방법도 있지만, 이는 매번 label 값을 넣어줘야 하고, 다른 개발자들과 같이 일하기에도 불편하기 때문에 `.babelrc`를 만들어 저장하는 것을 권장한다.

.babelrc

```json
{
  "plugins": [
    [
      "@emotion",
      {
        "autoLabel": "dev-only", // 기본값 'dev-only'
        "labelFormat": "mj-[dirname]-[filename]-[local]"
      }
    ]
  ]
}
```

_음.. 이번에도 바로 적용이 안된다. 추후 수정 필요_

이 방법 외에도, CRA 2.0+에서 Babel Macros를 지원하고 있다.

이는 Babel config없이 babel를 전환할 수 있는 것인데, styled-components도 이를 통해 className 라벨을 수정할 수 있다. 하지만 Babel Macros는 몇 최적화 작업이 불가능하기 때문에 `babel-plugin-emotion` 사용을 권장하고 있다.

### 재사용

스타일을 입힌 것을 component로 만들어서 어느 곳에서든 재사용이 가능하다.



```jsx
/** @jsxImportSource @emotion/react */

const P = props => (
  
)

const ArticleText = props => (
  
)

export default function App() {
  return (
    
      Using P component
      Using ArticleText component
    
  )
}
```

같은 CSS 속성이 있다면, 제일 최근 것으로 덮어씌워진다. (ex. `ArticleText`의 fontSize, fontFamily, color로 대체)

만약 component로 사용하여, CSS 속성을 inline으로 쓴다면 따로 `css`를 써줄 필요도 없으며, 속성명을 `camelCase`로 작성해야 한다. (ex. fontSize, fontFamily, backgroundColor 등)

### Nested

emotion.js에서 Nested도 사용가능하다.

```jsx
/** @jsxImportSource @emotion/react */
import { jsx, css } from '@emotion/react'

const paragraph = css`
  color: turquoise;

  a {
    border-bottom: 1px solid red;
    cursor: pointer;
  }
`
render(
  
    Some text.
    A link with a bottom border.
  
)
```

### 미디어 쿼리

반응형은 일반적으로 사용하는 미디어 쿼리와 사용법이 동일하다.

```jsx
/** @jsxImportSource @emotion/react */
import { jsx, css } from '@emotion/react'

render(
  
    Some text!
  
)
```

이 외에도, 미리 breakpoint를 선언하여 재사용 가능하게 만드는 법과 `facepaint` 패키지를 설치하여 더 쉽게 breakpoints를 만들 수도 있다.

emotion - Media Queries

## Global Theme 및 Typescript 설정

`styled-components`와 매우 비슷하다. (Styled Components를 Global에서 사용하기(w/반응형))

src/styles/global.tsx

```ts
import { Global, css } from '@emotion/react'

const style = css`
  * {
    margin: 0;
    padding: 0;
  }

  body {
    box-sizing: border-box;
  }
`

const GlobalStyle = () => {
  return 
}

export default GlobalStyle
```

src/styles/theme.ts

```ts
export const size = {
  largest: '75em', // 1200px
  large: '56.25em', // 900px
  medium: '37.5em', // 600px
  small: '31.25em', // 500px
  smallest: '25em', // 400px
}

const theme = {
  mainColor: '#0000ff',
  mq: {
    laptop: `@media only screen and (min-width: ${size.largest})`,
    tablet: `@media only screen and (min-width: ${size.large})`,
    mobile: `@media only screen and (min-width: ${size.small})`,
  },
}

export default theme
```

src/styles/emotion.d.ts

```ts
import '@emotion/react'

declare module '@emotion/react' {
  export interface Theme {
    mainColor: string
    mq: {
      laptop: string
      tablet: string
      mobile: string
    }
  }
}
```

타입스크립트를 사용할 경우, theme에 대한 타입 지정이 필요하다. `theme.ts`에서 설정한 것과 동일한 구조의 타입을 넣어주며, 파일 이름은 `emotion.d.ts`여야 한다.

src/index.tsx

```jsx
import ReactDOM from 'react-dom'
import { BrowserRouter } from 'react-router-dom'

import { ThemeProvider } from '@emotion/react'
import theme from '@styles/theme' // 위치한 경로 설정
import GlobalStyle from '@styles/global' // 위치한 경로 설정

import App from './App'

ReactDOM.render(
  
    
      
      
    
  ,
  document.getElementById('root')
)
```

잘 설정 되었다면, 어느 컴포넌트에서는 props로 꺼내 사용할 수 있다.

```jsx
// 1. @emotion/styled
import styled from '@emotion/styled'

interface LayoutProps {
  children: React.ReactChild;
}

const Layout = ({ children }: LayoutProps) => {
  return {children}
}

const LayoutWrap = styled.div`
  margin: 0 auto;
  max-width: 1200px;

  ${props => props.theme.mq.tablet} {
    max-width: 800px;
  }
`

export default Layout
```

```jsx
// 2. @emotion/react
/** @jsxImportSource @emotion/react */

const Login = () => {
  return  ({ color: theme.mainColor })}>Login
}

export default Login
```



## 번외) 왜 CSS-in-JS를 사용할까?

위에 작성된 내용과 종합하여 정리하면 아래와 같다.

- component로 만들어 재사용
- 중복되는 className 해결 (Global namespace)
- 자바스크립트에서 쓰이는 상수, props, 함수 공유하기
- 상속에 의한 영향이 없도록 격리 (Isolation)
- 미사용 코드 처리 (Dead Code Elimination)

어떤 글을 보면 CSS-in-JS로 '디자이너와 협업을 더 원활하게 할 수 있다'고 되어있다. 하지만 개인적으로 CSS-in-JS는 단순히 개발자들이 더 편하게 쓰기 위해 생긴 것이지, 디자이너와 협업을 위해 만들어진 것이 아닌 것 같다. 디자이너에게 가서 CSS-in-JS를 보여주면 어떻게 사용하는지 모르는 사람이 대부분일 것이라 생각한다.

또한, className을 짓지 않아도 된다는 장점이 있다고 하지만, 결국 사용해야 할 이름을 지어야 하는 건 똑같다. 하지만 scope가 있어서 다른 곳에서 중복으로 이름을 사용가능한 장점은 있다.



**참고**



- https://cssinjs.org/?v=v10.2.0
- https://d0gf00t.tistory.com/22
- https://medium.com/@okys2010/%EB%AA%A8%EB%8D%98-css-1-css-in-js-c1c53d9bbbc9
- https://medium.com/@oleg008/jss-is-css-d7d41400b635
- https://orezytivarg.github.io/css-evolution-from-css-sass-bem-css-modules-to-styled-components/
- https://ideveloper2.dev/blog/2019-05-05--thinking-about-emotion-js-vs-styled-component/


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/storybook/03-how-to-use-actions-addon</guid>
      <title>Storybook: Actions addon 사용법</title>
      <link>https://www.howdy-mj.me/storybook/03-how-to-use-actions-addon</link>
      undefined
      <pubDate>Sun, 07 Jun 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>storybook</category>
      <content:encoded>
해당 글의 모든 예시는 기본으로 설치되어 있는 `src/storeis/1-Button.stories.js`에서 추가하는 형태로 진행하겠다.

_해당 글은 Storybook 5.3 기준으로 작성되었습니다._

## Actions

- [Actions repo](https://github.com/storybookjs/storybook/tree/master/addons/actions)
- [Actions 소개 및 설치](https://howdy-mj.me/storybook/02-addon-intro/#actions)



```js{2, 11, 16}
import React from 'react'
import { action } from '@storybook/addon-actions'
import { Button } from '@storybook/react/demo'

export default {
  title: 'Button',
  component: Button,
}

export const Text = () => (
  Hello Button
)

export const Emoji = () => (
  
    
      😀 😎 👍 💯
    
  
)
```

Actions은 간단하다.
`actions`을 import하고, `onClick()`메소드에 넣어주면 된다.

![actions](https://user-images.githubusercontent.com/58619071/193442836-e53fe271-da13-49b9-ba92-aa85065aa519.png)

`onClick()`메소드가 있는 곳을 클릭하면 하단 Actions 탭에 'clicked'라는 이름으로 뜨는 것을 볼 수 있다.



### storiesOf ?

Storybook 이용법을 찾다보면 종종 `storiesOf`이란 문법을 볼 수 있다.
이는 [storiesOf API](https://storybook.js.org/docs/formats/storiesof-api/#docs-content)안에 있는 것으로 Storybook 5.2까지 사용된 stories 생성법이며, 지금은 사용하지 않아도 된다.
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/react-spring/05-interpolation</guid>
      <title>react-spring: Interpolation</title>
      <link>https://www.howdy-mj.me/react-spring/05-interpolation</link>
      undefined
      <pubDate>Fri, 05 Jun 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>react-spring</category>
      <content:encoded>
react-spring에서 등장하는 interpolation이 무엇인지 간단하게 알아보자.

글을 시작하기에 앞서, 필자는 그래픽, 통계, 컴퓨터 관련 전공이 아니기 때문에 설명이 정확하지 않을 수 있다. 하지만 interpolation이 대충 무엇인지 파악하는데는 충분할 거라 믿는다.

## Interpolation 단어적 의미

**interpolation**을 구글에 치면 가장 먼저 나오는 것이 '선형 보간법(linear, bilinear, trilinear interpolation)'이 나온다.

우선 이 글에서는 linear interpolation(선형 보간법)만 다루겠다.

선형은 직선이란 뜻이다.

그렇다면 **보간법**이 무엇일까?

국립국어원 표준국어대사전을 보면 '(수학) 둘 이상의 변숫값에 대한 함숫값을 알고서, 그것들 사이의 임의의 변숫값에 대한 함숫값이나 그 근삿값을 구하는 방법'을 뜻한다.

더 쉽게 보자면, 아래의 그림에서 p1과 p2 사이에 있는 점 p의 값을 추정하기 위해 '선형 보간법'을 사용할 수 있다.



https://ko.wikipedia.org/wiki/%EC%84%A0%ED%98%95_%EB%B3%B4%EA%B0%84%EB%B2%95

해당 그림에서 점 p를 구하는 공식은 아래와 같다.


https://ko.wikipedia.org/wiki/%EC%84%A0%ED%98%95_%EB%B3%B4%EA%B0%84%EB%B2%95



**회귀와 보간의 차이점**

회귀(regression)도 주어진 데이터로 어떤 값을 추정하는 것이지만, 회귀는 기존 데이터에 오차가 있다고 가정하여 오차범위를 생각하여 범위를 return한다.

하지만 보간(interpolation)은 기존 데이터가 정확한 데이터라 가정하기 때문에 결과값이 값으로 나온다.

## 언제 interpolation을 사용하는가?

이렇게만 보면 언제 사용되는지 잘 모를 수 있다.
우리가 interpolation을 가장 많이 체감할 수 있는건 사진이다.



위 짤처럼, 사람들이 퍼가다보면 사진 화질이 안좋아져서 확대하면 흐릿하게 보인다. 이때 우리는 주로 '픽셀(px)이 깨졌다'라고 표현한다.


https://twlab.tistory.com/23

해상도가 매우 높아 우리 눈에는 공백이 없는 사진처럼 보여도, 컴퓨터는 컴퓨터가 찾을 수 있는 가장 작은 단위의 px로 저장하기 때문에 확대를 하면 공백이 있을 수 밖에 없다.

그리고 이 공백을 주변의 px값에서 끌어와 채워주는게 바로 interpolation이다. 사진의 경우 주변에 있는 색상들로 공백인 px을 채운다.

그라데이션도 interpolation으로 그릴 수 있다.


https://www.pinterest.co.kr/pin/760475087054803380/

우리는 맨 위에 있는 분홍색 rgba와 아래 있는 하늘색 rbga를 정확하게 안다면, interpolation이 알아서 중간 값을 찾아서 그려준다.

## react-spring의 interpolation

사실 애니메이션은 시작 값을 x로, 끝나는 값을 y로 잡아서 for문으로 x값을 1씩 증가하여 y에 맞닿았을 때 종료해도 된다.

하지만 움직이는 것이 매우 부자연스러울 것이다. 이는 등속운동(균등한 속도로 움직이는 것)이라 그런 것이다.

자연스러운 움직임이라면, 처음 속도는 빨랐다가 점차 느리게 움직인다. 마치 야구선수가 공을 쳤을 때 잠시 공이 눈에 안보일 정도의 엄청난 속도로 나갔다가 점차 공의 움직임이 우리 눈에 보이고 느려지는 것처럼 말이다.


https://medium.com/motion-in-interaction/animation-principles-in-ui-design-understanding-easing-bea05243fe3

react-spring interpolation을 사용하면 자동으로 속도를 빠르게 가다 천천히 움직이게 해준다.
[interpolation.ts](https://github.com/react-spring/react-spring/blob/master/src/types/interpolation.ts)에 `easing`이 내장되어 있기 때문인 것 같다. (조정 가능)

### extrapolate

반대로 extrapolate(보외법)는 x와 y 사이의 있는 값을 추정하는 것이 아니라, 그 외의 범위를 추정해야 한다. 그렇기 때문에 정확한 예측은 불가능하다.

만약 기존의 데이터가 1, 2, 3이었다면 그 다음에 올 값을 4, 5로 예측하겠지만 어떻게 바뀔 지 알 수 없으니 정확하다 할 수 없다.



이번에 다룬건 linear interpolation이라 간단한 축에 속하지만, 만약 입체(trilinear interpolation)에 사용한다면 꽤나 까다롭고 어느정도 수학적 지식이 필요하다.



피드백은 언제나 환영합니다!
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/node/about-node</guid>
      <title>Node.js란?</title>
      <link>https://www.howdy-mj.me/node/about-node</link>
      undefined
      <pubDate>Thu, 04 Jun 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>node</category>
      <content:encoded>
## Node.js란 무엇인가?

대부분 npm은 아래처럼 기술되어 있다.

- npm은 Node Package Manager의 줄임말로 Node.js 패키지 관리를 원활하게 도와주는 것이다.
- npm은 Node.js의 패키지 생태계이면서 세계에서 가장 큰 오픈 소스 라이브러리이다.

그렇다면 Node.js란 무엇일까?

공식 홈페이지에서는 Node.js®는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임이다. Node.js는 싱글 스레드 이벤트 루프 기반, Non-Blocking I/O 모델을 사용해 가볍고 효율적이라 정의하고 있다.

그럼 다음의 키워드에 대해 하나씩 살펴보자.

- V8
- 자바스크립트 엔진
- 런타임
- Non-Blocking I/O
- 싱글 스레드
- 이벤트 루트 기반

### V8

V8은 C++로 작성된 구글의 오픈소스 고성능 자바스크립트와 WebAssembly(웹어셈블리: JavaScript API를 사용하여 최신 웹 브라우저에서 실행할 수 있는 새로운 유형의 코드, C/C++을 웹에서 동작할 수 있도록 컴파일 해줌) 엔진이다. Node.js의 런타임으로도 사용된다.

### 자바스크립트 엔진(JavaScript Engine)

자바스크립트 코드를 해석하고 실행하는 프로그램 또는 인터프리터(\*interpreter: 프로그래밍 언어를 바로 실행하는 컴퓨터 프로그램 또는 환경)이다. 위에 설명한 V8가 대표적인 자바스크립트 엔진 중 하나다.

### 런타임(Runtime)

런타임은 프로그램이 실행되고 있을 때 존재하는 곳을 말한다. 즉 컴퓨터 내에서 프로그램이 가동되면, 그것이 바로 그 프로그램의 런타임이다.  
원래 자바스크립트는 웹 브라우저에서만 사용할 수 있었지만, Node.js를 통해 서버 사이드 애플리케이션에서도 사용가능한 범용 개발 언어가 되었다. 그럼에도 자바스크립트는 여전히 웹에서 제일 많이 사용된다.

### 스레드(Thread)

스레드는 어떠한 프로그램 내에서, 특히 프로세스(\*운영체제로부터 자원을 할당받는 작업의 단위) 내에서 실행되는 흐름의 단위를 말한다. 일반적으로 한 프로그램은 하나의 스레드를 갖고 있지만, 프로그램 환경에 따라 둘 이상의 스레드를 동시에 실행할 수 있다.

![thread](https://user-images.githubusercontent.com/58619071/193441869-921c9683-892d-4ecf-8955-2aa1dd914ee8.png)

https://walkccc.github.io/CS/OS/Chap04/

**스레드와 프로세스**

프로세스는 실행될 때 운영체제로부터 CPU 시간, 필요한 주소 공간, code, data, stack, heap의 구조로 된 독립된 메모리 영역 등 자원을 할당 받는다.
스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(ex. heap 공간 등)을 같은 프로세스내에 스레드끼리 공유하면서 실행된다.



자바스크립트는 한번에 하나의 작업만 수행할 수 있는 **싱글 스레드(Single-Thread)**이다. 싱글 스레드는 먼저 들어온 요청을 전부 처리할 때까지 다른 요청을 받지 못한다. 따라서 자바스크립트에서는 비동기적 작업이 필수이다.

### 이벤트 루프(Event Loop)

싱글 스레드이기 때문에, 발생하는 이벤트 순서대로 실행하기 위해 이벤트 루프라는 개념이 있다.

이벤트 루프는 작업을 요청하면서 그 작업이 완료되었을 때 어떤 작업을 진행할지에 대한 콜백 함수를 지정하여 **동작이 완료되었을 때 해당 콜백 함수를 실행되는 동작 방식**을 말한다. 즉, 이벤트 발생 시 호출되는 콜백 함수들을 관리하여 콜백 큐(Callback queue)에 전달하고, 이를 콜 스택(Call stack)에 넘겨준다.

```js
// 예시
console.log('Hi')
setTimeout(function cb1() {
  console.log('cb1')
}, 5000)
console.log('Bye')
```

자바스크립트는 위에서 아래로 실행되는데, `setTimeout()`은 비동기 콜백함수이기 때문에 Web APIs에 보관되어 있다가 시간이 지나 호출될 때 콜백 큐에 전달 후, 콜 스택에 넘겨준다.


https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5

발생한 이벤트에 대해서만 웹서버가 연결해주기 때문에 자원을 최소화할 수 있는 장점이 있다. 대부분의 웹서버는 사용자가 이벤트를 발생하기까지를 기다리면서 자원(대기시간/메모리)을 계속 소비한다.

### Blocking & Non-Blocking I/O

**I/O**는 Input과 Output이 관련된 작업으로 http, Database CRUD, Third party API, Filtsystem 등 데이터나 정보를 가공하는 프로세스이다.
이 외에도, 대표적인 Input 장치로 키보드, 마우스, Output 장치에는 프린터가 있다.

**Blocking I/O**는 어떤 이벤트(작업)가 발생하면 그 이벤트가 완료될 때까지 기다려야 한다. 이는 이벤트 루프가 Blocking 작업을 하는 동안 JavaScript 실행을 계속 할 수 없기 때문이다. 또한 메모리 버퍼에 데이터를 차지하게 되므로 메모리도 소비한다.

이러한 비효율성을 극복하고자 나온 것이 **Non-blocking I/O**이다. Non-Blocking은 비동기 방식으로 콜백 함수를 받는다. 또한, I/O 작업을 진행하는 동안 유저 프로세스의 작업을 중단하지 않고 모듈을 변환시켜 다른 작업을 하도록 준비를 한다. 그래서 속도가 동기식 보다 빠르고 메모리도 덜 차지한다.

만약 Blocking I/O 였다면, 우리가 키보드를 칠 때 옆에있는 애니메이션이 멈출 것이다. 하지만 Non-Blocking I/O이기 때문에 타이핑을 하면서도 애니메이션이 끊기지 않는다.

## Node.js는 JavaScript만 돌아갈까?

사실 나는 Node.js가 자바스크립트 엔진으로 빌드된 것이기 때문에 당연히 자바스크립트에서만 사용할 수 있을 줄 알았다. 하지만 이는 편협된 사고였다.

Node.js로 서버를 만들다 보면, npm 패키지에 포함되지 않은 기능이 필요하거나 더 좋은 성능(빠른 속도, 적은 메모리 등)이 필요 할 때가 있다. 이럴 때 다른 프로그래밍 언어(Java, C, C++, Python)를 활용할 수 있으며, 해당 언어의 라이브러리에도 연결할 수 있다.

어떻게 import해서 쓰는지는 Node.js v14.4.0 Documentation을 참고하길 바란다.



### 번외) JavaScript가 싱글 스레드인 이유?

Node.js가 싱글 스레드인 이유는 자바스크립트가 싱글 스레드이기 때문이다.
그렇다면 자바스크립트는 왜 싱글 스레드로 만들어 졌을까?

처음에는 웹이 단순했기 때문에 빠른 처리를 위해 싱글 스레드로 만들거라 생각했다. 하지만 그 보다 예전 컴퓨터 사양을 보면 더 타당하게 추론할 수 있다.

최근 컴퓨터나 노트북의 코어 수는 보통 2개로, 4개의 스레드로 이루어져있다. 맥북의 경우 3 코어, 6 스레드이다.

코어: 단일 컴퓨팅 구성 요소에 들어 있는 독립된 CPU(중앙 처리 장치) 수를 나타내는 하드웨어 용어
스레드: 스레드 또는 스레드 확장은 싱글 CPU 코어를 경유하거나 싱글 CPU 코어에 의해 처리될 수 있는 기본 순서로 구성된 명령어 시퀀스를 가리키는 소프트웨어 용어

하지만 자바스크립트가 탄생했던 90년대 후반에는 듀얼 코어가 매우 획기적이고 희귀했다. 대부분은 1코어, 1스레드였다.



그렇기 때문에 누구든 웹 브라우저를 원활하게 사용할 수 있게 하기 위해 싱글 스레드로 만들었던게 아닐까 생각한다.



피드백은 언제나 환영합니다!



**참고**



- https://junspapa-itdev.tistory.com/3
- https://geonlee.tistory.com/92
- https://asfirstalways.tistory.com/43
- https://poiemaweb.com/js-browser
- https://edu.goorm.io/learn/lecture/557/%ED%95%9C-%EB%88%88%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-node-js/lesson/21763/%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EA%B8%B0%EB%B0%98-%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B0%A9%EC%8B%9D
- https://ko.wikipedia.org/wiki/%EC%8A%A4%EB%A0%88%EB%93%9C_(%EC%BB%B4%ED%93%A8%ED%8C%85)
- https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html
- https://medium.com/@vdongbin/javascript-%EC%9E%91%EB%8F%99%EC%9B%90%EB%A6%AC-single-thread-event-loop-asynchronous-e47e07b24d1c
- https://ui.toast.com/fe-guide/ko_DEPENDENCY-MANAGE/
- https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5
- https://tech.peoplefund.co.kr/2017/08/02/non-blocking-asynchronous-concurrency.html


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/node/about-npm</guid>
      <title>npm: 소개, 설치, 명령어, 배포</title>
      <link>https://www.howdy-mj.me/node/about-npm</link>
      undefined
      <pubDate>Wed, 03 Jun 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>node</category>
      <content:encoded>
## 1. npm이란?

React, Vue, Angular 등 자바스크립트 프레임워크를 사용해 본 사람이라면 `npm`이란 단어를 많이 접해봤을 것이다.

하지만 npm이 무엇이고, 어떻게 사용되는지 아는 사람은 많이 없다고 생각한다.

[npm](https://www.npmjs.com/)은 Node Package Manager의 줄임말로 Node.js 기반 패키지(모듈)(\*moudule: 애플리케이션을 이루는 기본 조각, 쉽게 말해 어떤 물건을 만들기 위해 쓰는 부품)들을 모아둔 저장소이다.

Node.js에서 제공하는 내장 모듈도 있으며, 사용자들이 직접 만든 유저모듈도 있다. npm은 이런 모듈(패키지)의 관리를 원활하게 도와준다.



npm은 세 가지 요소로 구성되어 있다.

**1. [Website](https://www.npmjs.com/)**

- 웹사이트를 통해 패키지들을 찾고, 관련 문서를 볼 수 있으며, 패키지를 공유하고 배포할 수 있다.

**2. [CLI](https://docs.npmjs.com/cli/npm)**

- Command Line Interface의 줄임말로, 터미널을 뜻한다.
- 대부분의 개발자들이 CLI를 통해 npm 패키지 업데이트/설치/제거/관리를 할 수 있다.

**3. [Registry](https://docs.npmjs.com/misc/registry)**

- 레지스트리는 큰 규모의 public 데이터베이스를 뜻하며, npm 레지스트리에는 자바스크립트 소프트웨어와 메타 정보들이 들어 있다.
- 현재 npm 레지스트리에는 100만개 이상의 패키지가 존재한다.
- package.json에 `private: true`를 설정하면 공개적 배포를 막아 줄 수 있다. (기본적으로 개인이 만든 CRA는 다 true로 설정되어 있다.)

## 2. npm으로 무엇을 할 수 있을까?

- 패키지의 코드들을 자신의 앱에 맞게 조정하거나, 그대로 사용할 수 있다.
- 바로 사용 가능한 독립적인 툴들을 다운로드 받을 수 있다.
- [npx](https://www.npmjs.com/package/npx)를 사용하여 다운로드하지 않고 패키지를 실행할 수 있다.
- 어디에서든 npm 사용자끼리 코드를 공유할 수 있다.
- 특정 개발자에게만 코드를 제한할 수 있다.
- 패키지 유지관리, 코딩 및 개발자를 조정하는 [Orgs](https://docs.npmjs.com/orgs/)(조직)을 만들 수 있다.
- [Orgs](https://docs.npmjs.com/orgs/)로 가상 팀을 구성할 수 있다.
- 여러 버전의 코드 및 코드 종속성 관리가 가능하다.
- 기존 코드가 업데이트 될 때 앱도 쉽게 업데이트 할 수 있다.
- 같은 문제를 다양한 방법으로 푸는 해결책을 찾을 수 있다.
- 유사한 문제와 프로젝트를 진행 중인 다른 개발자를 찾을 수 있다.



공식 홈페이지에 들어가기 전까지 npm은 단순하게 패키지를 설치하는 거라고만 알고 있었다.
하지만 단순히 패키지를 다운받는 것에 그치지 않고, npm [커뮤니티](https://npm.community/)에 자주 들어가보면 나에게 필요한 것을 많이 찾을 수 있을 것 같다.

## 3. npm 설치하기

npm은 Node.js를 통해 다운받아야 한다.

Node의 설치 유무를 보기 위해 버전 체크를 해보자.

```shell
node -v
npm -v
```

아무 숫자도 뜨지 않는다면 [다운로드](https://nodejs.org/en/download/)를 받아야 한다.

다운로드를 하고 다시 버전을 쳐보면 정상적으로 숫자가 나오는 것을 확인할 수 있다.

그 후, `package.json` 생성을 위해 아래와 같은 코드를 치자.

```shell
npm init
# or 질문 없이 바로 시작하고 싶다면
npm init -y
```

`package.json`은 프로젝트의 mainfest(\*컴퓨팅에서 집합의 일부 또는 논리정연한 단위인 파일들의 그룹을 위한 메타데이터를 포함하는 파일) 파일이다. 프로젝트 정보와 **의존성(dependencies) 관리**가 가능하며 작성된 `package.json` 문서로 어느 곳에서든 동일한 개발 환경을 구축할 수 있게 해준다.

그렇다면 이 **의존성 관리**가 무엇인지 알아보자.

초기의 자바스크립트는 간단한 작업을 위해 만들어졌지만, 웹 기술이 빠르게 발전하면서 점점 더 복잡한 코드가 늘어났다. 때문에 코드를 기능이나 페이지 단위로 분리하고 있지만, 아래 처럼 복잡한 의존 관계를 피할 수 없게 되었다.


https://ui.toast.com/fe-guide/ko_DEPENDENCY-MANAGE/

### 모듈의 필요성

자바스크립트는 파일이 나뉘어도 모두 같은 전역 스코프를 사용하며, 의도치 않게 다른 파일에 영향을 줄 수 있다. 하지만 자바스크립트 모듈 방식을 사용하면, 모듈의 독립된 스코프로 전역 스코프의 오염을 막을 뿐만 아니라 모듈 의존성을 코드로 작성할 수 있다. 따라서 복잡한 자바스크립트를 효율적으로 관리하기 위해서는 모듈 단위 개발을 해야 한다.

**모듈 스코프**
모듈 스코프는 전역과 분리된 모듈만의 독립된 스코프이다. 모듈 스코프에 선언된 변수나 함수는 외부에서 접근할 수 없고, 별도로 `export`한 변수와 함수만 외부에서 접근할 수 있다. (ex. ``)

A.js

```js
const name = 'foo'
export function getName() {
  return name
}
```

B.js

```js
import { getName } from 'A'

export function sayHello() {
  alert('Hello' + getName()) // Hello foo
}
```

모듈로 로드한 A.js에 정의된 name은 모듈 스코프에 포함한다. 따라서 B.js에서 name에 바로 접근할 수 없고 export된 getName 함수로만 name을 읽을 수 있다. 이처럼 모듈 스코프를 사용하면 전역 스코프가 여러 변수로 오염되는 것을 막을 수 있다. 또한, 코드 상에서 명시적으로 모듈을 가져오기 때문에 코드로 모듈간 의존성을 파악할 수 있다.

### npm을 통한 외부 패키지 의존성 관리

위처럼 `script`태그로 자바스크립트 파일을 import 한다면, 필요한 패키지를 의존성에 맞게 일일이 나열해야 하고 각 패키지의 버전을 알맞게 관리해야 한다. 하지만 npm을 사용하면 이 모든 것을 `package.json`으로 관리할 수 있다.

`package.json`에 패키지 이름과 버전 등의 기본적인 정보와 해당 패키지의 의존성을 기입해야 한다.

`package.json`

```json
{
  "name": "project-name", // 이름
  "version": "1.0.0", // 버전
  "keywords": [
    // 키워드, 배열로 작성
    "howdy",
    "mj"
  ],
  "description": "", // 설명
  "main": "index.js",
  "scripts": {
    // 스크립트
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "MJ", // 작성자
  "license": "MIT",
  "dependencies": {
    // 이 패키지를 실행하기 위해 필요한 의존성 정의
    // 해당 패키지가 동작하는데 필요한 패키지로 배포나 번들 시에 포함
    "react": "^16.13.1",
    "react-dom": "^16.13.1",
    "react-scripts": "3.4.1",
    "react-spring": "^9.0.0-rc.3"
  },
  "devDependencies": {
    // 이 패키지를 개발할 때 필요한 의존성 정의
    // 개발 단계에서만 필요하므로 배포나 번들 시에 포함되지 않음
  }
}
```

**번들러?**

번들러는 의존성이 있는 모듈 코드를 하나(또는 여러개)의 파일로 만들어주는 도구이다.

처음부터 하나의 js파일로 만드는 방법도 있겠지만, 그러기엔 코드가 너무 복잡해져서 유지보수도 힘들다. 따라서 처음에 아예 따로 만든 다음에 번들링 작업을 진행하는 것이다.

브라우저 환경에서는 CommonJS나 일부 ES6 Module로 작성된 코드를 바로 실행할 수 없으므로(크롬은 ES6 Module 지원), 모듈 코드를 분석하고 자바스크립트 모듈 스펙에 따라 새로운 코드로 가공이 필요하다. 이런 역할을 번들러가 해주고 있으며, 현재 [webpack](https://webpack.js.org/)이 각광받고 있다.


https://medium.com/@paul.allies/webpack-managing-javascript-and-css-dependencies-3b4913f49c58



하지만 같은 `package.json`을 설치하더라도 설치 시점에 따라 설치되는 패키지가 완벽히 같지 않을 수 있다. 왜냐하면 설치 시점에 의존 패키지가 업데이트 되었을 수도 있기 때문이다. 때문에 완벽히 같은 node modules를 설치하기 위해 npm 5부터 `package-lock.json`이 생겼다.

`package-lock.json`은 자동으로 생성되고 현재 설치된 패키지들의 버전과 의존성 관계를 모두 저장한다. 따라서 사용자가 개발 환경 그대로의 의존성 있는 패키지를 설치하여 사용할 수 있다.

`package-lock.json`예시:

```json{10, 25}
"react-redux": {
  "version": "7.2.0",
  "resolved": "https://registry.npmjs.org/react-redux/-/react-redux-7.2.0.tgz",
  "integrity": "sha512-EvCAZYGfOLqwV7gh849xy9/pt55rJXPwmYvI4lilPM5rUT/1NxuuN59ipdBksRVSvz0KInbPnp4IfoXJXCqiDA==",
  "requires": {
    "@babel/runtime": "^7.5.5",
    "hoist-non-react-statics": "^3.3.0",
    "loose-envify": "^1.4.0",
    "prop-types": "^15.7.2",
    "react-is": "^16.9.0"
  }
},
"react-router": {
  "version": "5.2.0",
  "resolved": "https://registry.npmjs.org/react-router/-/react-router-5.2.0.tgz",
  "integrity": "sha512-smz1DUuFHRKdcJC0jobGo8cVbhO3x50tCL4icacOlcwDOEQPq4TMqwx3sY1TP+DvtTgz4nm3thuo7A+BK2U0Dw==",
  "requires": {
    "@babel/runtime": "^7.1.2",
    "history": "^4.9.0",
    "hoist-non-react-statics": "^3.1.0",
    "loose-envify": "^1.3.1",
    "mini-create-react-context": "^0.4.0",
    "path-to-regexp": "^1.7.0",
    "prop-types": "^15.6.2",
    "react-is": "^16.6.0",
    "tiny-invariant": "^1.0.2",
    "tiny-warning": "^1.0.0"
  }
},
```

`react-redux`, `react-router` 모두 `react-is`라는 패키지를 참조하지만 서로 다른 버전을 사용하고 있다.



## 4. npm 버전

![semantic versioning](https://user-images.githubusercontent.com/58619071/193441952-a6f1addc-5db9-492f-a949-d6d2a2275dad.jpeg)

https://medium.com/beginners-guide-to-mobile-web-development/introduction-to-npm-and-basic-npm-commands-18aa16f69f6b

모든 패키지에는 세 가지 숫자가 존재하며 순서대로 major, minor, patch이다.

**major**는 기존 코드를 깨뜨릴 만큼 큰 변화가 업데이트 됐을 때 바뀐다.

**minor**는 기존 코드를 유지하면서 새로운 기능이 추가 되었을 때 사용한다.

**patch**는 버그를 수정했을 때 사용한다.

`예시`

```json
"dependencies": {
    "react": "^16.13.1",
    "react-dom": "^16.13.1",
    "react-scripts": "3.4.1",
    "react-spring": "^9.0.0-rc.3"
  },
```

다운 받은 패키지 숫자 앞에 ~와 ^가 있는 것을 볼 수 있다.

틸트(~)는 마이너 버전을 갱신한다. (ex. `~1.2.3`은 1.2.3부터 1.3.0 미만까지를 포함한다.)

캐럿(^)은 정식버전에서 마이너와 패치 버전을 변경한다. (ex. `^1.2.3`은 1.2.3부터 2.0.0 미만 까지를 포함한다.)

원래 React는 ~(틸트)로 버전관리를 진행했었지만, 이는 마이너 버전을 바꾸기 때문에 하위 호환성이 지켜지지 않아 에러가 날 수 있다. 때문에 현재는 ^(캐럿)로 진행하여, 마이너 버전을 업데이트하지 않고 패치버전만 업데이트 한다.

만약, 특정 버전의 패키지를 다운받고 싶다면 아래처럼 쓰면 된다:

```shell
npm install 패키지명@x.y.z
```

## 5. npm 명령어

### Getting help:

```shell
npm help # npm 관련 도움
npm  -h # 특정 command 도움
```


npm help 쳤을 때 화면

### Installing packages:

두 가지 설치 방법이 있다.

첫 번째, 오직 현재 폴더(directory)에서만 패키지를 사용할 것이라면 **로컬**에 설치 한다.

```shell
npm install 패키지명
```

두 번째, 현재 폴더뿐만 아니라 어디서든 패키지를 사용할 것이라면 **전역**에 설치한다.

```shell
npm install 패키지명 -g
```

### Updating packages:

설치한 패키지가 새로운 기능을 가진 버전으로 업데이트 될 때가 있다.

이럴 때 update란 명령어를 사용하면 된다.

```shell
npm update 패키지명    # 특정 패키지 업데이트
npm update            # 전체 패키지 업데이트
npm update 패키지명 -g # 전역 패키지 업데이트
```

### Uninstalling packages:

설치했던 패키지가 더이상 필요 없어진다면 패키지를 삭제해서 `node_modules`안의 내용도 없애 주는 것이 좋다.

```shell
npm uninstall 패키지명
# or
npm r 패키지명

# 전역에서 삭제
npm uninstall 패키지명 -g
# or
npm r 패키지명 -g
```

### Installing from package.json:

프로젝트를 공유할 때 용량이 큰 _node modules_ 를 공유하기보단, `package.json`을 공유하면 다른 사람도 쉽게 패키지를 다운 받을 수 있다.

```shell
npm install
```

### List of installed packages:

설치한 패키지를 확인하는 방법은 직접 `package.json`을 열어보는 방법과 CLI에 치는 방법이 있다.

```shell
npm list
```

## 6. npm 배포하기

npm 배포를 하려면 먼저 [npm 회원가입](https://www.npmjs.com/signup)이 필요하다.

### npm 로그인

회원가입을 했다면 터미널에서 `npm login`을 입력하고 계정 정보를 입력해야 한다.

```shell
$ npm login
# Username:
# Password:
# Email
Logged in as howdy-mj on https://registry.npmjs.org/
```

제대로 로그인이 됐는지 확인하고 싶다면 `npm whoami`를 입력하면 본인의 Username이 출력될 것이다.

### 패키지명 결정

패키지를 배포하기 위해서는 패키지명을 정해야 한다.

사용하고 싶은 패키지명이 중복되는지 npm 사이트에서 검색하거나, 터미널에서 `npm info 패키지명`을 입력하면 확인할 수 있다.

정보가 나온다면 이미 존재하는 패키지명이고, `404` 에러가 뜨면 아직 없는 패키지명이라 사용 가능하다.

### 패키지 생성

우선 `howdy-first`라는 폴더를 만들고 안에 `package.json` 파일을 만들어 주겠다.

package.json

```json
{
  "name": "howdy-first",
  "version": "0.1.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "MIT"
}
```

_해당 패키지를 배포할 때는 name과 version만 썼다_

### 패키지 배포

이제 터미널에 `npm publish`를 입력하면 배포가 완료된다.

```shell
$ npm publish
D:\VSCode\hooks-practice\src\howdy-first>npm publish
npm notice
npm notice package: howdy-first@0.0.0
npm notice === Tarball Contents ===
npm notice 589B UseTitle.js
npm notice 54B  package.json
npm notice === Tarball Details ===
npm notice name:          howdy-first
npm notice version:       0.0.0
...,
+ howdy-first@0.0.0
```

[howdy-first 패키지 보러가기](https://www.npmjs.com/package/howdy-first)

피드백은 언제나 환영합니다!



**참고**



- https://www.npmjs.com/
- https://medium.com/beginners-guide-to-mobile-web-development/introduction-to-npm-and-basic-npm-commands-18aa16f69f6b
- https://medium.com/@shgautam/why-package-json-npm-basics-cab3e8cd150
- https://www.daleseo.com/js-npm-publish/


</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/storybook/02-addon-intro</guid>
      <title>Storybook: Actions, Knobs, Docs addon 소개 및 설치</title>
      <link>https://www.howdy-mj.me/storybook/02-addon-intro</link>
      undefined
      <pubDate>Tue, 02 Jun 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>storybook</category>
      <content:encoded>
## 1. addon이란?

addon은 Storybook의 plugin과 비슷한 역할로 고급 기능을 지원하고 새로운 워크플로우를 제공해준다.

대표적인 addon은 Knobs, Actions, Source, Docs, Viewport, Storyshots, Backgrounds, Accessibility, Console, Links가 있으며 더 자세한 내용은 [홈페이지](https://storybook.js.org/addons/)에서 확인 가능하다.

_해당 글은 Storybook 5.3 기준으로 작성되었습니다._



이번 글에서는 Actions, Knobs, Docs의 정의와 기본 세팅에 알아 보겠다.

### Actions

원래 Actions도 따로 설치를 해야 되는걸로 아는데, 업데이트 되면서 바뀌었는지 storybook을 설치하면 actinos도 같이 설치되어 있다.

`.storybook/main.js`

```js{5}
module.exports = {
  stories: ['../src/**/*.stories.js'],
  addons: [
    '@storybook/preset-create-react-app',
    '@storybook/addon-actions',
    '@storybook/addon-links',
  ],
}
```

`package.json`

```json{5}
...,
"devDependencies": {
    "@storybook/addon-actions": "^5.3.19",
    "@storybook/addon-links": "^5.3.19",
    "@storybook/addons": "^5.3.19",
    "@storybook/preset-create-react-app": "^3.0.0",
    "@storybook/react": "^5.3.19"
}
```

만약 설치가 안되어있다면, 아래처럼 입력하면 된다.

```shell
$ npm install --save-dev @storybook/addon-actions
```

설치 후, `.sotrybook/main.js`에 아래 코드를 추가한다.

```js
module.exports = {
  addons: ['@storybook/addon-actions/register'],
}
```



우선 storybook에 기본으로 세팅되어 있는 Button을 보자.

```
src
└─ stories
    ├─ 0-Weclome.stories.js
    └─ 1-Button.sotries.js
```

버튼을 클릭하게 되면 아래 `Actions`탭에 clicked한 내용이 뜬다.

![actions](https://user-images.githubusercontent.com/58619071/193442836-e53fe271-da13-49b9-ba92-aa85065aa519.png)

더 정확하게는, Actions는 Componenet를 통해 특정 함수가 호출 되었을 때, 어떤 함수가 어떤 parameter를 넣어서 호출되었는지에 대한 정보를 알려준다.



### Knobs

Knobs는 component의 props를 스토리북 화면에서 바로 반영시켜주는 것이다.

**Knobs 설치**

```shell
$ npm install --save-dev @storybook/addon-knobs
```

설치 후, `.sotrybook/main.js`에 아래 코드를 추가한다.

```js
module.exports = {
  addons: ['@storybook/addon-knobs/register'],
}
```

실행했던 storybook을 껐다가 다시 키면 Knobs 탭이 추가된 걸 확인할 수 있다.

![knobs](https://user-images.githubusercontent.com/58619071/193442837-6a31bde7-057d-4f10-8453-53a8365a23fc.png)

아직 기능이 없기 때문에 Knobs 탭에도 아무것도 보이지 않는다.

**왜?**
이상하게 나는 Knobs를 깔 때마다 에러가 나서
`node_modules`랑 `package-lock.json`을 지우고 다시 `npm install`, `npm update`를 해야 정상적으로 작동된다...

```shell
$ rm -rf package-lock.json node_modules
$ npm install
$ npm update
$ npm audit fix
```

나중에 원인을 알게되면 글에 추가하겠다.



### Docs

Docs는 **MDX**(\*마크다운을 jsx와 결합한 파일 형식) 형식으로 문서를 작성할 수 있게 해주며, component의 props와 주석에 기반하여 문서를 자동으로 생성해준다.
MDX를 사용하면 마크다운으로 react component를 더 쉽게 문서화할 수 있다.

**Docs 설치**

```shell
$ npm install --save-dev @storybook/addon-docs
```

설치 후, `.sotrybook/main.js`에 아래 코드를 추가한다.

```js
module.exports = {
  stories: ['../src/**/*.stories.(js|mdx)'],
  addons: ['@storybook/addon-docs'],
}
```

storybook을 재실행하면 아래와 같이 Docs 탭이 생긴걸 볼 수 있다.

![docs](https://user-images.githubusercontent.com/58619071/193442839-18ab501b-6b04-4ccc-87bd-59d25e96044c.png)



이제 Actions, Knobs, Docs의 설치했으니, 다음 글에서 사용 방법에 대해 다뤄보겠다.
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/storybook/01-introduction</guid>
      <title>Storybook 소개</title>
      <link>https://www.howdy-mj.me/storybook/01-introduction</link>
      undefined
      <pubDate>Mon, 01 Jun 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>storybook</category>
      <content:encoded>
### 현존하는 프론트 개발의 불편함

최근 프론트엔드 개발은 주로 component 단위로 이루어진다. 특히, React에서도 Class Component 보다 Functional Component가 주로 사용된다.

하지만, 실제 개발 환경은 여전히 Component가 아니라 Page 단위로 진행되기 때문에, component 의존성이 있어 **재사용성이 높지 않다는 문제**가 있다.

분명 같은 속성으로 만들었지만, 어떤 페이지에서는 깨지는 경우가 있어 재설정을 해야만 했다.

그래서 Design System(디자인 시스템)이란 것이 도입됐다.

## Design System(디자인 시스템)

![](https://user-images.githubusercontent.com/58619071/193442765-a85eecfe-0d6b-4714-a65b-6899ddbdb36c.png)

https://product-unicorn.com/design-systems-style-guides-all-those-libraries-what-the-hell-is-the-difference-4c2741193fdc

디자인 시스템의 정의는 제각각이다.
따라서 그냥 내가 이해하기 가장 쉬웠던 정의로 가져왔다.

디자인 시스템은 하나의 서비스 혹은 상품에 적용되는 것으로, Style Guide(ex. 색상, 여백, 타이포그라피 등)과 Component Library(ex. 카드, 버튼, 네비게이션 등)을 포함한다.

즉, 디자인 시스템은

- 개발자와 디자이너의 효율적인 소통 및 협업
- 프로덕트 디자인에 대한 일관성 유지
- 디자인 요소들을 분리하여 재사용 가능한 Component로 만들기
  위해 나왔으며, 이를 위해 **'문서화'** 된 가이드가 필요하다.

디자인 코드의 문서화를 도와주는 도구 중 하나가 바로 Storybook📚이다.

## Storybook이란?

> Storybook runs outside of the main app so users can develop UI components in isolation without worrying about app specific dependencies and requirements.

스토리북은 외부 영향을 받지 않는 독립적인 UI Component이다.

(\*User Interface: 사용자와 컴퓨터가 상호작용할 수 있는 접점)

![](https://user-images.githubusercontent.com/58619071/193442767-e98a42cc-c53d-4951-8c7f-90467b264d1f.jpg)

https://www.learnstorybook.com/intro-to-storybook/react/en/get-started/

예전에는 디자이너의 요구대로 개발자가 만들고 적용한 후 테스트 단계에서 같이 확인했었다면, 스토리북이 있다면 개발자가 개발하면서 디자이너가 직접 보면서 확인할 수 있어 빠른 수정이 가능하다.

**Storybook 설치 및 실행**

CRA 환경에서 설치해야 한다.

```shell
# 원하는 폴더 위치에서
$ npx create-react-app 폴더명
$ cd 폴더명
$ npx -p @storybook/cli sb init

$ npm run storybook
# or
$ yarn storybook
```

![](https://user-images.githubusercontent.com/58619071/193442772-5a913463-e95f-4b4b-8dd2-be883a5bcbe0.png)

스토리북을 열면 9009 포트로 열리게 된다.
컴퓨터 사양에 따라 켜지는 속도가 다른거 같은데, 나는 조금 오래 걸리는 편인 것 같다.

![](https://user-images.githubusercontent.com/58619071/193442768-a427832f-0a81-454b-903e-b044b339df79.PNG)

storybook 첫 화면


storybook 폴더 구조



다음 글에서는 스토리북의 각종 편리한 기능을 제공해주는 addon을 다룰 것이다.
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/react-spring/04-render-props-api</guid>
      <title>react-spring: Render-props api</title>
      <link>https://www.howdy-mj.me/react-spring/04-render-props-api</link>
      undefined
      <pubDate>Sun, 31 May 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>react-spring</category>
      <content:encoded>
## Render-props api

react-spring 6.0(2018.10)까지는 Render-props api만 있었다.
Render-props api도 크게 5가지로 나뉜다.

- **Spring**: spring 혹은 springs의 데이터가 from: a => to: b로 움직이는 것
- **Trail**: list의 다른 아이템들이 첫번째 아이템을 따라 움직이는 것
- **Transition**: list의 아이템들이 추가/제거/업데이트 될 때 animation 발생
- **Keyframes**: animation들을 연결, 구성, 조율할 수 있는 것
- **Parallax**: 스크롤을 만드는 것



_해당 글은 react-spring 8.0 기준으로 작성되었다._

react-spring의 property는 [이전글](https://howdy-mj.me/react-spring/02-common-api/)을 참고하길 바란다.

### 1. Spring

Spring은 Hooks-api의 useSpring(s)와 비슷하다.



출처: [react-spring-examples](https://github.com/react-spring/react-spring-examples/tree/renderprops/demos/renderprops/auto)

```jsx
import { Spring, animated } from 'react-spring/renderprops'

const LOREM = `Hello world`

export default class App extends React.Component {
  state = { toggle: true, text: [LOREM] }
  onToggle = () => this.setState(state => ({ toggle: !state.toggle }))
  onAddText = () =>
    this.setState(state => ({ toggle: true, text: [...state.text, LOREM] }))
  onRemoveText = () =>
    this.setState(state => ({ toggle: true, text: state.text.slice(1) }))
  render() {
    const { toggle, text } = this.state
    return (
      
        Toggle
        Add text
        Remove text
        
          
            {props => (
              
                {text.map((t, i) => (
                  {t}
                ))}
              
            )}
          
        
      
    )
  }
}
```

useSpring과 크게 다를게 없기 때문에 바로 Trail로 넘어가겠다.



### 2. Trail

Trail 역시 useTrail과 비슷한데, native, from, immediate, onReset 등과 같은 spring properties도 사용 가능하며, Trail에서만 쓰이는 Props가 존재한다.

| Property  | Type              | Required  | Default       | Description                                                                                                     |
|:----------|:------------------|:----------|:--------------|:----------------------------------------------------------------------------------------------------------------|
| keys      | fn/undefined/any  | false     | item => item  | item의 keys(React에 넘겨주는 key와 동일) items를 지정한다면, keys는 접근자 함수가 될 수 있음(item => item.key)                            |
| from      | obj               | false     | -             | 기준 값                                                                                                            |
| to        | obj               | false     | -             | 바뀔 값                                                                                                            |
| items     | any/undefined     | true      | -             | 표시 될 items의 배열, 실제 items에 접근해서 특정 값을 넘겨야 할 때 사용                                                                 |
| children  | fn                | true      | -             | 하나의 item을 받는 단일 함수-자식(하위)으로 함수 컴포넌트를 리턴함 ex. (item, index) => props => view                                     |
| reverse   | bool              | false     | -             | true일 때, triling 순서가 bottom => top으로 바뀜                                                                         |



codesandbox에 구현되지 않아 코드로만 대체한다.

```jsx{28, 31}
import { Trail, animated } from 'react-spring/renderprops'

export default class TrailsExample extends React.PureComponent {
  state = {
    toggle: true,
    items: ['item1', 'item2', 'item3', 'item4', 'item5'],
  }
  toggle = () =>
    this.setState(state => ({
      toggle: !state.toggle,
    }))
  render() {
    const { toggle, items } = this.state
    return (
      
        
          {item => ({ x, opacity }) => (
             `translate3d(${x}%,0,0)`),
              }}
            />
          )}
        
      
    )
  }
}
```

```css
/** css */
.box {
  cursor: pointer;
  position: relative;
  width: 50%;
  height: 20%;
  background-color: #f3ffbd;
  will-change: transform;
}
```

예시 보러가기 : [TRAILS](https://www.react-spring.io/docs/props/trail)

여기서 `items`는 움직일 때 보여지는 박스 5칸을 뜻 하며, `onClick()`이 발동되었을 때 toggle 값이 바뀔 때 animation이 일어난다.

``에서 선언한 `opacity`와 `x`값을 그대로 ``의 props로 넘겨주기 위해 `{item => ({x, opacity}) => ()}`로 넘겨준다.



### 3. Transition

Transition도 useTransition과 같이 lifecycles에 따라 animation이 실행된다.

Transition은 모든 종류의 타입으로 이루어진 items으로 이루어져 있다. 마지막 기본값으로는 item => item인데, items이 key로 자급자족할 수 있는 경우가 많다.(??) items가 추가, 제거, 재정렬, 업데이트 될 때마다 애니메이션화 하는데 도움이 될 것이다.

item과 추가적으로 transition state(enter/leave/update)와 index를 받는 단일 함수-자식(하위)을 제공해야 한다. 전체적인 그림은 이것과 같다: `(item, state, index) => props => ReactNode`.

이미 삭제된 item을 render할 수 있으니 스코프 밖에서 값을 받는 것보다, 항상 함수로 받는 item들에 의존해야 한다. 하지만 이 item은 fade-out이 완료될 때 까지 Transition 내부에 보관 된다. 이는 routes에 굉장히 중요하다(?).

요약하자면, 필요한 경우 keys를 items에 표시하고, props로 넘겨주어 animation에 적용하면 된다.

### Transition Properties

native, from, immediate, onRest 등의 spring의 properties도 사용가능하다.

| Property     | Type    | Required  | Default       | Description                                                                                                                                                                                |
|:-------------|:--------|:----------|:--------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| keys         | union   | false     | item => item  | 일반적으로 list에서 React로 넘겨주는 key와 동일한 key. keys는 key-accessor로 함수, 배열 혹은 단일 값으로 지정될 수 있음                                                                                                       |
| unique       | bool    | false     | false         | true 일 때, 동일 한 key를 가진 두 개 이상의 items들이 stack에 공존하도록 허용하는 대신, 한 번만 발생할 수 있다고 강행                                                                                                             |
| reset        | bool    | false     | false         | 'unique'와 주로 같이 사용되며, true일 때, 현재 값에 적응하는 대신 이미 존재하는 들어오는 items이 다시 시작되도록 강행                                                                                                               |
| initial      | union   | false     | -             | 첫번째 render의 초기 값, 만약 값이 존재한다면 첫 render에서 "from"보다 우선 됨. 첫 mounting transition을 스킵하고 싶다면 "null"로 작성. object나 function을 가질 수 있음 (item => object)                                             |
| from         | union   | false     | -             | 기준 값 (from => enter), 혹은 item => values                                                                                                                                                    |
| enter        | union   | false     | -             | 들어오는(새로운) (entering) elements에 적용되는 값, 혹은 item => values                                                                                                                                   |
| leave        | union   | false     | -             | 없어지는(leaving) elements에 적용되는 값, 혹은 item => values                                                                                                                                          |
| update       | union   | false     | -             | 들어오지도 나가지도 않는 element에 적용되는 값(이 값을 사용하여 현재 elements를 업데이트 할 수 있음) , 혹은 item => values                                                                                                      |
| trail        | number  | false     | -             | 지연되는 시간(초 단위)                                                                                                                                                                              |
| config       | union   | false     | -             | Spring의 config 값, 혹은 각각의 keys에 해당: fn( (item, type) => key => config) 혹은 fn ( (item, type) => config) , "type"은 enter, leave, update가 될 수 있음                                               |
| onDestoryed  | fn      | false     | -             | transition이 끝날 때 콜백                                                                                                                                                                        |
| items        | union   | true      | -             | 표시할 items의 배열(또는 모든 타입의 단일 item) 이며, Transition에 의해 변경 사항을 탐지하는 주요 수단으로 사용                                                                                                                 |
| children     | fn      | true      | -             | 하나의 item을 받는 단일 함수-자식(하위)으로 함수 컴포넌트를 리턴함 ex. (item, index) => props => view                                                                                                                |



이것도 이상하게 codesandbox에서 구현되지 않아 코드만 올린다.

```jsx
import React from 'react'
import { Transition, animated } from 'react-spring/renderprops'
import './styles.css'

export default class App extends React.PureComponent {
  state = { show: true }
  toggle = e => this.setState(state => ({ show: !state.show }))
  render() {
    return (
      
        
          {show =>
            show && (props => hello)
          }
        
      
    )
  }
}
```

```css
/** css */
.reveals-main {
  width: 100%;
  height: 100%;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
}
.reveals-main > div {
  font-weight: 800;
  font-size: 4em;
  will-change: transform, opacity;
  overflow: hidden;
}
```

예시 보러가기 : [SIMPLE REVEALS](https://www.react-spring.io/docs/props/trail)

`onClick()`에 따라 toggle값이 바뀌면서 'Hello'란 글자가 사라졌다 보여진다.

```jsx

  {show => show && (props => hello)}

```

기본값으로 `height: 0`으로 되어 있으며, 클릭하면 `leave`로 바뀌어서 글자가 위에서 밑으로 사라진다. 그 후, 다시 클릭하면 `enter`가 실행되어 글자가 밑에서 올라오는 듯한 animation을 보여준다.



### 4. Keyframes

Keyframes은 springs나 trails의 기능을 확장하는 공장과 같다. 먼저 구현하고 싶은 한 개 이상의 animation을 named-slot으로 정의한다. 알수 없는 모든 props는 interpolate를 이용해 "to"로 설정한다. 이 외에도, from, config, reset 등의 모든 spring props를 사용할 수 있다. 이는 특별한 "state" prop을 가진 컴포넌트를 생성하고, 만들어 둔 slot 중 하나로 그 값을 받는다. 그러면 그것이 실행되면서 animation을 일으킬 것이다.

slot은 아래와 같은 것을 가질 수 있다:

- properties를 가진 object
- animation이 연결된(chained) objects의 배열
- loop를 만들 수 있는 함수

요약하자면, named-slots으로 Keyframe-object를 정의해야 한다.

### Keyframes Properties

resulting 컴포넌트는 native, from, immediate, onRest 등의 spring properties도 사용가능하다.

| Property  | Type    | Required  | Default      | Description           |
|:----------|:--------|:----------|:-------------|:----------------------|
| state     | string  | false     | \_\_default  | 활성화된 slot의 이름         |



codesandbox에서 delay를 넣으면 실행이 안돼서 빼고 가져왔더니 animation이 온전하지 못하다.
원본을 보고 싶다면 [SCRIPTED KEYFRAMES](https://www.react-spring.io/docs/props/keyframes) 여기서 확인하는 것을 추천한다.



```jsx{4, 53}
import { Keyframes, animated, config } from 'react-spring/renderprops'
// import delay from 'delay'

const Content = Keyframes.Spring(async next => {
  // None of this will cause React to render, the component renders only once :-)
  while (true) {
    await next({
      from: { opacity: 0, width: 50, height: 50, background: 'black' },
      opacity: 1,
      width: 80,
      height: 80,
      background: 'tomato',
    })
    await next({
      from: { left: '0%' },
      left: '70%',
      background: 'seagreen',
    })
    next({
      from: { top: '0%' },
      top: '40%',
      background: 'plum',
      config: config.wobbly,
    })
    // await delay(2000) // don't wait for the animation above to finish, go to the next one in 2s
    await next({ left: '0%', background: 'hotpink' })
    await next({
      top: '0%',
      background: 'teal',
    })
    await next({
      opacity: 0,
      width: 40,
      height: 40,
      background: 'black',
    })
  }
})

export default class App extends React.Component {
  render() {
    return (
      
        
          {props => (
            
          )}
        
      
    )
  }
}
```

Keyframes를 이용해 모든 Spring들을 묶어준다. 그리고 `await`를 이용해 animation이 일어날 순서를 정의한다.
위에서 정의한 모든 props를 `` 내부에서 가져와서 사용한다.

### 5. Parallax

Parallax는 시차(視差: 관측 위치에 따른 물체의 위치나 방향의 차이)란 뜻으로 주로 scroll container를 만들어 준다. 그리고 ParallaxLayers에 값을 넣어 offsets과 speeds등을 따라 움직일 수 있다.

### Parallax Properties

**1. Parallax**


| Property    | Type    | Required  | Default      | Description                                                  |
|:------------|:--------|:----------|:-------------|:-------------------------------------------------------------|
| config      | object  | false     | config.slow  | Spring config (선택)                                           |
| scrolling   | bool    | false     | true         | 스크롤 가능 여부                                                    |
| horizontal  | bool    | false     | false        | 스크롤의 가로, 세로 결정                                               |
| pages       | number  | true      | -            | 각 page에 100%를 차지하는 container의 내부 공간(space) 설정                |

**2. ParallaxLayer**


| Property  | Type    | Required  | Default  | Description                                            |
|:----------|:--------|:----------|:---------|:-------------------------------------------------------|
| factor    | number  | false     | 1        | page 사이즈 (1=100%, 1.5= 150%, ...)                      |
| offset    | number  | false     | 0        | layer가 언제 scroll될 지 결정 (0=start, 1=1page, ...)         |
| speed     | number  | false     | 0        | offset에 따라 layer 변경, 값은 +, - 값이 올수 있음                  |





오역이 있을 수 있습니다. 피드백은 언제나 환영합니다!
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/react-spring/03-hooks-api</guid>
      <title>react-spring: Hooks api</title>
      <link>https://www.howdy-mj.me/react-spring/03-hooks-api</link>
      undefined
      <pubDate>Sat, 30 May 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>react-spring</category>
      <content:encoded>
## Hooks api

Hooks api는 크게 5가지로 나뉜다.

- **useSpring**: 하나의 spring의 데이터가 from: a => to: b로 움직이는 것
- **useSprings**: 여러개의 springs, 각 데이터가 자신만의 상태로 움직이는 것 (dependency 존재)
- **useTrail**: 여러개의 springs가 하나의 데이터셋처럼 이전의 spring을 따라 움직이는 것 (dependency가 없음)
- **useTransition**: list의 아이템들이 추가/제거/업데이트 될 때 animation 발생
- **useChain**: 다수의 animation을 묶어서 연쇄적으로 발생



_해당 글은 react-spring 8.0 기준으로 작성되었다._

### 1. useSpring





```jsx{6}
import { useSpring, animated } from 'react-spring'
...

function App() {
  const [open, toggle] = useState(false)
  const [bind, { width }] = useMeasure()
  const props = useSpring({ width: open ? width : 0 })

  return (
     toggle(!open)}>
      
      
        {props.width.interpolate(x => x.toFixed(0))}
      
    
  )
}
```

`onClick()`을 했을 때, open이 `true`로 바뀌면서 div의 색상과 숫자를 채워주고 있다.

react-spring [introduction](https://howdy-mj.me/react-spring/01-introduction/) 글에서 썼듯이, Hooks api는 view를 모르기 때문에 `useMeasure()`라는 custom Hook으로 `{ width }`를 정의해서 return 안에 있는 `animated.div`에 알려주었다.

return문 안에 있는 두 개의 `animated.div`에 모두 props로 useSpring 값을 넘겨주었고, 만약 open이 `true`가 된다면, div의 width만큼 색상과 숫자(px)이 채워진다.



### 2. useSprings

_추후 업데이트_



### 2. useTrail





useTrail이 어떤 것인지 가장 잘 보여주는 예시인 것 같다.
마우스가 움직이는 대로 중간의 큰 동그라미가 따라온다.

```jsx
import { useTrail, animated } from 'react-spring'

const fast = { tension: 1200, friction: 40 }
const slow = { mass: 10, tension: 200, friction: 50 }
const trans = (x, y) => `translate3d(${x}px,${y}px,0) translate3d(-50%,-50%,0)`

export default function Goo() {
  const [trail, set] = useTrail(3, () => ({
    xy: [0, 0],
    config: i => (i === 0 ? fast : slow),
  }))
  return (
    <>
      
        
          
          
        
      
       set({ xy: [e.clientX, e.clientY] })}
      >
        {trail.map((props, index) => (
          
        ))}
      
    
  )
}
```

`fast`와 `slow`는 config의 mass, tension, friction으로 설정했다.
아직 spring들의 property를 모르겠다면, [전글](https://howdy-mj.me/react-spring/02-common-api/)을 참고하길 바란다.

`trans`에는 마우스의 x, y값 대로 움직일 것을 미리 정의했다.

```jsx{1}
const [trail, set] = useTrail(3, () => ({
  xy: [0, 0],
  config: i => (i === 0 ? fast : slow),
}))
```

spring을 선언할 때, 어떤 값에 바로 선언해도 되지만, 위에 처럼 함수로 return 값을 넣고 `set`을 이용해 업데이트 해줄 수도 있다.
`set`은 render를 하지 않고 그 위에 animation을 덮어 씌워 빠르게 업데이트 해줄 수 있다. 그리고 세번째 인자로 `stop`을 쓸 수 있어 함수를 멈출 수 있다.

여기서 `set`은 return 안의 `onMouseMove()`에서 마우스의 x, y값을 가져오고 이를 `trans`에 업데이트 해 줄 때 사용된다.

`useTrail`은 배열로 출력되어, return문에서 `trail`을 map을 돌려 사용한다.
이때 `useTrail( number, () => {})`에서 number는 따라 움직일 item의 개수이다.
해당 예시에서는 마우스를 빠르게 움직이면 세 개의 동그라미를 볼 수 있다. 해당 숫자를 2로 바꾼다면 마지막에 따라오는 동그라미가 없어진 걸 확인할 수 있다.

초기의 xy값은 모두 0이고, `i===0`일 때 마우스 가장 가까이 있는 동그라미가 가장 빠른 것이 온다. `i===1`일 경우, 동그라미는 2개로 바뀌면서 제일 빨랐던 동그라미가 없어지고, 가장 큰 동그라미가 선두에 선다. 그리고 `i=== 2`일 경우, 여전히 두 개의 동그라미로 이루어져있으며, `i===1`일때와 반대로 작은 동그라미가 선두에 있다. (아직 제대로 파악하지 못했다.. 알게되면 수정하겠다)

```jsx
 set({ xy: [e.clientX, e.clientY] })}
>
  {trail.map((props, index) => (
    
  ))}

```

위에서 선언한 `trans`를 props로 받으며, 마우스의 실시간 위치가 `set`으로 업데이트 되어 해당 위치로 `transform`하게 해준다.



### 2. useTransition

useTransition은 list의 아이템들이 lifecycles이 일어날 때 animation 발생한다.

useTransition의 인자로는 items, keys(atomic이라면 `null`이 될 수 있다), property에는 lifecycles가 있다.

따라서 useTransition만 따로 쓰는 properties가 존재한다.

#### useTransition Properties

| Property     | Type               | Description                                                                     |
|:-------------|:-------------------|:--------------------------------------------------------------------------------|
| initial      | obj/fn             | 최초값 (optional, null도 될 수 있음)                                                    |
| from         | obj/fn             | 기준 값 (optional)                                                                 |
| enter        | obj/fn/array(obj)  | animation이 시작할 때 적용되는 것                                                         |
| update       | obj/fn/array(obj)  | animation이 업데이트 될 때 적용되는 것 (자체 hook으로 새로운 값 업데이트 가능)                            |
| leave        | obj/fn/array(obj)  | animation이 끝날 때 적용되는 것                                                          |
| trail        | number             | animation 시작 시간 지연(초 단위), enter/update/leave에 추가 가능                             |
| unique       | bool/fn            | true라면, 들어가고 나오는 아이템들은 같은 key를 재 사용함                                            |
| reset        | ool/fn             | 'unique'와 같이 사용되며, enter 아이템들을 처음부터 시작하게 함                                      |
| onDestroyed  | fn                 | object들이 완전히 사라졌을 때 호출 됨                                                        |

이 외, common api도 같이 사용할 수 있다.



```jsx
import { useTransition, animated, config } from 'react-spring'

const slides = [
  {
    id: 0,
    url:
      'photo-1544511916-0148ccdeb877?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&w=1901&q=80i',
  },
  {
    id: 1,
    url:
      'photo-1544572571-ab94fd872ce4?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&w=1534&q=80',
  },
  {
    id: 2,
    url: 'reserve/bnW1TuTV2YGcoh1HyWNQ_IMG_0207.JPG?ixlib=rb-1.2.1&w=1534&q=80',
  },
  { id: 3, url: 'photo-1540206395-68808572332f?ixlib=rb-1.2.1&w=1181&q=80' },
]

const App = () => {
  const [index, set] = useState(0)
  const transitions = useTransition(slides[index], item => item.id, {
    from: { opacity: 0 },
    enter: { opacity: 1 },
    leave: { opacity: 0 },
    config: config.molasses,
  })
  useEffect(
    () => void setInterval(() => set(state => (state + 1) % 4), 2000),
    []
  )
  return transitions.map(({ item, props, key }) => (
    
  ))
}
```

`useTransition`도 `useTrail`처럼 값을 배열로 리턴하여, return문 에서 `transitions`를 map으로 돌릴 수 있다.

`setInterval()`로 2초마다 index 값을 올려서 사진을 무한 반복하고 있다.



### 2. useChain

useChain은 다른 spring들과 다르게 from => to가 아니라, spring 들의 순서를 정해주는 animation-hooks이다.
useChian을 사용하기 위해서는 `useRef()`로 ref를 선언해 주고, 밑에 `useChain([firstRef, secondRef])`를 적어주면 이 순서대로 animation을 실행시켜준다.

```jsx
// spring과 springRef 묶어주기
const springRef = useRef()
const spring = useSpring({ ...values, ref: springRef })

// transitions와 transitionRef 묶어주기
const transitionRef = useRef()
const transitions = useTransition({ ...values, ref: transitionRef })

// spring이 끝나고 transition 실행
useChain([springRef, transitionRef])

// Use the animated props like always
return (
  
    {transitions.map(({ item, key, props }) => (
      
    ))}
  
)
```

useChain의 두 번째 인자로 timeSteps를 정의할 수 있다. timeSteps는 0-1 사이의 숫자로 이루어진 배열로, 처음 시작 시간과 끝나는 시간을 정의할 수 있다.

```jsx
useChain([springRef, transitionRef], [0, 0.5] /*1000*/)
// springRef는 0.0 * 1000ms = 0ms로 바로 시작
// transitionRef는 0.5 * 1000ms = 500ms 뒤에 시작
```





이로써 react-spring의 Hooks api를 간단하게 훑어봤다.
아직 공부한지 얼마 안되어 부족한 부분이 많다. 수정하거나 추가할 것이 생기면 업데이트 할 예정이다.



오역이 있을 수 있습니다. 피드백은 언제나 환영합니다!
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/react-spring/02-common-api</guid>
      <title>react-spring: Common api</title>
      <link>https://www.howdy-mj.me/react-spring/02-common-api</link>
      undefined
      <pubDate>Fri, 29 May 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>react-spring</category>
      <content:encoded>
## Common api

### Configs

react-spring의 animation의 속도, 크기 등의 설정은 `config`를 통해 바꿀 수 있다.

ex. useSpring에 적용하고 싶다면:

```js
useSpring({ config: { duration: 250 }, ... })
```

| Property   | Default    | Description                                                                                                                               |
|:-----------|:-----------|:------------------------------------------------------------------------------------------------------------------------------------------|
| mass       | 1          | spring의 크기                                                                                                                                |
| tension    | 170        | spring의 움직이는 속도                                                                                                                           |
| friction   | 26         | spring의 마찰, 저항(클수록 반동이 없어짐)                                                                                                               |
| clamp      | false      | true일 때, spring의 경계를 넘으면 움직임이 멈춤                                                                                                          |
| precision  | 0.01       | 정밀도                                                                                                                                       |
| velocity   | 0          | 초속(初速)                                                                                                                                    |
| duration   | undefined  | 0보다 클 경우, spring-physics가 아닌 지속시간 기반 animation으로 바뀌며 초 단위로 표시됨 (ex. duration: 2500은 2.5초 동안 animation 실행                                  |
| easing     | t => t     | 선형이 기본값으로, [d3-ease](https://github.com/d3/d3-ease) 처럼 원하는 굴곡을 넣을 수 있음                                                                    |



### Presets

react-spring에서 자주 쓰일법한 config들을 미리 설정해주었다.

```jsx
import { ..., config } from 'react-spring'

useSpring({ ..., config: config.default })
```

| Property         | Value                                     |
|:-----------------|:------------------------------------------|
| config.default   | { mass: 1, tension: 170, friction: 26 }   |
| config.gentle    | { mass: 1, tension: 120, friction: 14 }   |
| config.wobbly    | { mass: 1, tension: 180, friction: 12 }   |
| config.stiff     | { mass: 1, tension: 210, friction: 20 }   |
| config.slow      | { mass: 1, tension: 280, friction: 60 }   |
| config.molasses  | { mass: 1, tension: 280, friction: 120 }  |



### Properties

모두 아래와 같은 property를 상속 받을 수 있다.

```jsx
useSpring({ from: { ... }, to: { ... }, delay: 100, onRest: () => ... })
```

| Property   | Type               | Description                                                                             |
|:-----------|:-------------------|:----------------------------------------------------------------------------------------|
| from       | obj                | 기준 값 (optional)                                                                         |
| to         | obj/fn/array(obj)  | 변경될 값                                                                                   |
| delay      | number/fn          | animaion 지연 시간(초 단위), 개별 key의 함수로 사용 가능: key => delay                                   |
| immediate  | bool/fn            | true일 경우 animation 중지, 개별 key의 함수로 사용 가능: key => immediate                              |
| config     | obj/fn             | spring config(mass, tension, friction 등 ), 개별 key의 함수로 사용 가능: key => config             |
| reset      | bool               | true일 경우, spring이 처음부터 animation 시작 (from => to)                                        |
| reverse    | bool               | true일 경우, "from"과 "to"가 바뀜                                                              |
| onStart    | fn                 | key가 animaten을 시작할 때 콜백                                                                 |
| onRest     | fn                 | 모든 animation이 정지 상태일 때 콜백                                                               |
| onFrame    | fn                 | frame 별 콜백, 첫 번째 전달 된 인자가 animated 값임                                                   |



### Interpolations

react-spring에는 Up-front interpolation과 View interpolation으로 나뉜다. 여기에선 View interpolation에 대해 다루겠다.

interpolate은 '보간하다, (중간값을) 채우다'란 의미로 그래픽과 관련된 작업에서 많이 쓰인다. (다른 글에서 더 자세히 다룰 예정이다)

clamp(어떤 값을 특정 범위의 값으로 고정)나 extrapolate(보외법, 범위 외의 값을 추정할 때)가 필요한 경우 사용되며, 각각의 animated 값은 view안에서 `interpolate`할 수 있다.
`value.interpolate`은 object나 function을 가질 수 있다.

| Value             | Default    | Description                                             |
|:------------------|:-----------|:--------------------------------------------------------|
| extrapolateLeft   | extend     | 왼쪽 extrapolate, identity/clamp/extend가 될 수 있음           |
| extrapolateRight  | extend     | 오른쪽 extrapolate, identity/clamp/extend가 될 수 있음          |
| extrapolate       | extend     | 좌우 extrapolate를 설정할 수 있는 단축값                            |
| range             | [0,1]      | input 범위 배열                                             |
| output            | undefined  | map으로 출력 된 output 범위 배열                                 |
| map               | undefined  | input 값에 적용된 값 필터                                       |

range를 짧게 쓰고 싶다면: `value.interpolate([...inputRange], [...outputRange])`
혹은 함수로도 쓸 수 있다: `value.interpolate(v => ...)`



이제 spring에 어떤 property가 있는지 알아보았으니, 다음엔 Hooks api에 대해 써보겠다.



오역이 있을 수 있습니다. 피드백은 언제나 환영합니다!
</content:encoded>
    </item>
  
    <item>
      <guid>https://www.howdy-mj.me/react-spring/01-introduction</guid>
      <title>react-spring 소개</title>
      <link>https://www.howdy-mj.me/react-spring/01-introduction</link>
      undefined
      <pubDate>Thu, 28 May 2020 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>react-spring</category>
      <content:encoded>
## 1. react-spring이란?

react-spring은 spring-physics 기반의 애니메이션 라이브러리로, 대부분의 UI 애니메이션을 지원한다.
본래 애니메이션은 퍼블리셔 단에서 많이 진행됐지만, 최근은 프론트엔드가 같이 하는 추세라 라이브러리가 많이 나오고 있다.

**react-spring 설치**

```shell
$ npm install react-spring
```

react-spring은 cross platform으로 웹, react-native, react-native-web 등의 플랫폼에서 다 사용 가능하다.

#### 왜 이름이 durations이 아니라 springs일까?

[react-spring 홈페이지](https://www.react-spring.io/)에 따르면, 모든 움직임은 만화처럼 깔끔하게 움직이는 경우는 거의 없으며, 항상 struggle(꿈틀거림)이 존재한다. 즉, 어느 움직임이든 한 번에(sync) 이루어지지 않고, 늘 time and curves(시간과 굴곡)에 영향을 받는다.
그래서 spring-physcis라는 단어를 사용한 것이 아닐까 추측해본다.

#### animated + react-motion 장점 = react-spring

애니메이션 라이브러리하면 [animated](https://github.com/animatedjs/animated)와 [react-motion](https://github.com/chenglou/react-motion)이 많이 나온다.
react-animated는 시간 기반의 애니메이션 라이브러리로 간단하게 start와 stop 메소드를 사용한다.
react-spring은 animated의 쉬운 사용과 react-motion의 간결한 구조를 합쳤다.

## 2. Hooks api, Render-props api

react-spring은 크게 Hooks, Render-props(Class)로 나뉜다.
Hooks api는 19년 2월에 도입되었다.

두 가지의 가장 큰 차이점은 Hooks는 view를 모른다.
만약 height를 해당 스코프 밖에서 선언했다면, Hooks의 경우 다른 해당 height를 알려주는 custom Hook을 사용해서 ``에 알려줘야 한다.

```jsx
const [bind, { height }] = useMeasure() // custom Hook
const props = useSpring({ height })
return (
  
    content
  
)
```

_(조금 더 이해도가 높아졌을 때 다시 수정할 예정이다.)_



이번 글에서 간단하게 Hooks와 Render-props의 구조를 살펴보자.
두 가지 모두 spring을 예로 들겠다.

#### (1) Hooks api 구조

```jsx
import { useSpring, animated } from 'react-spring'

function App() {
  const props = useSpring({ number: 1, from: { number: 0 } }) // spring 정의
  return {props.number} // return(내 view)에 animated 값 묶기
}
```

#### (2) Render-props api 구조

```jsx
import { Spring } from 'react-spring/renderprops'

function App() {
  return (
    // spring 정의
    
      // return
      {props => {props.number}}
    
  )
}
```

지금은 Hooks와 Render-props를 import 해오는 위치가 다르지만, react-spring 9.0(아직 배포 전)에서는 모두 `react-spring`에서 불러올 수 있다.

```jsx
import { Spring, useSpring } from 'react-spring'

// 아래처럼 import하는 것도 여전히 가능하다:
import { Spring } from 'react-spring/renderprops'
```



오역이 있을 수 있습니다. 피드백은 언제나 환영합니다!
</content:encoded>
    </item>
  
    </channel>
  </rss>
